<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Home on Outcome documentation</title>
    <link>https://ned14.github.io/outcome/</link>
    <description>Recent content in Home on Outcome documentation</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Tue, 19 Mar 2019 22:57:48 +0100</lastBuildDate>
    
	<atom:link href="https://ned14.github.io/outcome/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Before we begin</title>
      <link>https://ned14.github.io/outcome/tutorial/essential/before/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/tutorial/essential/before/</guid>
      <description>Outcome v2 namespace It is recommended that you refer to entities from this Outcome v2 via the following namespace alias:
namespace outcome = OUTCOME_V2_NAMESPACE; View this code on Github On standalone Outcome only, as patches and modifications are applied to this library, namespaces get permuted in order to not to cause binary incompatibility. At some point namespace outcome_v2 will be defined, and this will be the preferred namespace. Until then OUTCOME_V2_NAMESPACE denotes the most recently updated version, getting closer to outcome_v2.</description>
    </item>
    
    <item>
      <title>Incommensurate E types</title>
      <link>https://ned14.github.io/outcome/tutorial/advanced/interop/problem/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/tutorial/advanced/interop/problem/</guid>
      <description>Back in the essential tutorial section on result, we studied a likely very common initial choice of E type: a strongly typed enum. We saw how by marking up strongly typed enums to tell the C++ standard library what they are, they gain implicit convertibility into std::error_code, and we then pointed out that you might as well now always set E = std::error_code, as that comes with the enormous advantage that you can use the boilerplate saving OUTCOME_TRY macro when the E type is always the same.</description>
    </item>
    
    <item>
      <title>The main advantages</title>
      <link>https://ned14.github.io/outcome/experimental/advantages/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/experimental/advantages/</guid>
      <description>The main advantages of choosing &amp;lt;outcome/experimental&amp;gt; over default Outcome:
 Codegen is tighter and less verbose1, sometimes remarkably so.
 Build time impact is markedly lower, barely above the inclusion of naked &amp;lt;basic_result.hpp&amp;gt;, as the STL allocator machinery and std::string et al is not dragged into inclusion by including &amp;lt;system_error&amp;gt;. Note that &amp;lt;outcome/experimental/status_outcome.hpp&amp;gt; bring in &amp;lt;exception&amp;gt;, however &amp;lt;outcome/experimental/status_result.hpp&amp;gt; brings in no extra system headers.
 More discipline is imposed on your use of Outcome, leading to less ambiguous code which is easier to optimise by the compiler, lower cost to maintain, and lower cognitive load to audit code based on experimental Outcome for correctness.</description>
    </item>
    
    <item>
      <title>ValueOrError Concept</title>
      <link>https://ned14.github.io/outcome/tutorial/advanced/interop/value-or-error/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/tutorial/advanced/interop/value-or-error/</guid>
      <description>Something not really mentioned until now is how Outcome interoperates with the proposed  P0323 std::expected&amp;lt;T, E&amp;gt;, whose design lands in between unchecked&amp;lt;T, E = varies&amp;gt; and checked&amp;lt;T, E = varies&amp;gt; (both of which are type aliases hard coding no-value policies as previously covered in this tutorial).
Expected and Outcome are isomorphic to one another in design intent, but interoperation for code using Expected and Outcome ought to be seamless thanks to the proposed ValueOrError concept framework, a subset of which Outcome implements.</description>
    </item>
    
    <item>
      <title>A custom no-value policy</title>
      <link>https://ned14.github.io/outcome/tutorial/essential/no-value/custom/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/tutorial/essential/no-value/custom/</guid>
      <description>If you want your basic_outcome&amp;lt;&amp;gt; or basic_result&amp;lt;&amp;gt; instances to call std::abort() whenever .value() is called on an object that does not contain a value, or .error() is called on an object that does not contain an error, you will need to define your own no-value policy as follows:
struct abort_policy : outcome::policy::base { template &amp;lt;classImpl&amp;gt; static constexpr void wide_value_check(Impl &amp;amp;&amp;amp;self) { if(!base::_has_value(std::forward&amp;lt;Impl&amp;gt;(self))) std::abort(); } template &amp;lt;classImpl&amp;gt; static constexpr void wide_error_check(Impl &amp;amp;&amp;amp;self) { if(!</description>
    </item>
    
    <item>
      <title>Approximate map between error code designs</title>
      <link>https://ned14.github.io/outcome/experimental/map/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/experimental/map/</guid>
      <description>Much of the design of Boost.System (which went on to become &amp;lt;system_error&amp;gt;) has been retained in proposed &amp;lt;system_error2&amp;gt;, so an approximate map between &amp;lt;system_error2&amp;gt; and &amp;lt;system_error&amp;gt; and Boost.System can be given:
  C++ 17 &amp;lt;system_error&amp;gt;Boost.SystemProposed &amp;lt;system_error2&amp;gt;  std::errc boost::system::errc experimental::errc (almost identical)  std::error_category boost::system::error_category experimental::status_code_domain  std::generic_category boost::system::generic_category experimental::generic_code_domain  std::system_category boost::system::system_category One of: experimental::posix_code_domain (POSIX systems) experimental::win32_code_domain (Microsoft Windows) experimental::nt_code_domain (Microsoft Windows)   std::error_condition boost::system::error_condition No equivalent (deliberately removed as hindsight proved it to be a design mistake leading to much confusing and hard to audit for correctness code)  std::error_code boost::system::error_code One of: experimental::status_code&amp;lt;DomainType&amp;gt; const experimental::status_code&amp;lt;void&amp;gt; &amp;amp; experimental::status_code&amp;lt;erased&amp;lt;intptr_t&amp;gt;&amp;gt; (aliased to experimental::system_code) experimental::errored_status_code&amp;lt;DomainType&amp;gt; const experimental::errored_status_code&amp;lt;void&amp;gt; &amp;amp; experimental::errored_status_code&amp;lt;erased&amp;lt;intptr_t&amp;gt;&amp;gt; (aliased to experimental::error)   std::system_error boost::system::system_error One of: const experimental::status_error&amp;lt;void&amp;gt; &amp;amp; experimental::status_error&amp;lt;DomainType&amp;gt;   As is obvious from the above, in &amp;lt;system_error2&amp;gt; one must be much more specific and accurate with respect to intent and specification and desired semantics than with &amp;lt;system_error&amp;gt;.</description>
    </item>
    
    <item>
      <title>Define a custom code domain</title>
      <link>https://ned14.github.io/outcome/experimental/worked-example/preamble/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/experimental/worked-example/preamble/</guid>
      <description>Firstly let&amp;rsquo;s alias the experimental Outcome namespace into something less tedious to type, declare our custom status code type, and get started on defining the custom status code domain implementation.
namespace outcome_e = OUTCOME_V2_NAMESPACE::experimental; // To define a `file_io_error` which participates in the P1028 world // of `std::error`, we must first declare, then define, a custom code // domain which extends `posix_code` (the std error coding for POSIX // failures). The following is fairly standard boilerplate for defining // a custom code domain.</description>
    </item>
    
    <item>
      <title>Exceptions</title>
      <link>https://ned14.github.io/outcome/motivation/exceptions/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/motivation/exceptions/</guid>
      <description>Exceptions are the default mechanism in C++ for reporting, propagating and processing the information about function failures. Their main advantage is the ability to describe the &amp;ldquo;success dependency&amp;rdquo; between functions: if you want to say that calling function g() depends on the successful execution of function f(), you just put g() below f() and that&amp;rsquo;s it:
int a() { f(); g(); // don&amp;#39;t call g() and further if f() fails  return h(); // don&amp;#39;t call h() if g() fails }  In the C++ Standard terms this means that f() is sequenced before g().</description>
    </item>
    
    <item>
      <title>Keeping state</title>
      <link>https://ned14.github.io/outcome/tutorial/advanced/hooks/keeping_state/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/tutorial/advanced/hooks/keeping_state/</guid>
      <description>The first thing we are going to need is somewhere to store the stack backtrace. We could take the easier route and simply store it into an allocated block and keep the pointer as a custom payload in a result&amp;lt;T, std::pair&amp;lt;error_code, std::unique_ptr&amp;lt;stack_backtrace&amp;gt;&amp;gt;&amp;gt; (see previous section on Custom payloads). But let us assume that we care so deeply about bounded execution times that ever calling malloc is unacceptable.
We therefore are going to need some completely static and trivially typed storage perhaps kept per-thread to avoid the need to keep mutexes.</description>
    </item>
    
    <item>
      <title>Limitations</title>
      <link>https://ned14.github.io/outcome/experimental/c-api/limitations/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/experimental/c-api/limitations/</guid>
      <description>C++ has excellent two-way compatibility with the C ABI, but there are some limitations you must observe to write C++ code which C code can call without marshalling at the ABI boundary:
 A C++ function may not throw exceptions if it is safe to call from C, and so should always be marked noexcept.
 A C++ function should be annotated with extern &amp;quot;C&amp;quot; to prevent its symbol being mangled, and thus give it the C rather than C++ ABI.</description>
    </item>
    
    <item>
      <title>The Filesystem TS</title>
      <link>https://ned14.github.io/outcome/tutorial/advanced/payload/copy_file/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/tutorial/advanced/payload/copy_file/</guid>
      <description>Something which has long annoyed the purists in the C++ leadership is the problem of dual overloads in error_code capable standard library APIs.
Consider the copy_file() API from the Filesystem TS:
namespace filesystem { /*! Copies the file at path `from` to path `to`. \returns True if file was successfully copied. \throws On failure throws `filesystem_error(ec.message(), from, to, ec)` with `ec` being the error code reported by the operating system. */ bool copy_file(const path &amp;amp;from, const path &amp;amp;to); /*!</description>
    </item>
    
    <item>
      <title>The HTTP library</title>
      <link>https://ned14.github.io/outcome/tutorial/advanced/interop/httplib/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/tutorial/advanced/interop/httplib/</guid>
      <description>Let us imagine a simple application: it fetches a HTTP page using a HTTP library, sends it through HTML tidy via the htmltidy library, and then writes it to disc using a filelib library. So three third party libraries, two using Outcome in incompatible ways, and the third being a C library just for kicks.
Let us imagine that the HTTP library has the following public interface:
// This is some standalone library implementing high level HTTP namespace httplib { // These are the error code that this HTTP library can return  enum classstatus_code { success = 0, // not the HTTP success code of 200  // A subset of all HTTP status codes for brevity  bad_request = 400, access_denied = 401, logon_failed = 402, forbidden = 403, not_found = 404, internal_error = 500 }; // This is the error type that this HTTP library can return  struct failure { status_code status{status_code::success}; std::string url{}; // The failing URL  }; // Localise a result implementation to this library, holding  // the logic error of incorrect observation to mean program  // termination.</description>
    </item>
    
    <item>
      <title>Two phase construction</title>
      <link>https://ned14.github.io/outcome/tutorial/advanced/constructors/two-phase-init/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/tutorial/advanced/constructors/two-phase-init/</guid>
      <description>The first thing to do is to break your object&amp;rsquo;s construction into two phases:
 Place the object into a state where it can be legally destructed without doing any initialisation which could throw an exception (i.e. everything done in phase 1 is constexpr). This phase usually involves initialising member variables to various default values, most often using default member initialisers. Most standard C++ library objects and containers have constexpr constructors, and thus can be initialised during phase 1.</description>
    </item>
    
    <item>
      <title>The HTMLTidy library</title>
      <link>https://ned14.github.io/outcome/tutorial/advanced/interop/tidylib/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/tutorial/advanced/interop/tidylib/</guid>
      <description>// There actually is a library for tidying HTML into XHTML called HTMLTidy // See http://www.html-tidy.org/ // HTMLTidy is actually a great tool for dealing with 1990s-era tag soup // HTML, I highly recommend it.  // This isn&amp;#39;t the API for Tidy, but let&amp;#39;s assume it&amp;#39;s a C library returning // errno domained error codes. out must be freed with free() after use. extern &amp;#34;C&amp;#34; int tidy_html(char **out, size_t *outlen, const char *in, size_t inlen); View this code on Github A C API may not initially appear to be a T|E based API, but if failure returns some domained error code and causes no other effects, and success returns some value, then it is effectively a &amp;ldquo;split&amp;rdquo; T|E API.</description>
    </item>
    
    <item>
      <title>A file handle</title>
      <link>https://ned14.github.io/outcome/tutorial/advanced/constructors/file_handle/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/tutorial/advanced/constructors/file_handle/</guid>
      <description>Borrowing from llfio::file_handle which uses this design pattern1, here is a simplified file_handle implementation:
classfile_handle { int _fd{-1}; // file descriptor  struct stat _stat { 0 }; // stat of the fd at open  // Phase 1 private constexpr constructor  constexpr file_handle() {} public: using path_type = filesystem::path; //! The behaviour of the handle: does it read, read and write, or atomic append?  enum classmode : unsigned char // bit 0 set means writable  { unchanged = 0, none = 2, //!</description>
    </item>
    
    <item>
      <title>ADL bridging</title>
      <link>https://ned14.github.io/outcome/tutorial/advanced/hooks/adl_bridging/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/tutorial/advanced/hooks/adl_bridging/</guid>
      <description>In a previous section, we used the failure_info type to create the ADL bridge into the namespace where the ADL discovered outcome_throw_as_system_error_with_payload() function was to be found.
Here we do the same, but more directly by creating a thin clone of std::error_code into the local namespace. This ensures that this namespace will be searched by the compiler when discovering the event hooks.
namespace error_code_extended { // Use the error_code type as the ADL bridge for the hooks by creating a type here  // It can be any type that your localised result uses, including the value type but  // by localising the error code type here you prevent nasty surprises later when the  // value type you use doesn&amp;#39;t trigger the ADL bridge.</description>
    </item>
    
    <item>
      <title>Built-in policies</title>
      <link>https://ned14.github.io/outcome/tutorial/essential/no-value/builtin/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/tutorial/essential/no-value/builtin/</guid>
      <description>These are the predefined policies built into Outcome:
&amp;nbsp;
all_narrow If there is an observation of a value/error/exception which is not present, the program is put into a hard undefined behaviour situation. The compiler literally compiles no code for an invalid observation &amp;ndash; the CPU &amp;ldquo;runs off&amp;rdquo; into the unknown.
As bad as this may sound, it generates the most optimal code, and such hard UB is very tool-friendly for detection e.</description>
    </item>
    
    <item>
      <title>Example C&#43;&#43; function</title>
      <link>https://ned14.github.io/outcome/experimental/c-api/example/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/experimental/c-api/example/</guid>
      <description>Let us start with a simple C++ function which we wish to make available to C code:
namespace outcome_e = OUTCOME_V2_NAMESPACE::experimental; // Fill the supplied buffer with the integer v converted to a string, // returning length of string minus null terminator outcome_e::status_result&amp;lt;size_t&amp;gt; to_string(char *buffer, size_t bufferlen, int v) noexcept { try { // Could throw an exception!  std::string temp(std::to_string(v)); // Will this string exceed the supplied buffer?  if(temp.</description>
    </item>
    
    <item>
      <title>Inspecting result&lt;T, EC&gt;</title>
      <link>https://ned14.github.io/outcome/tutorial/essential/result/inspecting/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/tutorial/essential/result/inspecting/</guid>
      <description>Suppose we will be writing a function print_half that takes a std::string representing an integer and prints half the integer:
outcome::result&amp;lt;void&amp;gt; print_half(const std::string&amp;amp; text); View this code on Github The type result&amp;lt;void&amp;gt; means that there is no value to be returned upon success, but that the operation might still fail, and we may be interested in inspecting the cause of the failure. The class template result&amp;lt;&amp;gt; is declared with the attribute [[nodiscard]], which means the compiler will warn you if you forget to inspect the returned object (in C++ 17 or later).</description>
    </item>
    
    <item>
      <title>Major differences</title>
      <link>https://ned14.github.io/outcome/experimental/differences/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/experimental/differences/</guid>
      <description>The major design differences between &amp;lt;system_error&amp;gt; and proposed &amp;lt;system_error2&amp;gt; are as follows:
 experimental::status_code&amp;lt;DomainType&amp;gt; can represent warnings and form-of-success codes as well as failure codes. experimental::errored_status_code&amp;lt;DomainType&amp;gt; is more similar to std::error_code, in that it can only represent failures (this is enforced by C++ 20 contract or runtime assertion check).
 The code&amp;rsquo;s domain implementation defines the payload type to be transported around by experimental::status_code&amp;lt;DomainType&amp;gt;, rather than it being hardcoded to int as in std::error_code.</description>
    </item>
    
    <item>
      <title>The File I/O library</title>
      <link>https://ned14.github.io/outcome/tutorial/advanced/interop/filelib/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/tutorial/advanced/interop/filelib/</guid>
      <description>The File I/O library we shall be using is very similar to the one we saw earlier in this tutorial:
// You may remember this from the tutorial section on Custom Payloads namespace filelib { // Error code + paths related to a failure. Also causes ADL discovery  // to check this namespace.  struct failure_info { std::error_code ec; path path1{}, path2{}; }; // Tell Outcome that failure_info is to be treated as a std::error_code  inline const std::error_code &amp;amp;make_error_code(const failure_info &amp;amp;fi) { return fi.</description>
    </item>
    
    <item>
      <title>The payload</title>
      <link>https://ned14.github.io/outcome/experimental/worked-example/value_type/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/experimental/worked-example/value_type/</guid>
      <description>We define the code domain&amp;rsquo;s value_type &amp;ndash; the payload to be transported by status codes using this code domain &amp;ndash; to be a POSIX errno value, an integer line number and a const char pointer.
public: // This is the value type for `file_io_error`. We add line number and source file path.  struct value_type { typename outcome_e::posix_code::value_type errcode; // from POSIX, as we inherit from _posix_code_domain  // Our additional payload  int lineno; // from __LINE__  const char *file; // from __FILE__  // Could also place a backtrace of void *[16] here .</description>
    </item>
    
    <item>
      <title>Upgrading the Filesystem TS</title>
      <link>https://ned14.github.io/outcome/tutorial/advanced/payload/copy_file2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/tutorial/advanced/payload/copy_file2/</guid>
      <description>An Outcome based solution to the dual overload problem is straightforward:
namespace filesystem2 { // Error code + paths related to a failure. Also causes ADL discovery to check this namespace.  struct failure_info { std::error_code ec; path path1, path2; }; // Tell Outcome that failure_info is to be treated as a std::error_code  inline const std::error_code &amp;amp;make_error_code(const failure_info &amp;amp;fi) { return fi.ec; } // Localise an outcome implementation specific to this namespace.</description>
    </item>
    
    <item>
      <title>errno</title>
      <link>https://ned14.github.io/outcome/motivation/errno/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/motivation/errno/</guid>
      <description>The idiom of returning, upon failure, a special value and storing an error code (an int) inside a global (or thread-local) object errno is inherited from C, and used in its Standard Library:
int readValue(const char * filename) { FILE* f = fopen(filename, &amp;#34;r&amp;#34;); if (f == NULL) return 0; // special value indicating failure  // keep errno value set by fopen()  int i; int r = fscanf(f, &amp;#34;%d&amp;#34;, &amp;amp;i); if (r == 0 || r == EOF) { // special values: i not read  errno = ENODATA; // choose error value to return  return 0; fclose(f); errno = 0; // clear error info (success)  return i; }  One advantage (to some, and a disadvantage to others) of this technique is that it uses familiar control statements (if and return) to indicate all execution paths that handle failures.</description>
    </item>
    
    <item>
      <title>The Application</title>
      <link>https://ned14.github.io/outcome/tutorial/advanced/interop/app/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/tutorial/advanced/interop/app/</guid>
      <description>The application is of course also based on Outcome, and like the HTTP library is also of mixed-failure design in that failure can be returned via error code, type erased exception_ptr or indeed a C++ exception throw.
// This is the namespace of the application which is connecting together the httplib, // filelib and tidylib libraries into a solution. namespace app { // Create an ADL bridge so copy/move hooks will be searched for in this namespace  struct error_code : public std::error_code { // passthrough  using std::error_code::error_code; error_code() = default; error_code(std::error_code ec) : std::error_code(ec) { } }; // Localise an outcome implementation for this namespace  template &amp;lt;classT&amp;gt; using outcome = //  OUTCOME_V2_NAMESPACE::outcome&amp;lt;T, error_code /*, std::exception_ptr */&amp;gt;; using OUTCOME_V2_NAMESPACE::success; } // namespace app View this code on Github Here we localise a passthrough error_code solely for the purpose of ADL bridging, otherwise the localised outcome configured is the default one which comes with Outcome.</description>
    </item>
    
    <item>
      <title>Auto-throwing filesystem_error</title>
      <link>https://ned14.github.io/outcome/tutorial/advanced/payload/copy_file3/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/tutorial/advanced/payload/copy_file3/</guid>
      <description>Something not mentioned at all until now (and properly described in the next section, Default actions) is that Outcome can be programmed take various actions when the user tries to observe .value() when there is no value, and so on for the other possible state observations.
Seeing as we are replacing the throwing overload of copy_file() in the Filesystem TS with a result returning edition instead, it would make sense if an attempt to observe the value of an unsuccessful fs_result threw the exact same filesystem_error as the Filesystem TS does.</description>
    </item>
    
    <item>
      <title>Calling it from C</title>
      <link>https://ned14.github.io/outcome/experimental/c-api/example2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/experimental/c-api/example2/</guid>
      <description>Firstly we need to declare to C our result returning C++ function:
// Declare our C++ function&amp;#39;s returning result type. Only needs to be done once. // This declares an `status_result&amp;lt;size_t, system_code&amp;gt;` which is an alias to // `basic_result&amp;lt;size_t, status_code&amp;lt;erased&amp;lt;intptr_t&amp;gt;&amp;gt;&amp;gt;`. // // The first parameter is some unique identifier for this type which will be used // whenever we reference this type in the future. CXX_DECLARE_RESULT_SYSTEM(to_string_rettype, size_t); // Tell C about our extern C++ function `to_string()` extern CXX_RESULT_SYSTEM(to_string_rettype) _Z9to_stringPcmi(char *buffer, size_t bufferlen, int v); View this code on Github Now let&amp;rsquo;s call the C++ function from C:</description>
    </item>
    
    <item>
      <title>Error codes</title>
      <link>https://ned14.github.io/outcome/motivation/error_codes/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/motivation/error_codes/</guid>
      <description>Error codes are reasonable error handling technique, also working in C. In this case the information is also stored as an int, but returned by value, which makes it possible to make functions pure (side-effect-free and referentially transparent).
int readInt(const char * filename, int&amp;amp; val) { FILE* fd; int r = openFile(filename, /*out*/ fd); if (r != 0) return r; // return whatever error openFile() returned  r = readInt(fd, /*out*/ val); if (r !</description>
    </item>
    
    <item>
      <title>Hook result</title>
      <link>https://ned14.github.io/outcome/tutorial/advanced/hooks/hook_result/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/tutorial/advanced/hooks/hook_result/</guid>
      <description>We now tell Outcome that for every instance of our localised result&amp;lt;T&amp;gt;, that on failure construction only, we want custom code to be run which increments the current slot in TLS storage and writes the current stack backtrace into it.
namespace error_code_extended { // Specialise the result construction hook for our localised result  // We hook any non-copy, non-move, non-inplace construction, capturing a stack backtrace  // if the result is errored.</description>
    </item>
    
    <item>
      <title>Inspecting outcome&lt;T, EC, EP&gt;</title>
      <link>https://ned14.github.io/outcome/tutorial/essential/outcome/inspecting/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/tutorial/essential/outcome/inspecting/</guid>
      <description>Continuing with the previous example, in Layer3 we have function z which again reports failures via exceptions. It will call function h from Layer2_old which returns outcome&amp;lt;int&amp;gt; (which may store a double or an std::error_code or an std::exception_ptr). The goal is to unpack it to either the successful return value int or to throw an appropriate exception: if we are storing an std::exception_ptr just rethrow it. If we are storing an std::error_code throw it as std::system_error, which is designed to store std::error_code&amp;rsquo;s:</description>
    </item>
    
    <item>
      <title>Mapping the HTTP library into the Application `1/2`</title>
      <link>https://ned14.github.io/outcome/tutorial/advanced/interop/app-map-httplib1/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/tutorial/advanced/interop/app-map-httplib1/</guid>
      <description>Firstly, remember that we are the application writer who has the problem of integrating three third party libraries into our application&amp;rsquo;s Outcome-based failure handling mechanism. We cannot modify those third party library sources; we must be non-intrusive.
We start by dealing with the HTTP library. We will integrate this into our application by wrapping up httplib::failure into a custom STL exception type. We then type erase it into an exception_ptr instance.</description>
    </item>
    
    <item>
      <title>Phase 2 construction</title>
      <link>https://ned14.github.io/outcome/tutorial/advanced/constructors/static-constructor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/tutorial/advanced/constructors/static-constructor/</guid>
      <description>Its phase 2 constructor:
// Phase 2 static member constructor function, which cannot throw inline outcome::result&amp;lt;file_handle&amp;gt; file_handle::file(file_handle::path_type path, file_handle::mode mode) noexcept { // Perform phase 1 of object construction  file_handle ret; // Perform phase 2 of object construction  int flags = 0; switch(mode) { case mode::attr_read: case mode::read: flags = O_RDONLY; break; case mode::attr_write: case mode::write: flags = O_RDWR; break; case mode::append: flags = O_APPEND; break; default: return std::errc::invalid_argument; } ret.</description>
    </item>
    
    <item>
      <title>TRY operations</title>
      <link>https://ned14.github.io/outcome/tutorial/essential/result/try/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/tutorial/essential/result/try/</guid>
      <description>In the implementation of function print_half we have seen the usage of the macro OUTCOME_TRYV(expr)/OUTCOME_TRY(expr):
OUTCOME_TRY (i, BigInt::fromString(text));  The OUTCOME_TRY macro uses C macro overloading to select between two implementations based on the number of input parameters. If there is exactly one input parameter i.e. without the i, the control statement is roughly equivalent to:
auto&amp;amp;&amp;amp; __result = BigInt::fromString(text); if (!__result) return __result.as_failure();  Where __result is a compile time generated unique name.</description>
    </item>
    
    <item>
      <title>The constructor</title>
      <link>https://ned14.github.io/outcome/experimental/worked-example/constructor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/experimental/worked-example/constructor/</guid>
      <description>Code domains are 100% constexpr to construct and destruct, as are status codes. This enables the compiler to 100% instantiate both only in its mind, and to emit zero code and thus zero overhead.
Unfortunately it also means that it must be possible for each domain to be instantiated an infinite number of times, and being 100% in constexpr, any instances never have a unique address in memory either. Thus we cannot compare domains for equivalence using their address in memory, as  std::error_category does.</description>
    </item>
    
    <item>
      <title>Mapping the HTTP library into the Application `2/2`</title>
      <link>https://ned14.github.io/outcome/tutorial/advanced/interop/app-map-httplib2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/tutorial/advanced/interop/app-map-httplib2/</guid>
      <description>If you remember the tutorial section on the ValueOrError Concept, this is an example of how to implement a custom ValueOrError Concept converter in Outcome:
// Inject custom ValueOrError conversion OUTCOME_V2_NAMESPACE_BEGIN namespace convert { // Provide custom ValueOrError conversion from  // httplib::result&amp;lt;U&amp;gt; into any app::outcome&amp;lt;T&amp;gt;  template &amp;lt;classT, classU&amp;gt; //  struct value_or_error&amp;lt;app::outcome&amp;lt;T&amp;gt;, httplib::result&amp;lt;U&amp;gt;&amp;gt; { // False to indicate that this converter wants `result`/`outcome`  // to NOT reject all other `result`  static constexpr bool enable_result_inputs = true; // False to indicate that this converter wants `outcome` to NOT  // reject all other `outcome`  static constexpr bool enable_outcome_inputs = true; template &amp;lt;classX, //  typename = std::enable_if_t&amp;lt;std::is_same&amp;lt;httplib::result&amp;lt;U&amp;gt;, std::decay_t&amp;lt;X&amp;gt;&amp;gt;::value //  &amp;amp;&amp;amp; std::is_constructible&amp;lt;T, U&amp;gt;::value&amp;gt;&amp;gt; //  constexpr app::outcome&amp;lt;T&amp;gt; operator()(X &amp;amp;&amp;amp;src) { // Forward any successful value, else synthesise an exception ptr  return src.</description>
    </item>
    
    <item>
      <title>Custom exception ptr</title>
      <link>https://ned14.github.io/outcome/tutorial/advanced/hooks/poke_exception/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/tutorial/advanced/hooks/poke_exception/</guid>
      <description>If you merely want result to capture stack backtraces without calling a memory allocator and retaining any triviality of copy which is important for optimisation, you already have everything you need.
But let&amp;rsquo;s keep going by intercepting any construction of our localised outcome from our localised result, retrieving any stored backtrace and using it to synthesise an exception ptr with a message text including the backtrace. Firstly let us look at the function which synthesises the exception ptr:</description>
    </item>
    
    <item>
      <title>Mapping the File I/O library into the Application</title>
      <link>https://ned14.github.io/outcome/tutorial/advanced/interop/app-map-filelib/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/tutorial/advanced/interop/app-map-filelib/</guid>
      <description>To handle the File I/O library, once again we turn to custom ValueOrError converters:
// Inject custom ValueOrError conversion OUTCOME_V2_NAMESPACE_BEGIN namespace convert { // Provide custom ValueOrError conversion from filelib::result&amp;lt;U&amp;gt;  // into any app::outcome&amp;lt;T&amp;gt;  template &amp;lt;classT, classU&amp;gt; //  struct value_or_error&amp;lt;app::outcome&amp;lt;T&amp;gt;, filelib::result&amp;lt;U&amp;gt;&amp;gt; { // True to indicate that this converter wants `result`/`outcome`  // to NOT reject all other `result`  static constexpr bool enable_result_inputs = true; // False to indicate that this converter wants `outcome` to NOT  // reject all other `outcome`  static constexpr bool enable_outcome_inputs = true; template &amp;lt;classX, //  typename = std::enable_if_t&amp;lt;std::is_same&amp;lt;filelib::result&amp;lt;U&amp;gt;, std::decay_t&amp;lt;X&amp;gt;&amp;gt;::value //  &amp;amp;&amp;amp; std::is_constructible&amp;lt;T, U&amp;gt;::value&amp;gt;&amp;gt; //  constexpr app::outcome&amp;lt;T&amp;gt; operator()(X &amp;amp;&amp;amp;src) { // Forward any successful value  if(src.</description>
    </item>
    
    <item>
      <title>Phase 3</title>
      <link>https://ned14.github.io/outcome/tutorial/advanced/constructors/metaprogrammg1/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/tutorial/advanced/constructors/metaprogrammg1/</guid>
      <description>We have built our first two phases of construction for file_handle, and for some users they might be happy writing:
outcome::result&amp;lt;file_handle&amp;gt; fh1 = file_handle::file(&amp;#34;hello&amp;#34; /*, file_handle::mode::read */); if(!fh1) { std::cerr &amp;lt;&amp;lt; &amp;#34;Opening file &amp;#39;hello&amp;#39; failed with &amp;#34; &amp;lt;&amp;lt; fh1.error().message() &amp;lt;&amp;lt; std::endl; } View this code on Github &amp;hellip; and be done with it.
But wouldn&amp;rsquo;t it be nicer if we could instead write:
outcome::result&amp;lt;file_handle&amp;gt; fh2 = make&amp;lt;file_handle&amp;gt;{&amp;#34;hello&amp;#34; /*, file_handle::mode::read */}(); if(!</description>
    </item>
    
    <item>
      <title>String refs</title>
      <link>https://ned14.github.io/outcome/experimental/worked-example/string_ref/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/experimental/worked-example/string_ref/</guid>
      <description>&amp;lt;system_error2&amp;gt; does not use std::string to return possibly statically or dynamically allocated strings, and thus avoids dragging in a lot of the standard library which impacts build times.
Instead status code domains have a string_ref, which has a polymorphic implementation which may or may not manage a dynamic memory allocation using an atomic reference counter. Due to this polymorphism, you don&amp;rsquo;t need to worry which implementation is actually in use under the bonnet when you pass around string_ref instances.</description>
    </item>
    
    <item>
      <title>`status_result` and `status_outcome`</title>
      <link>https://ned14.github.io/outcome/experimental/status_result/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/experimental/status_result/</guid>
      <description>status_result and status_outcome are type aliases to basic_result&amp;lt;T, E, NoValuePolicy&amp;gt; and basic_outcome&amp;lt;T, EC, EP, NoValuePolicy&amp;gt; in the usual way, but with a defaulted NoValuePolicy which selects on the basis of status_code&amp;lt;DomainType&amp;gt; instead.
If the E type is not some status_code&amp;lt;&amp;gt;, the default policy selector will complain.
 The specifications are:
experimental::status_result&amp;lt;T, E = experimental::system_code&amp;gt; experimental::status_outcome&amp;lt;T, E = experimental::system_code, EP = std::exception_ptr&amp;gt;  So, the default E is the erased status code system_code, which can represent any generic_code, posix_code, win32_code, nt_code, com_code and many other integer error and status codings.</description>
    </item>
    
    <item>
      <title>std::error_code</title>
      <link>https://ned14.github.io/outcome/motivation/std_error_code/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/motivation/std_error_code/</guid>
      <description>Type std::error_code has been designed to be sufficiently small and trivial to be cheaply passed around, and at the same time be able to store sufficient information to represent any error situation from any library/sub-system in the world without a clash. Its representation is basically:
classerror_code { error_category* domain; // domain from which the error originates  int value; // numeric value of error within the domain };  Here, domain indicates the library from which the error originates.</description>
    </item>
    
    <item>
      <title>Mapping the HTMLTidy library into the Application</title>
      <link>https://ned14.github.io/outcome/tutorial/advanced/interop/app-map-tidylib/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/tutorial/advanced/interop/app-map-tidylib/</guid>
      <description>Once again, we create a custom STL exception type to represent failure from the HTMLTidy library. We also create an app namespace wrapper for the C tidy_html() function which is more C++ friendly.
namespace app { // Specialise an exception type for tidylib errors  struct tidylib_error : std::system_error { // passthrough  using std::system_error::system_error; tidylib_error() = default; explicit tidylib_error(int c) : std::system_error(c, std::generic_category()) { } }; // Create a C++ invoking wrapper for the tidylib C API, modifying data with the returned data,  // returing a unique_ptr to release storage on scope exit.</description>
    </item>
    
    <item>
      <title>C Macro API Reference</title>
      <link>https://ned14.github.io/outcome/experimental/c-api/reference/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/experimental/c-api/reference/</guid>
      <description>The C macro API header &amp;lt;outcome/experimental/result.h&amp;gt; consists of these macros:
 CXX_DECLARE_RESULT(ident, T, E) Declares to C a basic_result type uniquely identified by ident. T is available at the member variable .value, and E is available at the member variable .error. CXX_RESULT(ident) A reference to a previously declared result type with unique ident. CXX_RESULT_HAS_VALUE(r) Evaluates to 1 (true) if the input result has a value. CXX_RESULT_HAS_ERROR(r) Evaluates to 1 (true) if the input result has an error.</description>
    </item>
    
    <item>
      <title>Hook outcome</title>
      <link>https://ned14.github.io/outcome/tutorial/advanced/hooks/hook_outcome/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/tutorial/advanced/hooks/hook_outcome/</guid>
      <description>The final step is to add ADL discovered event hooks for the very specific case of when our localised outcome is copy or move constructed from our localised result.
You ought to be very careful that the noexcept-ness of these matches the noexcept-ness of the types in the outcome. You may have noticed that poke_exception() creates a std::string and appends to it. This can throw an exception. If the copy and/or move constructors of T, EC and EP are noexcept, then so will be outcome&amp;rsquo;s copy and/or move constructor.</description>
    </item>
    
    <item>
      <title>In use</title>
      <link>https://ned14.github.io/outcome/tutorial/advanced/interop/app-go/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/tutorial/advanced/interop/app-go/</guid>
      <description>This is how you might now write application code using these three libraries:
namespace app { // A markup function to indicate when we are ValueOrError converting  template &amp;lt;classT&amp;gt; inline outcome&amp;lt;typename T::value_type&amp;gt; ext(T &amp;amp;&amp;amp;v) { //  return outcome&amp;lt;typename T::value_type&amp;gt;(std::move(v)); } outcome&amp;lt;void&amp;gt; go() // NOT noexcept, this can throw STL exceptions e.g. bad_alloc  { // Note that explicit construction is required when converting between differing types  // of outcome and result.</description>
    </item>
    
    <item>
      <title>Plugging a library into std::error_code</title>
      <link>https://ned14.github.io/outcome/motivation/plug_error_code/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/motivation/plug_error_code/</guid>
      <description>This section illustrates how you can hook into the std::error_code system from the Standard Library in order to work with your own set of error codes. As is usually the case in C++, doing this is straightforward but requires typing boilerplate to tell the C++ STL about your custom error type. This is not part of Outcome library, but we still provide this short guide here, because how to do this is not well documented [1].</description>
    </item>
    
    <item>
      <title>Redefining `message()`</title>
      <link>https://ned14.github.io/outcome/experimental/worked-example/message/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/experimental/worked-example/message/</guid>
      <description>You may remember that our custom _file_io_error_domain inherits from outcome_e::posix_code::domain_type, and thus does not have to implement the many pure virtual functions required by outcome_e::status_code_domain.
What we do need to do is reimplement _do_message() to append the file and line information to the POSIX error description string returned by outcome_e::posix_code::domain_type. This causes the status code&amp;rsquo;s .message() observer to return a string with the extra payload information represented in text.
// Return a string describing a specific code.</description>
    </item>
    
    <item>
      <title>construct&lt;T&gt;</title>
      <link>https://ned14.github.io/outcome/tutorial/advanced/constructors/metaprogrammg2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/tutorial/advanced/constructors/metaprogrammg2/</guid>
      <description>First, we need a base definition for make&amp;lt;T&amp;gt;:
template &amp;lt;classT&amp;gt; struct make { outcome::result&amp;lt;T&amp;gt; operator()() const noexcept { //  static_assert(!std::is_same&amp;lt;T, T&amp;gt;::value, //  &amp;#34;make&amp;lt;T&amp;gt;() was not specialised for the type T supplied&amp;#34;); } }; View this code on Github This fails a static assert if the type is ever instantiated unspecialised.
We then specialise for make&amp;lt;file_handle&amp;gt;:
template &amp;lt;&amp;gt; struct make&amp;lt;file_handle&amp;gt; { file_handle::path_type _path; file_handle::mode _mode{file_handle::mode::read}; // Any other args, default initialised if necessary, follow here .</description>
    </item>
    
    <item>
      <title>Conclusion</title>
      <link>https://ned14.github.io/outcome/tutorial/advanced/interop/conclusion/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/tutorial/advanced/interop/conclusion/</guid>
      <description>This worked example was in fact excessively complex: a quicker route to achieving the same thing would be to add explicit converting constructors to app::error_code for each of the third party library E types. One then could have saved oneself with having to bother injecting custom converters into the OUTCOME_V2_NAMESPACE::convert namespace. If you control your application&amp;rsquo;s E type, then that is probably a better, and certainly simpler, approach.
However there are occasions when you don&amp;rsquo;t have control over the implementation of the destination E type e.</description>
    </item>
    
    <item>
      <title>Alternatives</title>
      <link>https://ned14.github.io/outcome/tutorial/advanced/constructors/metaprogrammg3/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/tutorial/advanced/constructors/metaprogrammg3/</guid>
      <description>No doubt many will dislike the two-stage invocation pattern i.e.
make&amp;lt;file_handle&amp;gt;{&amp;#34;hello&amp;#34;}();  So let us examine the most obvious alternative: a templated free function make&amp;lt;T&amp;gt;.
Due to the inability to partially specialise templated functions in C++, you need to use tagged overloading e.g.
template&amp;lt;class... Args&amp;gt; inline outcome::result&amp;lt;file_handle&amp;gt; make(std::in_place_type_t&amp;lt;file_handle&amp;gt;, Args&amp;amp;&amp;amp; ... args) { return file_handle::file(std::forward&amp;lt;Args&amp;gt;(args)...); } ... // Now you must always write this: make(std::in_place_type&amp;lt;file_handle&amp;gt;, &amp;#34;hello&amp;#34;);  Tagged overloading is fine for smaller projects, but for larger code bases:</description>
    </item>
    
    <item>
      <title>Constexpr domain source</title>
      <link>https://ned14.github.io/outcome/experimental/worked-example/source/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/experimental/worked-example/source/</guid>
      <description>Back in The constructor, we declared but did not implement a .get() function which returns a constexpr static instance of the domain. We implement this now:
// 100% constexpr instantiation constexpr _file_io_error_domain file_io_error_domain; inline constexpr const _file_io_error_domain &amp;amp;_file_io_error_domain::get() { return file_io_error_domain; } View this code on Github As this is 100% constexpr, it can be (and is under optimisation) implemented entirely in the mind of the compiler with no run time representation.</description>
    </item>
    
    <item>
      <title>Narrow contracts</title>
      <link>https://ned14.github.io/outcome/motivation/narrow_contract/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/motivation/narrow_contract/</guid>
      <description>A program&amp;rsquo;s thread of execution can enter a &amp;ldquo;disappointing&amp;rdquo; state for two reasons:
 due to disappointing situation in the environment (operating system, external input), or due to a bug in the program.  The key to handling these disappointments correctly is to identify to which category they belong, and use the tools adequate for a given category. In this tutorial when we say &amp;ldquo;error&amp;rdquo; or &amp;ldquo;failure&amp;rdquo; we only refer to the first category.</description>
    </item>
    
    <item>
      <title>Implicit conversion</title>
      <link>https://ned14.github.io/outcome/experimental/worked-example/implicit_conversion/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/experimental/worked-example/implicit_conversion/</guid>
      <description>Back in The payload, we mentioned that there was no default implicit conversion of file_io_error (status_code&amp;lt;_file_io_error_domain&amp;gt;) to error, as error is too small to hold _file_io_error_domain::value_type.
We can tell the framework about available implicit conversions by defining an ADL discovered free function make_status_code() which takes our custom status code as input, and returns an error:
// Now tell `error` how it can implicitly construct from `file_io_error`. // This is done by us defining a free function called `make_status_code()` // which is discovered using ADL.</description>
    </item>
    
    <item>
      <title>Tying it all together</title>
      <link>https://ned14.github.io/outcome/experimental/outcome/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/experimental/outcome/</guid>
      <description>Firstly let&amp;rsquo;s alias a more convenient form of status_result:
template &amp;lt;classT, classE = outcome_e::error&amp;gt; using result = // outcome_e::status_result&amp;lt;T, E, outcome_e::policy::default_status_result_policy&amp;lt;T, E&amp;gt;&amp;gt;; View this code on Github (The defaulting of default_result_policy is superfluous, it&amp;rsquo;s already the default)
What follows now is very standard Outcome code. Indeed, it would compile just fine under standard Outcome with only a few typedefs.
result&amp;lt;file_handle, file_io_error&amp;gt; open_file(const char *path) // models throws(file_io_error) { file_handle ret(::fopen(path, &amp;#34;r&amp;#34;)); if(ret) return ret; return file_io_error({errno, __LINE__, __FILE__}); } result&amp;lt;void&amp;gt; open_resource() // models throws(std::error) { for(;;) { result&amp;lt;file_handle, file_io_error&amp;gt; r = open_file(&amp;#34;some file&amp;#34;); if(r) break; file_io_error e = r.</description>
    </item>
    
    <item>
      <title>`basic_outcome() = delete`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_outcome/default/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_outcome/default/</guid>
      <description>The default constructor for basic outcome is always disabled.</description>
    </item>
    
    <item>
      <title>`basic_result() = delete`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_result/default/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_result/default/</guid>
      <description>The default constructor for basic result is always disabled.</description>
    </item>
    
    <item>
      <title>`static void _ub(Impl &amp;&amp;)`</title>
      <link>https://ned14.github.io/outcome/reference/policies/base/ub/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/policies/base/ub/</guid>
      <description>This is a special function which does compiler-specific stuff to tell the compiler that this function can never, ever, ever be executed. The compiler&amp;rsquo;s optimiser will hard assume that this function can never be executed, and will prune the possibility of it being executed completely. Generally this means that the code path stops dead, and if execution does proceed down this path, it will run off the end of a branch which doesn&amp;rsquo;t go anywhere.</description>
    </item>
    
    <item>
      <title>`basic_outcome(basic_outcome &amp;&amp;)`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_outcome/move_constructor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_outcome/move_constructor/</guid>
      <description>Move constructor.
Requires: that value_type, error_type and exception_type all implement a move constructor.
Complexity: Same as for value_type&amp;rsquo;s, error_type&amp;rsquo;s and exception_type&amp;rsquo;s move constructors. Constexpr, triviality and noexcept of underlying operations is propagated.
Guarantees: If an exception is thrown during the operation, the object is left in a partially completed state, as per the normal rules for the same operation on a struct.</description>
    </item>
    
    <item>
      <title>`basic_result(basic_result &amp;&amp;)`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_result/move_constructor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_result/move_constructor/</guid>
      <description>Move constructor.
Requires: that value_type and error_type both implement a move constructor.
Complexity: Same as for value_type&amp;rsquo;s and error_type&amp;rsquo;s move constructors. Constexpr, triviality and noexcept of underlying operations is propagated.
Guarantees: If an exception is thrown during the operation, the object is left in a partially completed state, as per the normal rules for the same operation on a struct.</description>
    </item>
    
    <item>
      <title>`basic_outcome(const basic_outcome &amp;)`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_outcome/copy_constructor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_outcome/copy_constructor/</guid>
      <description>Copy constructor.
Requires: that value_type, error_type and exception_type all implement a copy constructor.
Complexity: Same as for value_type&amp;rsquo;s, error_type&amp;rsquo;s and exception_type&amp;rsquo;s copy constructors. Constexpr, triviality and noexcept of underlying operations is propagated.
Guarantees: If an exception is thrown during the operation, the object is left in a partially completed state, as per the normal rules for the same operation on a struct.</description>
    </item>
    
    <item>
      <title>`basic_result(const basic_result &amp;)`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_result/copy_constructor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_result/copy_constructor/</guid>
      <description>Copy constructor.
Requires: that value_type and error_type both implement a copy constructor.
Complexity: Same as for value_type&amp;rsquo;s and error_type&amp;rsquo;s copy constructors. Constexpr, triviality and noexcept of underlying operations is propagated.
Guarantees: If an exception is thrown during the operation, the object is left in a partially completed state, as per the normal rules for the same operation on a struct.</description>
    </item>
    
    <item>
      <title>`basic_outcome &amp;operator=(basic_outcome &amp;&amp;)`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_outcome/move_assignment/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_outcome/move_assignment/</guid>
      <description>Move assignment.
Requires: that value_type, error_type and exception_type all implement move assignment.
Complexity: If the value_type for both is present, uses value_type&amp;rsquo;s move assignment operator, else either destructs or move constructs value_type as appropriate. error_type&amp;rsquo;s and exception_type&amp;rsquo;s move assignment operator are always used. Constexpr, triviality and noexcept of underlying operations is propagated.
Guarantees: If an exception is thrown during the operation, the object is left in a partially completed state, as per the normal rules for the same operation on a struct.</description>
    </item>
    
    <item>
      <title>`basic_result &amp;operator=(basic_result &amp;&amp;)`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_result/move_assignment/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_result/move_assignment/</guid>
      <description>Move assignment.
Requires: that value_type and error_type both implement move assignment.
Complexity: If the value_type for both is present, uses value_type&amp;rsquo;s move assignment operator, else either destructs or move constructs value_type as appropriate. error_type&amp;rsquo;s move assignment operator is always used. Constexpr, triviality and noexcept of underlying operations is propagated.
Guarantees: If an exception is thrown during the operation, the object is left in a partially completed state, as per the normal rules for the same operation on a struct.</description>
    </item>
    
    <item>
      <title>`basic_outcome &amp;operator=(const basic_outcome &amp;)`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_outcome/copy_assignment/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_outcome/copy_assignment/</guid>
      <description>Copy assignment.
Requires: that value_type, error_type and exception_type all implement copy assignment.
Complexity: If the value_type for both is present, uses value_type&amp;rsquo;s copy assignment operator, else either destructs or copy constructs value_type as appropriate. error_type&amp;rsquo;s and exception_type&amp;rsquo;s copy assignment operator is always used. Constexpr, triviality and noexcept of underlying operations is propagated.
Guarantees: If an exception is thrown during the operation, the object is left in a partially completed state, as per the normal rules for the same operation on a struct.</description>
    </item>
    
    <item>
      <title>`basic_result &amp;operator=(const basic_result &amp;)`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_result/copy_assignment/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_result/copy_assignment/</guid>
      <description>Copy assignment.
Requires: that value_type and error_type both implement copy assignment.
Complexity: If the value_type for both is present, uses value_type&amp;rsquo;s copy assignment operator, else either destructs or copy constructs value_type as appropriate. error_type&amp;rsquo;s copy assignment operator is always used. Constexpr, triviality and noexcept of underlying operations is propagated.
Guarantees: If an exception is thrown during the operation, the object is left in a partially completed state, as per the normal rules for the same operation on a struct.</description>
    </item>
    
    <item>
      <title>`~basic_outcome()`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_outcome/destructor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_outcome/destructor/</guid>
      <description>Destructor.
Requires: Always available.
Complexity: Same as for value_type&amp;rsquo;s, error_type&amp;rsquo;s and exception_type&amp;rsquo;s destructors. Constexpr, triviality and noexcept of underlying operations is propagated.</description>
    </item>
    
    <item>
      <title>`~basic_result()`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_result/destructor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_result/destructor/</guid>
      <description>Destructor.
Requires: Always available.
Complexity: Same as for value_type&amp;rsquo;s and error_type&amp;rsquo;s destructors. Constexpr, triviality and noexcept of underlying operations is propagated.</description>
    </item>
    
    <item>
      <title>`basic_outcome(Args...) = delete`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_outcome/disabling_catchall/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_outcome/disabling_catchall/</guid>
      <description>Disabling catchall constructor used to give useful diagnostic error when trying to use non-inplace constructors when predicate::constructors_enabled is false.
Requires: predicate::constructors_enabled is false.
Complexity: N/A.</description>
    </item>
    
    <item>
      <title>`basic_result(Args...) = delete`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_result/disabling_catchall/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_result/disabling_catchall/</guid>
      <description>Disabling catchall constructor used to give useful diagnostic error when trying to use non-inplace constructors when predicate::constructors_enabled is false.
Requires: predicate::constructors_enabled is false.
Complexity: N/A.</description>
    </item>
    
    <item>
      <title>`basic_outcome(X &amp;&amp;) = delete`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_outcome/disabling_implicit_constructor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_outcome/disabling_implicit_constructor/</guid>
      <description>Disabling implicit constructor used to give useful diagnostic error when trying to use implicit constructors when predicate::implicit_constructors_enabled is false.
Requires: predicate::implicit_constructors_enabled is false.
Complexity: N/A.</description>
    </item>
    
    <item>
      <title>`basic_result(X &amp;&amp;) = delete`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_result/disabling_implicit_constructor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_result/disabling_implicit_constructor/</guid>
      <description>Disabling implicit constructor used to give useful diagnostic error when trying to use implicit constructors when predicate::implicit_constructors_enabled is false.
Requires: predicate::implicit_constructors_enabled is false.
Complexity: N/A.</description>
    </item>
    
    <item>
      <title>`basic_outcome(R &amp;&amp;)`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_outcome/implicit_value_converting_constructor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_outcome/implicit_value_converting_constructor/</guid>
      <description>Implicit value_type constructor. Calls void hook_outcome_construction(T *, U &amp;amp;&amp;amp;) noexcept with this and R.
Requires: predicate::enable_value_converting_constructor&amp;lt;R&amp;gt; is true.
Complexity: Same as for value_type&amp;rsquo;s copy or move constructor. Constexpr, triviality and noexcept of underlying operations is propagated.</description>
    </item>
    
    <item>
      <title>`basic_result(R &amp;&amp;)`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_result/implicit_value_converting_constructor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_result/implicit_value_converting_constructor/</guid>
      <description>Implicit value_type constructor. Calls void hook_result_construction(T *, U &amp;amp;&amp;amp;) noexcept with this and R.
Requires: predicate::enable_value_converting_constructor&amp;lt;R&amp;gt; is true.
Complexity: Same as for value_type&amp;rsquo;s copy or move constructor. Constexpr, triviality and noexcept of underlying operations is propagated.</description>
    </item>
    
    <item>
      <title>`basic_outcome(S &amp;&amp;)`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_outcome/implicit_error_converting_constructor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_outcome/implicit_error_converting_constructor/</guid>
      <description>Implicit error_type constructor. Calls void hook_outcome_construction(T *, U &amp;amp;&amp;amp;) noexcept with this and S.
Requires: predicate::enable_error_converting_constructor&amp;lt;S&amp;gt; is true.
Complexity: Same as for error_type&amp;rsquo;s copy or move constructor. Constexpr, triviality and noexcept of underlying operations is propagated.</description>
    </item>
    
    <item>
      <title>`basic_result(S &amp;&amp;)`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_result/implicit_error_converting_constructor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_result/implicit_error_converting_constructor/</guid>
      <description>Implicit error_type constructor. Calls void hook_result_construction(T *, U &amp;amp;&amp;amp;) noexcept with this and S.
Requires: predicate::enable_error_converting_constructor&amp;lt;S&amp;gt; is true.
Complexity: Same as for error_type&amp;rsquo;s copy or move constructor. Constexpr, triviality and noexcept of underlying operations is propagated.</description>
    </item>
    
    <item>
      <title>`basic_outcome(ErrorCondEnum &amp;&amp;)`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_outcome/implicit_error_condition_converting_constructor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_outcome/implicit_error_condition_converting_constructor/</guid>
      <description>Implicit error_type from ErrorCondEnum constructor. Calls void hook_outcome_construction(T *, U &amp;amp;&amp;amp;) noexcept with this and ErrorCondEnum.
Requires: predicate::enable_error_condition_converting_constructor&amp;lt;R&amp;gt; is true.
Complexity: Same as for error_type&amp;rsquo;s copy or move constructor from the result of make_error_code(ErrorCondEnum). Constexpr, triviality and noexcept of underlying operations is propagated.
Guarantees: If an exception is thrown during the operation, the state of the input is left indeterminate.</description>
    </item>
    
    <item>
      <title>`basic_result(ErrorCondEnum &amp;&amp;)`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_result/implicit_error_condition_converting_constructor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_result/implicit_error_condition_converting_constructor/</guid>
      <description>Implicit error_type from ErrorCondEnum constructor. Calls void hook_result_construction(T *, U &amp;amp;&amp;amp;) noexcept with this and ErrorCondEnum.
Requires: predicate::enable_error_condition_converting_constructor&amp;lt;R&amp;gt; is true.
Complexity: Same as for error_type&amp;rsquo;s copy or move constructor from the result of make_error_code(ErrorCondEnum). Constexpr, triviality and noexcept of underlying operations is propagated.
Guarantees: If an exception is thrown during the operation, the state of the input is left indeterminate.</description>
    </item>
    
    <item>
      <title>`static bool _has_value(Impl &amp;&amp;) noexcept`</title>
      <link>https://ned14.github.io/outcome/reference/policies/base/has_value/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/policies/base/has_value/</guid>
      <description>Returns true if a value is present in the implementation passed in. Constexpr where possible.
Requires: Always available.
Complexity: Constant time.
Guarantees: Never throws an exception.</description>
    </item>
    
    <item>
      <title>`basic_outcome(P &amp;&amp;)`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_outcome/implicit_exception_converting_constructor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_outcome/implicit_exception_converting_constructor/</guid>
      <description>Implicit exception_type constructor. Calls void hook_outcome_construction(T *, U &amp;amp;&amp;amp;) noexcept with this and P.
Requires: predicate::enable_exception_converting_constructor&amp;lt;P&amp;gt; is true.
Complexity: Same as for exception_type&amp;rsquo;s copy or move constructor. Constexpr, triviality and noexcept of underlying operations is propagated.</description>
    </item>
    
    <item>
      <title>`basic_outcome(S &amp;&amp;, P &amp;&amp;)`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_outcome/implicit_error_exception_converting_constructor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_outcome/implicit_error_exception_converting_constructor/</guid>
      <description>Implicit error_type + exception_type constructor. Calls void hook_outcome_construction(T *, U &amp;amp;&amp;amp;, V &amp;amp;&amp;amp;) noexcept with this, S and P.
Requires: predicate::enable_error_exception_converting_constructor&amp;lt;S, P&amp;gt; is true.
Complexity: Same as for error_type&amp;rsquo;s and exception_type&amp;rsquo;s copy or move constructor. Constexpr, triviality and noexcept of underlying operations is propagated.</description>
    </item>
    
    <item>
      <title>`static bool _has_error(Impl &amp;&amp;) noexcept`</title>
      <link>https://ned14.github.io/outcome/reference/policies/base/has_error/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/policies/base/has_error/</guid>
      <description>Returns true if an error is present in the implementation passed in. Constexpr where possible.
Requires: Always available.
Complexity: Constant time.
Guarantees: Never throws an exception.</description>
    </item>
    
    <item>
      <title>`static bool _has_exception(Impl &amp;&amp;) noexcept`</title>
      <link>https://ned14.github.io/outcome/reference/policies/base/has_exception/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/policies/base/has_exception/</guid>
      <description>Returns true if an exception is present in the implementation passed in. Constexpr where possible.
Requires: Always available.
Complexity: Constant time.
Guarantees: Never throws an exception.</description>
    </item>
    
    <item>
      <title>`static bool _has_error_is_errno(Impl &amp;&amp;) noexcept`</title>
      <link>https://ned14.github.io/outcome/reference/policies/base/has_error_is_errno/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/policies/base/has_error_is_errno/</guid>
      <description>Returns true if the error code in the implementation passed in has a domain or category matching that of POSIX errno. Constexpr where possible.
Requires: Always available.
Complexity: Constant time.
Guarantees: Never throws an exception.</description>
    </item>
    
    <item>
      <title>`static auto &amp;&amp;_value(Impl &amp;&amp;) noexcept`</title>
      <link>https://ned14.github.io/outcome/reference/policies/base/value/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/policies/base/value/</guid>
      <description>Returns a reference to the value in the implementation passed in. No checking is done to ensure there is a value. Constexpr where possible.
Requires: Always available.
Complexity: Constant time.
Guarantees: Never throws an exception.</description>
    </item>
    
    <item>
      <title>`static auto &amp;&amp;_error(Impl &amp;&amp;) noexcept`</title>
      <link>https://ned14.github.io/outcome/reference/policies/base/error/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/policies/base/error/</guid>
      <description>Returns a reference to the error in the implementation passed in. No checking is done to ensure there is an error. Constexpr where possible.
Requires: Always available.
Complexity: Constant time.
Guarantees: Never throws an exception.</description>
    </item>
    
    <item>
      <title>`static auto &amp;&amp;_exception(Impl &amp;&amp;) noexcept`</title>
      <link>https://ned14.github.io/outcome/reference/policies/base/exception/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/policies/base/exception/</guid>
      <description>Returns a reference to the exception in the implementation passed in. No checking is done to ensure there is an error. Constexpr where possible.
Requires: Always available.
Complexity: Constant time.
Guarantees: Never throws an exception.</description>
    </item>
    
    <item>
      <title>`explicit basic_outcome(ValueOrError&lt;T, E&gt; &amp;&amp;)`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_outcome/explicit_valueorerror_converting_constructor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_outcome/explicit_valueorerror_converting_constructor/</guid>
      <description>Explicit converting constructor from ValueOrError&amp;lt;T, E&amp;gt; concept matching types. Delegates to the basic_result move constructor explicit basic_outcome(basic_result&amp;lt;A, B, C&amp;gt; &amp;amp;&amp;amp;).
Requires: convert::value_or_error&amp;lt;T, U&amp;gt; has an available call operator, and if the input is a basic_result or basic_outcome, then convert::value_or_error&amp;lt;&amp;gt; has enabled those inputs for that convert::value_or_error&amp;lt;&amp;gt; specialisation.
Complexity: Same as for the copy or move constructor from the input&amp;rsquo;s .value() or .error() respectively. Constexpr, triviality and noexcept of underlying operations is propagated.</description>
    </item>
    
    <item>
      <title>`explicit basic_result(ValueOrError&lt;T, E&gt; &amp;&amp;)`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_result/explicit_valueorerror_converting_constructor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_result/explicit_valueorerror_converting_constructor/</guid>
      <description>Explicit converting constructor from ValueOrError&amp;lt;T, E&amp;gt; concept matching types. Delegates to the basic_result move constructor.
Requires: convert::value_or_error&amp;lt;T, U&amp;gt; has an available call operator, and if the input is a basic_result or basic_outcome, then convert::value_or_error&amp;lt;&amp;gt; has enabled those inputs for that convert::value_or_error&amp;lt;&amp;gt; specialisation.
Complexity: Same as for the copy or move constructor from the input&amp;rsquo;s .value() or .error() respectively. Constexpr, triviality and noexcept of underlying operations is propagated.
Guarantees: If an exception is thrown during the operation, the object is left in a partially completed state, as per the normal rules for the same operation on a struct.</description>
    </item>
    
    <item>
      <title>`static void _set_has_value(Impl &amp;&amp;, bool) noexcept`</title>
      <link>https://ned14.github.io/outcome/reference/policies/base/set_has_value/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/policies/base/set_has_value/</guid>
      <description>Sets whether the implementation has a value by setting or clearing the relevant bit in the flags. Constexpr where possible.
Requires: Always available.
Complexity: Constant time.
Guarantees: Never throws an exception.</description>
    </item>
    
    <item>
      <title>`explicit basic_outcome(const basic_outcome&lt;A, B, C, D&gt; &amp;)`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_outcome/explicit_copy_converting_constructor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_outcome/explicit_copy_converting_constructor/</guid>
      <description>Explicit converting copy constructor from compatible basic_outcome. Calls void hook_outcome_copy_construction(T *, U &amp;amp;&amp;amp;) noexcept with this and the input.
Requires: predicate::enable_compatible_conversion&amp;lt;A, B, C, D&amp;gt; is true.
Complexity: Same as for the copy constructors of the underlying types. Constexpr, triviality and noexcept of underlying operations is propagated.
Guarantees: If an exception is thrown during the operation, the object is left in a partially completed state, as per the normal rules for the same operation on a struct.</description>
    </item>
    
    <item>
      <title>`explicit basic_result(const basic_result&lt;R, S, P&gt; &amp;)`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_result/explicit_copy_converting_constructor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_result/explicit_copy_converting_constructor/</guid>
      <description>Explicit converting copy constructor from compatible basic_result. Calls void hook_result_copy_construction(T *, U &amp;amp;&amp;amp;) noexcept with this and the input.
Requires: predicate::enable_compatible_conversion&amp;lt;R, S, P&amp;gt; is true.
Complexity: Same as for the copy constructors of the underlying types. Constexpr, triviality and noexcept of underlying operations is propagated.
Guarantees: If an exception is thrown during the operation, the object is left in a partially completed state, as per the normal rules for the same operation on a struct.</description>
    </item>
    
    <item>
      <title>`static void _set_has_error(Impl &amp;&amp;, bool) noexcept`</title>
      <link>https://ned14.github.io/outcome/reference/policies/base/set_has_error/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/policies/base/set_has_error/</guid>
      <description>Sets whether the implementation has an error by setting or clearing the relevant bit in the flags. Constexpr where possible.
Requires: Always available.
Complexity: Constant time.
Guarantees: Never throws an exception.</description>
    </item>
    
    <item>
      <title>`explicit basic_outcome(basic_outcome&lt;A, B, C, D&gt; &amp;&amp;)`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_outcome/explicit_move_converting_constructor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_outcome/explicit_move_converting_constructor/</guid>
      <description>Explicit converting move constructor from compatible basic_outcome. Calls void hook_outcome_move_construction(T *, U &amp;amp;&amp;amp;) noexcept with this and the input.
Requires: predicate::enable_compatible_conversion&amp;lt;A, B, C, D&amp;gt; is true.
Complexity: Same as for the move constructors of the underlying types. Constexpr, triviality and noexcept of underlying operations is propagated.
Guarantees: If an exception is thrown during the operation, the object is left in a partially completed state, as per the normal rules for the same operation on a struct.</description>
    </item>
    
    <item>
      <title>`explicit basic_result(basic_result&lt;R, S, P&gt; &amp;&amp;)`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_result/explicit_move_converting_constructor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_result/explicit_move_converting_constructor/</guid>
      <description>Explicit converting move constructor from compatible basic_result. Calls void hook_result_move_construction(T *, U &amp;amp;&amp;amp;) noexcept with this and the input.
Requires: predicate::enable_compatible_conversion&amp;lt;R, S, P&amp;gt; is true.
Complexity: Same as for the move constructors of the underlying types. Constexpr, triviality and noexcept of underlying operations is propagated.
Guarantees: If an exception is thrown during the operation, the object is left in a partially completed state, as per the normal rules for the same operation on a struct.</description>
    </item>
    
    <item>
      <title>`explicit basic_outcome(const basic_result&lt;A, B, C&gt; &amp;)`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_outcome/explicit_result_copy_converting_constructor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_outcome/explicit_result_copy_converting_constructor/</guid>
      <description>Explicit converting copy constructor from compatible basic_result. Calls void hook_outcome_copy_construction(T *, U &amp;amp;&amp;amp;) noexcept with this and the input.
Requires: predicate::enable_compatible_conversion&amp;lt;A, B, void, C&amp;gt; is true.
Complexity: Same as for the copy constructors of the underlying types. Constexpr, triviality and noexcept of underlying operations is propagated.
Guarantees: If an exception is thrown during the operation, the object is left in a partially completed state, as per the normal rules for the same operation on a struct.</description>
    </item>
    
    <item>
      <title>`static void _set_has_exception(Impl &amp;&amp;, bool) noexcept`</title>
      <link>https://ned14.github.io/outcome/reference/policies/base/set_has_exception/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/policies/base/set_has_exception/</guid>
      <description>Sets whether the implementation has an exception by setting or clearing the relevant bit in the flags. Constexpr where possible.
Requires: Always available.
Complexity: Constant time.
Guarantees: Never throws an exception.</description>
    </item>
    
    <item>
      <title>`explicit basic_outcome(basic_result&lt;A, B, C&gt; &amp;&amp;)`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_outcome/explicit_result_move_converting_constructor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_outcome/explicit_result_move_converting_constructor/</guid>
      <description>Explicit converting move constructor from compatible basic_result. Calls void hook_outcome_move_construction(T *, U &amp;amp;&amp;amp;) noexcept with this and the input.
Requires: predicate::enable_compatible_conversion&amp;lt;A, B, void, C&amp;gt; is true.
Complexity: Same as for the move constructors of the underlying types. Constexpr, triviality and noexcept of underlying operations is propagated.
Guarantees: If an exception is thrown during the operation, the object is left in a partially completed state, as per the normal rules for the same operation on a struct.</description>
    </item>
    
    <item>
      <title>`static void _set_has_exception(Impl &amp;&amp;, bool) noexcept`</title>
      <link>https://ned14.github.io/outcome/reference/policies/base/set_has_error_is_errno/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/policies/base/set_has_error_is_errno/</guid>
      <description>Sets whether the implementation&amp;rsquo;s error code has a domain or category matching that of POSIX errno by setting or clearing the relevant bit in the flags. Constexpr where possible.
Requires: Always available.
Complexity: Constant time.
Guarantees: Never throws an exception.</description>
    </item>
    
    <item>
      <title>`explicit basic_outcome(in_place_type_t&lt;value_type_if_enabled&gt;, Args ...)`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_outcome/explicit_inplace_value_constructor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_outcome/explicit_inplace_value_constructor/</guid>
      <description>Explicit inplace value constructor. Calls void hook_outcome_in_place_construction(T *, in_place_type_t&amp;lt;U&amp;gt;, Args &amp;amp;&amp;amp;...) noexcept with this, in_place_type&amp;lt;value_type&amp;gt; and Args ....
Requires: predicate::enable_inplace_value_constructor&amp;lt;Args ...&amp;gt; is true.
Complexity: Same as for the value_type constructor which accepts Args .... Constexpr, triviality and noexcept of underlying operations is propagated.
Guarantees: If an exception is thrown during the operation, the state of the Args is left indeterminate.</description>
    </item>
    
    <item>
      <title>`explicit basic_result(in_place_type_t&lt;value_type_if_enabled&gt;, Args ...)`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_result/explicit_inplace_value_constructor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_result/explicit_inplace_value_constructor/</guid>
      <description>Explicit inplace value constructor. Calls void hook_result_in_place_construction(T *, in_place_type_t&amp;lt;U&amp;gt;, Args &amp;amp;&amp;amp;...) noexcept with this, in_place_type&amp;lt;value_type&amp;gt; and Args ....
Requires: predicate::enable_inplace_value_constructor&amp;lt;Args ...&amp;gt; is true.
Complexity: Same as for the value_type constructor which accepts Args .... Constexpr, triviality and noexcept of underlying operations is propagated.
Guarantees: If an exception is thrown during the operation, the state of the Args is left indeterminate.</description>
    </item>
    
    <item>
      <title>`static void narrow_value_check(Impl &amp;&amp;) noexcept`</title>
      <link>https://ned14.github.io/outcome/reference/policies/base/narrow_value_check/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/policies/base/narrow_value_check/</guid>
      <description>Observer policy performing hard UB if no value is present, by calling static void _ub(Impl &amp;amp;&amp;amp;). Constexpr where possible.
Requires: Always available.
Complexity: Constant time.
Guarantees: Never throws an exception.</description>
    </item>
    
    <item>
      <title>`explicit basic_outcome(in_place_type_t&lt;value_type_if_enabled&gt;, std::initializer_list&lt;U&gt;, Args ...)`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_outcome/explicit_inplace_value_constructor_il/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_outcome/explicit_inplace_value_constructor_il/</guid>
      <description>Explicit inplace value constructor. Calls void hook_outcome_in_place_construction(T *, in_place_type_t&amp;lt;U&amp;gt;, Args &amp;amp;&amp;amp;...) noexcept with this, in_place_type&amp;lt;value_type&amp;gt;, &amp;lsquo;std::initializer_list&amp;rsquo; and Args ....
Requires: predicate::enable_inplace_value_constructor&amp;lt;std::initializer_list&amp;lt;U&amp;gt;, Args ...&amp;gt; is true.
Complexity: Same as for the value_type constructor which accepts std::initializer_list&amp;lt;U&amp;gt;, Args .... Constexpr, triviality and noexcept of underlying operations is propagated.
Guarantees: If an exception is thrown during the operation, the state of the Args is left indeterminate.</description>
    </item>
    
    <item>
      <title>`explicit basic_result(in_place_type_t&lt;value_type_if_enabled&gt;, std::initializer_list&lt;U&gt;, Args ...)`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_result/explicit_inplace_value_constructor_il/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_result/explicit_inplace_value_constructor_il/</guid>
      <description>Explicit inplace value constructor. Calls void hook_result_in_place_construction(T *, in_place_type_t&amp;lt;U&amp;gt;, Args &amp;amp;&amp;amp;...) noexcept with this, in_place_type&amp;lt;value_type&amp;gt;, &amp;lsquo;std::initializer_list&amp;rsquo; and Args ....
Requires: predicate::enable_inplace_value_constructor&amp;lt;std::initializer_list&amp;lt;U&amp;gt;, Args ...&amp;gt; is true.
Complexity: Same as for the value_type constructor which accepts std::initializer_list&amp;lt;U&amp;gt;, Args .... Constexpr, triviality and noexcept of underlying operations is propagated.
Guarantees: If an exception is thrown during the operation, the state of the Args is left indeterminate.</description>
    </item>
    
    <item>
      <title>`static void narrow_error_check(Impl &amp;&amp;) noexcept`</title>
      <link>https://ned14.github.io/outcome/reference/policies/base/narrow_error_check/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/policies/base/narrow_error_check/</guid>
      <description>Observer policy performing hard UB if no error is present, by calling static void _ub(Impl &amp;amp;&amp;amp;). Constexpr where possible.
Requires: Always available.
Complexity: Constant time.
Guarantees: Never throws an exception.</description>
    </item>
    
    <item>
      <title>`explicit basic_outcome(in_place_type_t&lt;error_type_if_enabled&gt;, Args ...)`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_outcome/explicit_inplace_error_constructor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_outcome/explicit_inplace_error_constructor/</guid>
      <description>Explicit inplace error constructor. Calls void hook_outcome_in_place_construction(T *, in_place_type_t&amp;lt;U&amp;gt;, Args &amp;amp;&amp;amp;...) noexcept with this, in_place_type&amp;lt;error_type&amp;gt; and Args ....
Requires: predicate::enable_inplace_error_constructor&amp;lt;Args ...&amp;gt; is true.
Complexity: Same as for the error_type constructor which accepts Args .... Constexpr, triviality and noexcept of underlying operations is propagated.
Guarantees: If an exception is thrown during the operation, the state of the Args is left indeterminate.</description>
    </item>
    
    <item>
      <title>`explicit basic_result(in_place_type_t&lt;error_type_if_enabled&gt;, Args ...)`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_result/explicit_inplace_error_constructor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_result/explicit_inplace_error_constructor/</guid>
      <description>Explicit inplace error constructor. Calls void hook_result_in_place_construction(T *, in_place_type_t&amp;lt;U&amp;gt;, Args &amp;amp;&amp;amp;...) noexcept with this, in_place_type&amp;lt;error_type&amp;gt; and Args ....
Requires: predicate::enable_inplace_error_constructor&amp;lt;Args ...&amp;gt; is true.
Complexity: Same as for the error_type constructor which accepts Args .... Constexpr, triviality and noexcept of underlying operations is propagated.
Guarantees: If an exception is thrown during the operation, the state of the Args is left indeterminate.</description>
    </item>
    
    <item>
      <title>`static void narrow_exception_check(Impl &amp;&amp;) noexcept`</title>
      <link>https://ned14.github.io/outcome/reference/policies/base/narrow_exception_check/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/policies/base/narrow_exception_check/</guid>
      <description>Observer policy performing hard UB if no exception is present, by calling static void _ub(Impl &amp;amp;&amp;amp;). Constexpr where possible.
Requires: Always available.
Complexity: Constant time.
Guarantees: Never throws an exception.</description>
    </item>
    
    <item>
      <title>`explicit basic_outcome(in_place_type_t&lt;error_type_if_enabled&gt;, std::initializer_list&lt;U&gt;, Args ...)`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_outcome/explicit_inplace_error_constructor_il/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_outcome/explicit_inplace_error_constructor_il/</guid>
      <description>Explicit inplace error constructor. Calls void hook_outcome_in_place_construction(T *, in_place_type_t&amp;lt;U&amp;gt;, Args &amp;amp;&amp;amp;...) noexcept with this, in_place_type&amp;lt;error_type&amp;gt;, std::initializer_list&amp;lt;U&amp;gt; and Args ....
Requires: predicate::enable_inplace_error_constructor&amp;lt;std::initializer_list&amp;lt;U&amp;gt;, Args ...&amp;gt; is true.
Complexity: Same as for the error_type constructor which accepts std::initializer_list&amp;lt;U&amp;gt;, Args .... Constexpr, triviality and noexcept of underlying operations is propagated.
Guarantees: If an exception is thrown during the operation, the state of the Args is left indeterminate.</description>
    </item>
    
    <item>
      <title>`explicit basic_result(in_place_type_t&lt;error_type_if_enabled&gt;, std::initializer_list&lt;U&gt;, Args ...)`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_result/explicit_inplace_error_constructor_il/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_result/explicit_inplace_error_constructor_il/</guid>
      <description>Explicit inplace error constructor. Calls void hook_result_in_place_construction(T *, in_place_type_t&amp;lt;U&amp;gt;, Args &amp;amp;&amp;amp;...) noexcept with this, in_place_type&amp;lt;error_type&amp;gt;, std::initializer_list&amp;lt;U&amp;gt; and Args ....
Requires: predicate::enable_inplace_error_constructor&amp;lt;std::initializer_list&amp;lt;U&amp;gt;, Args ...&amp;gt; is true.
Complexity: Same as for the error_type constructor which accepts std::initializer_list&amp;lt;U&amp;gt;, Args .... Constexpr, triviality and noexcept of underlying operations is propagated.
Guarantees: If an exception is thrown during the operation, the state of the Args is left indeterminate.</description>
    </item>
    
    <item>
      <title>`explicit basic_outcome(in_place_type_t&lt;exception_type_if_enabled&gt;, Args ...)`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_outcome/explicit_inplace_exception_constructor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_outcome/explicit_inplace_exception_constructor/</guid>
      <description>Explicit inplace exception constructor. Calls void hook_outcome_in_place_construction(T *, in_place_type_t&amp;lt;U&amp;gt;, Args &amp;amp;&amp;amp;...) noexcept with this, in_place_type&amp;lt;exception_type&amp;gt; and Args ....
Requires: predicate::enable_inplace_exception_constructor&amp;lt;Args ...&amp;gt; is true.
Complexity: Same as for the exception_type constructor which accepts Args .... Constexpr, triviality and noexcept of underlying operations is propagated.
Guarantees: If an exception is thrown during the operation, the state of the Args is left indeterminate.</description>
    </item>
    
    <item>
      <title>`explicit basic_outcome(in_place_type_t&lt;exception_type_if_enabled&gt;, std::initializer_list&lt;U&gt;, Args ...)`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_outcome/explicit_inplace_exception_constructor_il/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_outcome/explicit_inplace_exception_constructor_il/</guid>
      <description>Explicit inplace exception constructor. Calls void hook_outcome_in_place_construction(T *, in_place_type_t&amp;lt;U&amp;gt;, Args &amp;amp;&amp;amp;...) noexcept with this, in_place_type&amp;lt;exception_type&amp;gt;, std::initializer_list&amp;lt;U&amp;gt; and Args ....
Requires: predicate::enable_inplace_exception_constructor&amp;lt;std::initializer_list&amp;lt;U&amp;gt;, Args ...&amp;gt; is true.
Complexity: Same as for the exception_type constructor which accepts std::initializer_list&amp;lt;U&amp;gt;, Args .... Constexpr, triviality and noexcept of underlying operations is propagated.
Guarantees: If an exception is thrown during the operation, the state of the Args is left indeterminate.</description>
    </item>
    
    <item>
      <title>`basic_outcome(A1 &amp;&amp;, A2 &amp;&amp;, Args ...)`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_outcome/implicit_inplace_value_error_exception_constructor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_outcome/implicit_inplace_value_error_exception_constructor/</guid>
      <description>Implicit inplace value or error or exception constructor. Delegates to an appropriate explicit inplace constructor depending on input.
Requires: predicate::enable_inplace_value_error_exception_constructor` is true.
Complexity: Same as for the value_type or error_type or exception_type constructor which accepts A1, A2, Args .... Constexpr, triviality and noexcept of underlying operations is propagated.
Guarantees: If an exception is thrown during the operation, the state of the Args is left indeterminate.</description>
    </item>
    
    <item>
      <title>`basic_result(A1 &amp;&amp;, A2 &amp;&amp;, Args ...)`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_result/implicit_inplace_value_error_constructor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_result/implicit_inplace_value_error_constructor/</guid>
      <description>Implicit inplace value or error constructor. Delegates to an appropriate explicit inplace constructor depending on input.
Requires: predicate::enable_inplace_value_error_constructor` is true.
Complexity: Same as for the value_type or error_type constructor which accepts A1, A2, Args .... Constexpr, triviality and noexcept of underlying operations is propagated.
Guarantees: If an exception is thrown during the operation, the state of the Args is left indeterminate.</description>
    </item>
    
    <item>
      <title>`basic_outcome(const success_type&lt;T&gt; &amp;)`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_outcome/implicit_success_copy_constructor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_outcome/implicit_success_copy_constructor/</guid>
      <description>Implicit value-from-success-type-sugar copy constructor used to disambiguate the construction of the value type. Note that if T = void, value_type will be default constructed. Calls void hook_outcome_copy_construction(T *, U &amp;amp;&amp;amp;) noexcept with this and const success_type&amp;lt;T&amp;gt; &amp;amp;.
Requires: predicate::enable_compatible_conversion&amp;lt;T, void, void&amp;gt; is true, or T is void.
Complexity: Same as for the value_type constructor which accepts T, or the value_type default constructor if T is void. Constexpr, triviality and noexcept of underlying operations is propagated.</description>
    </item>
    
    <item>
      <title>`basic_result(const success_type&lt;T&gt; &amp;)`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_result/implicit_success_copy_constructor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_result/implicit_success_copy_constructor/</guid>
      <description>Implicit value-from-success-type-sugar copy constructor used to disambiguate the construction of the value type. Note that if T = void, value_type will be default constructed. Calls void hook_result_copy_construction(T *, U &amp;amp;&amp;amp;) noexcept with this and const success_type&amp;lt;T&amp;gt; &amp;amp;.
Requires: predicate::enable_compatible_conversion&amp;lt;T, void, void&amp;gt; is true, or T is void.
Complexity: Same as for the value_type constructor which accepts T, or the value_type default constructor if T is void. Constexpr, triviality and noexcept of underlying operations is propagated.</description>
    </item>
    
    <item>
      <title>`basic_outcome(success_type&lt;T&gt; &amp;&amp;)`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_outcome/implicit_success_move_constructor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_outcome/implicit_success_move_constructor/</guid>
      <description>Implicit value-from-success-type-sugar move constructor used to disambiguate the construction of the value type. Note that if T = void, value_type will be default constructed. Calls void hook_outcome_move_construction(T *, U &amp;amp;&amp;amp;) noexcept with this and success_type&amp;lt;T&amp;gt; &amp;amp;&amp;amp;.
Requires: predicate::enable_compatible_conversion&amp;lt;T, void, void&amp;gt; is true, or T is void.
Complexity: Same as for the value_type constructor which accepts T, or the value_type default constructor if T is void. Constexpr, triviality and noexcept of underlying operations is propagated.</description>
    </item>
    
    <item>
      <title>`basic_result(success_type&lt;T&gt; &amp;&amp;)`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_result/implicit_success_move_constructor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_result/implicit_success_move_constructor/</guid>
      <description>Implicit value-from-success-type-sugar move constructor used to disambiguate the construction of the value type. Note that if T = void, value_type will be default constructed. Calls void hook_result_move_construction(T *, U &amp;amp;&amp;amp;) noexcept with this and success_type&amp;lt;T&amp;gt; &amp;amp;&amp;amp;.
Requires: predicate::enable_compatible_conversion&amp;lt;T, void, void&amp;gt; is true, or T is void.
Complexity: Same as for the value_type constructor which accepts T, or the value_type default constructor if T is void. Constexpr, triviality and noexcept of underlying operations is propagated.</description>
    </item>
    
    <item>
      <title>`basic_outcome(const failure_type&lt;EC&gt; &amp;)`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_outcome/implicit_failure_error_copy_constructor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_outcome/implicit_failure_error_copy_constructor/</guid>
      <description>Implicit error-from-failure-type-sugar copy constructor used to disambiguate the construction of the error type. Calls void hook_outcome_copy_construction(T *, U &amp;amp;&amp;amp;) noexcept with this and const failure_type&amp;lt;EC&amp;gt; &amp;amp;.
Requires: predicate::enable_compatible_conversion&amp;lt;void, EC, void, void&amp;gt; is true.
Complexity: Same as for the error_type constructor which accepts EC. Constexpr, triviality and noexcept of underlying operations is propagated.</description>
    </item>
    
    <item>
      <title>`basic_result(const failure_type&lt;T&gt; &amp;)`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_result/implicit_failure_copy_constructor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_result/implicit_failure_copy_constructor/</guid>
      <description>Implicit error-from-failure-type-sugar copy constructor used to disambiguate the construction of the error type. Note that if T = void, error_type will be default constructed. Calls void hook_result_copy_construction(T *, U &amp;amp;&amp;amp;) noexcept with this and const failure_type&amp;lt;T&amp;gt; &amp;amp;.
Requires: predicate::enable_compatible_conversion&amp;lt;void, T, void&amp;gt; is true, or T is void.
Complexity: Same as for the error_type constructor which accepts T, or the error_type default constructor if T is void. Constexpr, triviality and noexcept of underlying operations is propagated.</description>
    </item>
    
    <item>
      <title>`basic_outcome(failure_type&lt;EC&gt; &amp;&amp;)`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_outcome/implicit_failure_error_move_constructor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_outcome/implicit_failure_error_move_constructor/</guid>
      <description>Implicit error-from-failure-type-sugar move constructor used to disambiguate the construction of the error type. Calls void hook_outcome_move_construction(T *, U &amp;amp;&amp;amp;) noexcept with this and failure_type&amp;lt;EC&amp;gt; &amp;amp;&amp;amp;.
Requires: predicate::enable_compatible_conversion&amp;lt;void, EC, void, void&amp;gt; is true.
Complexity: Same as for the error_type constructor which accepts EC. Constexpr, triviality and noexcept of underlying operations is propagated.</description>
    </item>
    
    <item>
      <title>`basic_result(failure_type&lt;T&gt; &amp;&amp;)`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_result/implicit_failure_move_constructor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_result/implicit_failure_move_constructor/</guid>
      <description>Implicit error-from-failure-type-sugar move constructor used to disambiguate the construction of the error type. Note that if T = void, error_type will be default constructed. Calls void hook_result_move_construction(T *, U &amp;amp;&amp;amp;) noexcept with this and failure_type&amp;lt;T&amp;gt; &amp;amp;&amp;amp;.
Requires: predicate::enable_compatible_conversion&amp;lt;void, T, void&amp;gt; is true, or T is void.
Complexity: Same as for the error_type constructor which accepts T, or the error_type default constructor if T is void. Constexpr, triviality and noexcept of underlying operations is propagated.</description>
    </item>
    
    <item>
      <title>`basic_outcome(const failure_type&lt;EP&gt; &amp;)`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_outcome/implicit_failure_exception_copy_constructor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_outcome/implicit_failure_exception_copy_constructor/</guid>
      <description>Implicit exception-from-failure-type-sugar copy constructor used to disambiguate the construction of the exception type. Calls void hook_outcome_copy_construction(T *, U &amp;amp;&amp;amp;) noexcept with this and const failure_type&amp;lt;EP&amp;gt; &amp;amp;.
Requires: predicate::enable_compatible_conversion&amp;lt;void, void, EP, void&amp;gt; is true.
Complexity: Same as for the exception_type constructor which accepts EP. Constexpr, triviality and noexcept of underlying operations is propagated.</description>
    </item>
    
    <item>
      <title>`basic_outcome(failure_type&lt;EP&gt; &amp;&amp;)`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_outcome/implicit_failure_exception_move_constructor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_outcome/implicit_failure_exception_move_constructor/</guid>
      <description>Implicit exception-from-failure-type-sugar move constructor used to disambiguate the construction of the exception type. Calls void hook_outcome_move_construction(T *, U &amp;amp;&amp;amp;) noexcept with this and failure_type&amp;lt;EP&amp;gt; &amp;amp;&amp;amp;.
Requires: predicate::enable_compatible_conversion&amp;lt;void, void, EP, void&amp;gt; is true.
Complexity: Same as for the exception_type constructor which accepts EP. Constexpr, triviality and noexcept of underlying operations is propagated.</description>
    </item>
    
    <item>
      <title>`basic_outcome(const failure_type&lt;EC, EP&gt; &amp;)`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_outcome/implicit_failure_error_exception_copy_constructor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_outcome/implicit_failure_error_exception_copy_constructor/</guid>
      <description>Implicit error-and-exception-from-failure-type-sugar copy constructor used to disambiguate the construction of the error + exception types. Calls void hook_outcome_copy_construction(T *, U &amp;amp;&amp;amp;, V &amp;amp;&amp;amp;) noexcept with this, const failure_type&amp;lt;EC&amp;gt; &amp;amp; and const failure_type&amp;lt;EP&amp;gt; &amp;amp;.
Requires: predicate::enable_compatible_conversion&amp;lt;void, EC, EP, void&amp;gt; is true.
Complexity: Same as for the error_type and exception_type constructors which accept EC and EP. Constexpr, triviality and noexcept of underlying operations is propagated.</description>
    </item>
    
    <item>
      <title>`basic_outcome(failure_type&lt;EC, EP&gt; &amp;&amp;)`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_outcome/implicit_failure_error_exception_move_constructor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_outcome/implicit_failure_error_exception_move_constructor/</guid>
      <description>Implicit error-and-exception-from-failure-type-sugar move constructor used to disambiguate the construction of the error + exception types. Calls void hook_outcome_move_construction(T *, U &amp;amp;&amp;amp;, V &amp;amp;&amp;amp;) noexcept with this, failure_type&amp;lt;EC&amp;gt; &amp;amp;&amp;amp; and failure_type&amp;lt;EP&amp;gt; &amp;amp;&amp;amp;.
Requires: predicate::enable_compatible_conversion&amp;lt;void, EC, EP, void&amp;gt; is true.
Complexity: Same as for the error_type and exception_type constructors which accept EC and EP. Constexpr, triviality and noexcept of underlying operations is propagated.</description>
    </item>
    
    <item>
      <title>`explicit operator bool() const noexcept`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_outcome/operator_bool/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_outcome/operator_bool/</guid>
      <description>Returns true if a value is present. Constexpr where possible. Alias for bool has_value() const noexcept.
Requires: Always available.
Complexity: Constant time.
Guarantees: Never throws an exception.</description>
    </item>
    
    <item>
      <title>`explicit operator bool() const noexcept`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_result/operator_bool/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_result/operator_bool/</guid>
      <description>Returns true if a value is present. Constexpr where possible. Alias for bool has_value() const noexcept.
Requires: Always available.
Complexity: Constant time.
Guarantees: Never throws an exception.</description>
    </item>
    
    <item>
      <title>`bool has_value() const noexcept`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_outcome/has_value/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_outcome/has_value/</guid>
      <description>Returns true if a value is present. Constexpr where possible. Alias for explicit operator bool() const noexcept.
Requires: Always available.
Complexity: Constant time.
Guarantees: Never throws an exception.</description>
    </item>
    
    <item>
      <title>`bool has_value() const noexcept`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_result/has_value/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_result/has_value/</guid>
      <description>Returns true if a value is present. Constexpr where possible. Alias for explicit operator bool() const noexcept.
Requires: Always available.
Complexity: Constant time.
Guarantees: Never throws an exception.</description>
    </item>
    
    <item>
      <title>`bool has_error() const noexcept`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_outcome/has_error/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_outcome/has_error/</guid>
      <description>Returns true if an error is present. Constexpr where possible.
Requires: Always available.
Complexity: Constant time.
Guarantees: Never throws an exception.</description>
    </item>
    
    <item>
      <title>`bool has_error() const noexcept`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_result/has_error/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_result/has_error/</guid>
      <description>Returns true if an error is present. Constexpr where possible.
Requires: Always available.
Complexity: Constant time.
Guarantees: Never throws an exception.</description>
    </item>
    
    <item>
      <title>`bool has_exception() const noexcept`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_outcome/has_exception/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_outcome/has_exception/</guid>
      <description>Returns true if an exception is present. Constexpr where possible.
Requires: Always available.
Complexity: Constant time.
Guarantees: Never throws an exception.</description>
    </item>
    
    <item>
      <title>`bool has_exception() const noexcept`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_result/has_exception/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_result/has_exception/</guid>
      <description>Always returns false for basic_result. Constexpr where possible.
Requires: Always available.
Complexity: Constant time.
Guarantees: Never throws an exception.</description>
    </item>
    
    <item>
      <title>`bool has_failure() const noexcept`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_outcome/has_failure/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_outcome/has_failure/</guid>
      <description>Returns true if there is either an error or an exception. Constexpr where possible.
Requires: Always available.
Complexity: Constant time.
Guarantees: Never throws an exception.</description>
    </item>
    
    <item>
      <title>`bool has_failure() const noexcept`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_result/has_failure/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_result/has_failure/</guid>
      <description>Returns true if there is either an error or an exception. Constexpr where possible.
Requires: Always available.
Complexity: Constant time.
Guarantees: Never throws an exception.</description>
    </item>
    
    <item>
      <title>`value_type &amp;assume_value() &amp; noexcept`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_outcome/assume_value_lvalue/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_outcome/assume_value_lvalue/</guid>
      <description>Narrow contract lvalue reference observer of any value present. NoValuePolicy::narrow_value_check() is first invoked, then the reference to the value is returned. The convention is that hard undefined behaviour occurs if no value is actually present, however NoValuePolicy::narrow_value_check() can do something to avoid that.
Note that if value_type is void, only a const overload returning void is present.
Requires: Always available.
Complexity: Depends on NoValuePolicy::narrow_value_check().
Guarantees: An exception is never thrown.</description>
    </item>
    
    <item>
      <title>`value_type &amp;assume_value() &amp; noexcept`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_result/assume_value_lvalue/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_result/assume_value_lvalue/</guid>
      <description>Narrow contract lvalue reference observer of any value present. NoValuePolicy::narrow_value_check() is first invoked, then the reference to the value is returned. The convention is that hard undefined behaviour occurs if no value is actually present, however NoValuePolicy::narrow_value_check() can do something to avoid that.
Note that if value_type is void, only a const overload returning void is present.
Requires: Always available.
Complexity: Depends on NoValuePolicy::narrow_value_check().
Guarantees: An exception is never thrown.</description>
    </item>
    
    <item>
      <title>`const value_type &amp;assume_value() const &amp; noexcept`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_outcome/assume_value_lvalue_const/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_outcome/assume_value_lvalue_const/</guid>
      <description>Narrow contract const lvalue reference observer of any value present. NoValuePolicy::narrow_value_check() is first invoked, then the reference to the value is returned. The convention is that hard undefined behaviour occurs if no value is actually present, however NoValuePolicy::narrow_value_check() can do something to avoid that.
Note that if value_type is void, only a const overload returning void is present.
Requires: Always available.
Complexity: Depends on NoValuePolicy::narrow_value_check().
Guarantees: An exception is never thrown.</description>
    </item>
    
    <item>
      <title>`const value_type &amp;assume_value() const &amp; noexcept`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_result/assume_value_lvalue_const/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_result/assume_value_lvalue_const/</guid>
      <description>Narrow contract const lvalue reference observer of any value present. NoValuePolicy::narrow_value_check() is first invoked, then the reference to the value is returned. The convention is that hard undefined behaviour occurs if no value is actually present, however NoValuePolicy::narrow_value_check() can do something to avoid that.
Note that if value_type is void, only a const overload returning void is present.
Requires: Always available.
Complexity: Depends on NoValuePolicy::narrow_value_check().
Guarantees: An exception is never thrown.</description>
    </item>
    
    <item>
      <title>`value_type &amp;&amp;assume_value() &amp;&amp; noexcept`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_outcome/assume_value_rvalue/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_outcome/assume_value_rvalue/</guid>
      <description>Narrow contract rvalue reference observer of any value present. NoValuePolicy::narrow_value_check() is first invoked, then the reference to the value is returned. The convention is that hard undefined behaviour occurs if no value is actually present, however NoValuePolicy::narrow_value_check() can do something to avoid that.
Note that if value_type is void, only a const overload returning void is present.
Requires: Always available.
Complexity: Depends on NoValuePolicy::narrow_value_check().
Guarantees: An exception is never thrown.</description>
    </item>
    
    <item>
      <title>`value_type &amp;&amp;assume_value() &amp;&amp; noexcept`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_result/assume_value_rvalue/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_result/assume_value_rvalue/</guid>
      <description>Narrow contract rvalue reference observer of any value present. NoValuePolicy::narrow_value_check() is first invoked, then the reference to the value is returned. The convention is that hard undefined behaviour occurs if no value is actually present, however NoValuePolicy::narrow_value_check() can do something to avoid that.
Note that if value_type is void, only a const overload returning void is present.
Requires: Always available.
Complexity: Depends on NoValuePolicy::narrow_value_check().
Guarantees: An exception is never thrown.</description>
    </item>
    
    <item>
      <title>`const value_type &amp;&amp;assume_value() const &amp;&amp; noexcept`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_outcome/assume_value_rvalue_const/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_outcome/assume_value_rvalue_const/</guid>
      <description>Narrow contract const rvalue reference observer of any value present. NoValuePolicy::narrow_value_check() is first invoked, then the reference to the value is returned. The convention is that hard undefined behaviour occurs if no value is actually present, however NoValuePolicy::narrow_value_check() can do something to avoid that.
Note that if value_type is void, only a const overload returning void is present.
Requires: Always available.
Complexity: Depends on NoValuePolicy::narrow_value_check().
Guarantees: An exception is never thrown.</description>
    </item>
    
    <item>
      <title>`const value_type &amp;&amp;assume_value() const &amp;&amp; noexcept`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_result/assume_value_rvalue_const/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_result/assume_value_rvalue_const/</guid>
      <description>Narrow contract const rvalue reference observer of any value present. NoValuePolicy::narrow_value_check() is first invoked, then the reference to the value is returned. The convention is that hard undefined behaviour occurs if no value is actually present, however NoValuePolicy::narrow_value_check() can do something to avoid that.
Note that if value_type is void, only a const overload returning void is present.
Requires: Always available.
Complexity: Depends on NoValuePolicy::narrow_value_check().
Guarantees: An exception is never thrown.</description>
    </item>
    
    <item>
      <title>`value_type &amp;value() &amp;`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_outcome/value_lvalue/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_outcome/value_lvalue/</guid>
      <description>Wide contract lvalue reference observer of any value present. NoValuePolicy::wide_value_check() is first invoked, then the reference to the value is returned.
Note that if value_type is void, only a const overload returning void is present.
Requires: Always available.
Complexity: Depends on NoValuePolicy::wide_value_check().
Guarantees: None.</description>
    </item>
    
    <item>
      <title>`value_type &amp;value() &amp;`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_result/value_lvalue/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_result/value_lvalue/</guid>
      <description>Wide contract lvalue reference observer of any value present. NoValuePolicy::wide_value_check() is first invoked, then the reference to the value is returned.
Note that if value_type is void, only a const overload returning void is present.
Requires: Always available.
Complexity: Depends on NoValuePolicy::wide_value_check().
Guarantees: None.</description>
    </item>
    
    <item>
      <title>`const value_type &amp;value() const &amp;`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_outcome/value_lvalue_const/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_outcome/value_lvalue_const/</guid>
      <description>Wide contract const lvalue reference observer of any value present. NoValuePolicy::wide_value_check() is first invoked, then the reference to the value is returned.
Note that if value_type is void, only a const overload returning void is present.
Requires: Always available.
Complexity: Depends on NoValuePolicy::wide_value_check().
Guarantees: None.</description>
    </item>
    
    <item>
      <title>`const value_type &amp;value() const &amp;`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_result/value_lvalue_const/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_result/value_lvalue_const/</guid>
      <description>Wide contract const lvalue reference observer of any value present. NoValuePolicy::wide_value_check() is first invoked, then the reference to the value is returned.
Note that if value_type is void, only a const overload returning void is present.
Requires: Always available.
Complexity: Depends on NoValuePolicy::wide_value_check().
Guarantees: None.</description>
    </item>
    
    <item>
      <title>`value_type &amp;&amp;value() &amp;&amp;`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_outcome/value_rvalue/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_outcome/value_rvalue/</guid>
      <description>Wide contract rvalue reference observer of any value present. NoValuePolicy::wide_value_check() is first invoked, then the reference to the value is returned.
Note that if value_type is void, only a const overload returning void is present.
Requires: Always available.
Complexity: Depends on NoValuePolicy::wide_value_check().
Guarantees: None.</description>
    </item>
    
    <item>
      <title>`value_type &amp;&amp;value() &amp;&amp;`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_result/value_rvalue/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_result/value_rvalue/</guid>
      <description>Wide contract rvalue reference observer of any value present. NoValuePolicy::wide_value_check() is first invoked, then the reference to the value is returned.
Note that if value_type is void, only a const overload returning void is present.
Requires: Always available.
Complexity: Depends on NoValuePolicy::wide_value_check().
Guarantees: None.</description>
    </item>
    
    <item>
      <title>`const value_type &amp;&amp;value() const &amp;&amp;`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_outcome/value_rvalue_const/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_outcome/value_rvalue_const/</guid>
      <description>Wide contract const rvalue reference observer of any value present. NoValuePolicy::wide_value_check() is first invoked, then the reference to the value is returned.
Note that if value_type is void, only a const overload returning void is present.
Requires: Always available.
Complexity: Depends on NoValuePolicy::wide_value_check().
Guarantees: None.</description>
    </item>
    
    <item>
      <title>`const value_type &amp;&amp;value() const &amp;&amp;`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_result/value_rvalue_const/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_result/value_rvalue_const/</guid>
      <description>Wide contract const rvalue reference observer of any value present. NoValuePolicy::wide_value_check() is first invoked, then the reference to the value is returned.
Note that if value_type is void, only a const overload returning void is present.
Requires: Always available.
Complexity: Depends on NoValuePolicy::wide_value_check().
Guarantees: None.</description>
    </item>
    
    <item>
      <title>`error_type &amp;assume_error() &amp; noexcept`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_outcome/assume_error_lvalue/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_outcome/assume_error_lvalue/</guid>
      <description>Narrow contract lvalue reference observer of the stored error. NoValuePolicy::narrow_error_check() is first invoked, then the reference to the error is returned. As a valid default constructed error is always present, no undefined behaviour occurs unless NoValuePolicy::narrow_error_check() does that.
Note that if error_type is void, only a const overload returning void is present.
Requires: Always available.
Complexity: Depends on NoValuePolicy::narrow_error_check().
Guarantees: An exception is never thrown.</description>
    </item>
    
    <item>
      <title>`error_type &amp;assume_error() &amp; noexcept`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_result/assume_error_lvalue/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_result/assume_error_lvalue/</guid>
      <description>Narrow contract lvalue reference observer of the stored error. NoValuePolicy::narrow_error_check() is first invoked, then the reference to the error is returned. As a valid default constructed error is always present, no undefined behaviour occurs unless NoValuePolicy::narrow_error_check() does that.
Note that if error_type is void, only a const overload returning void is present.
Requires: Always available.
Complexity: Depends on NoValuePolicy::narrow_error_check().
Guarantees: An exception is never thrown.</description>
    </item>
    
    <item>
      <title>`const error_type &amp;assume_error() const &amp; noexcept`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_outcome/assume_error_lvalue_const/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_outcome/assume_error_lvalue_const/</guid>
      <description>Narrow contract const lvalue reference observer of the stored error. NoValuePolicy::narrow_error_check() is first invoked, then the reference to the error is returned. As a valid default constructed error is always present, no undefined behaviour occurs unless NoValuePolicy::narrow_error_check() does that.
Note that if error_type is void, only a const overload returning void is present.
Requires: Always available.
Complexity: Depends on NoValuePolicy::narrow_error_check().
Guarantees: An exception is never thrown.</description>
    </item>
    
    <item>
      <title>`const error_type &amp;assume_error() const &amp; noexcept`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_result/assume_error_lvalue_const/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_result/assume_error_lvalue_const/</guid>
      <description>Narrow contract const lvalue reference observer of the stored error. NoValuePolicy::narrow_error_check() is first invoked, then the reference to the error is returned. As a valid default constructed error is always present, no undefined behaviour occurs unless NoValuePolicy::narrow_error_check() does that.
Note that if error_type is void, only a const overload returning void is present.
Requires: Always available.
Complexity: Depends on NoValuePolicy::narrow_error_check().
Guarantees: An exception is never thrown.</description>
    </item>
    
    <item>
      <title>`error_type &amp;&amp;assume_error() &amp;&amp; noexcept`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_outcome/assume_error_rvalue/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_outcome/assume_error_rvalue/</guid>
      <description>Narrow contract rvalue reference observer of the stored error. NoValuePolicy::narrow_error_check() is first invoked, then the reference to the error is returned. As a valid default constructed error is always present, no undefined behaviour occurs unless NoValuePolicy::narrow_error_check() does that.
Note that if error_type is void, only a const overload returning void is present.
Requires: Always available.
Complexity: Depends on NoValuePolicy::narrow_error_check().
Guarantees: An exception is never thrown.</description>
    </item>
    
    <item>
      <title>`error_type &amp;&amp;assume_error() &amp;&amp; noexcept`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_result/assume_error_rvalue/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_result/assume_error_rvalue/</guid>
      <description>Narrow contract rvalue reference observer of the stored error. NoValuePolicy::narrow_error_check() is first invoked, then the reference to the error is returned. As a valid default constructed error is always present, no undefined behaviour occurs unless NoValuePolicy::narrow_error_check() does that.
Note that if error_type is void, only a const overload returning void is present.
Requires: Always available.
Complexity: Depends on NoValuePolicy::narrow_error_check().
Guarantees: An exception is never thrown.</description>
    </item>
    
    <item>
      <title>`const error_type &amp;&amp;assume_error() const &amp;&amp; noexcept`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_outcome/assume_error_rvalue_const/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_outcome/assume_error_rvalue_const/</guid>
      <description>Narrow contract const rvalue reference observer of the stored error. NoValuePolicy::narrow_error_check() is first invoked, then the reference to the error is returned. As a valid default constructed error is always present, no undefined behaviour occurs unless NoValuePolicy::narrow_error_check() does that.
Note that if error_type is void, only a const overload returning void is present.
Requires: Always available.
Complexity: Depends on NoValuePolicy::narrow_error_check().
Guarantees: An exception is never thrown.</description>
    </item>
    
    <item>
      <title>`const error_type &amp;&amp;assume_error() const &amp;&amp; noexcept`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_result/assume_error_rvalue_const/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_result/assume_error_rvalue_const/</guid>
      <description>Narrow contract const rvalue reference observer of the stored error. NoValuePolicy::narrow_error_check() is first invoked, then the reference to the error is returned. As a valid default constructed error is always present, no undefined behaviour occurs unless NoValuePolicy::narrow_error_check() does that.
Note that if error_type is void, only a const overload returning void is present.
Requires: Always available.
Complexity: Depends on NoValuePolicy::narrow_error_check().
Guarantees: An exception is never thrown.</description>
    </item>
    
    <item>
      <title>`error_type &amp;error() &amp;`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_outcome/error_lvalue/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_outcome/error_lvalue/</guid>
      <description>Wide contract lvalue reference observer of the stored error. NoValuePolicy::wide_error_check() is first invoked, then the reference to the error is returned. As a valid default constructed error is always present, no undefined behaviour occurs if NoValuePolicy::wide_error_check() returns.
Note that if error_type is void, only a const overload returning void is present.
Requires: Always available.
Complexity: Depends on NoValuePolicy::wide_error_check().
Guarantees: None.</description>
    </item>
    
    <item>
      <title>`error_type &amp;error() &amp;`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_result/error_lvalue/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_result/error_lvalue/</guid>
      <description>Wide contract lvalue reference observer of the stored error. NoValuePolicy::wide_error_check() is first invoked, then the reference to the error is returned. As a valid default constructed error is always present, no undefined behaviour occurs if NoValuePolicy::wide_error_check() returns.
Note that if error_type is void, only a const overload returning void is present.
Requires: Always available.
Complexity: Depends on NoValuePolicy::wide_error_check().
Guarantees: None.</description>
    </item>
    
    <item>
      <title>`const error_type &amp;error() const &amp;`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_outcome/error_lvalue_const/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_outcome/error_lvalue_const/</guid>
      <description>Wide contract const lvalue reference observer of the stored error. NoValuePolicy::wide_error_check() is first invoked, then the reference to the error is returned. As a valid default constructed error is always present, no undefined behaviour occurs if NoValuePolicy::wide_error_check() returns.
Note that if error_type is void, only a const overload returning void is present.
Requires: Always available.
Complexity: Depends on NoValuePolicy::wide_error_check().
Guarantees: None.</description>
    </item>
    
    <item>
      <title>`const error_type &amp;error() const &amp;`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_result/error_lvalue_const/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_result/error_lvalue_const/</guid>
      <description>Wide contract const lvalue reference observer of the stored error. NoValuePolicy::wide_error_check() is first invoked, then the reference to the error is returned. As a valid default constructed error is always present, no undefined behaviour occurs if NoValuePolicy::wide_error_check() returns.
Note that if error_type is void, only a const overload returning void is present.
Requires: Always available.
Complexity: Depends on NoValuePolicy::wide_error_check().
Guarantees: None.</description>
    </item>
    
    <item>
      <title>`error_type &amp;&amp;error() &amp;&amp;`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_outcome/error_rvalue/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_outcome/error_rvalue/</guid>
      <description>Wide contract rvalue reference observer of the stored error. NoValuePolicy::wide_error_check() is first invoked, then the reference to the error is returned. As a valid default constructed error is always present, no undefined behaviour occurs if NoValuePolicy::wide_error_check() returns.
Note that if error_type is void, only a const overload returning void is present.
Requires: Always available.
Complexity: Depends on NoValuePolicy::wide_error_check().
Guarantees: None.</description>
    </item>
    
    <item>
      <title>`error_type &amp;&amp;error() &amp;&amp;`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_result/error_rvalue/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_result/error_rvalue/</guid>
      <description>Wide contract rvalue reference observer of the stored error. NoValuePolicy::wide_error_check() is first invoked, then the reference to the error is returned. As a valid default constructed error is always present, no undefined behaviour occurs if NoValuePolicy::wide_error_check() returns.
Note that if error_type is void, only a const overload returning void is present.
Requires: Always available.
Complexity: Depends on NoValuePolicy::wide_error_check().
Guarantees: None.</description>
    </item>
    
    <item>
      <title>`const error_type &amp;&amp;error() const &amp;&amp;`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_outcome/error_rvalue_const/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_outcome/error_rvalue_const/</guid>
      <description>Wide contract const rvalue reference observer of the stored error. NoValuePolicy::wide_error_check() is first invoked, then the reference to the error is returned. As a valid default constructed error is always present, no undefined behaviour occurs if NoValuePolicy::wide_error_check() returns.
Note that if error_type is void, only a const overload returning void is present.
Requires: Always available.
Complexity: Depends on NoValuePolicy::wide_error_check().
Guarantees: None.</description>
    </item>
    
    <item>
      <title>`const error_type &amp;&amp;error() const &amp;&amp;`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_result/error_rvalue_const/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_result/error_rvalue_const/</guid>
      <description>Wide contract const rvalue reference observer of the stored error. NoValuePolicy::wide_error_check() is first invoked, then the reference to the error is returned. As a valid default constructed error is always present, no undefined behaviour occurs if NoValuePolicy::wide_error_check() returns.
Note that if error_type is void, only a const overload returning void is present.
Requires: Always available.
Complexity: Depends on NoValuePolicy::wide_error_check().
Guarantees: None.</description>
    </item>
    
    <item>
      <title>`exception_type &amp;assume_exception() &amp; noexcept`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_outcome/assume_exception_lvalue/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_outcome/assume_exception_lvalue/</guid>
      <description>Narrow contract lvalue reference observer of the stored exception. NoValuePolicy::narrow_exception_check() is first invoked, then the reference to the exception is returned. As a valid default constructed exception is always present, no undefined behaviour occurs unless NoValuePolicy::narrow_exception_check() does that.
Note that if exception_type is void, only a const overload returning void is present.
Requires: Always available.
Complexity: Depends on NoValuePolicy::narrow_exception_check().
Guarantees: An exception is never thrown.</description>
    </item>
    
    <item>
      <title>`const exception_type &amp;assume_exception() const &amp; noexcept`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_outcome/assume_exception_lvalue_const/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_outcome/assume_exception_lvalue_const/</guid>
      <description>Narrow contract const lvalue reference observer of the stored exception. NoValuePolicy::narrow_exception_check() is first invoked, then the reference to the exception is returned. As a valid default constructed exception is always present, no undefined behaviour occurs unless NoValuePolicy::narrow_exception_check() does that.
Note that if exception_type is void, only a const overload returning void is present.
Requires: Always available.
Complexity: Depends on NoValuePolicy::narrow_exception_check().
Guarantees: An exception is never thrown.</description>
    </item>
    
    <item>
      <title>`const exception_type &amp;&amp;assume_exception() const &amp;&amp; noexcept`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_outcome/assume_exception_rvalue_const/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_outcome/assume_exception_rvalue_const/</guid>
      <description>Narrow contract const rvalue reference observer of the stored exception. NoValuePolicy::narrow_exception_check() is first invoked, then the reference to the exception is returned. As a valid default constructed exception is always present, no undefined behaviour occurs unless NoValuePolicy::narrow_exception_check() does that.
Note that if exception_type is void, only a const overload returning void is present.
Requires: Always available.
Complexity: Depends on NoValuePolicy::narrow_exception_check().
Guarantees: An exception is never thrown.</description>
    </item>
    
    <item>
      <title>`exception_type &amp;&amp;assume_exception() &amp;&amp; noexcept`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_outcome/assume_exception_rvalue/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_outcome/assume_exception_rvalue/</guid>
      <description>Narrow contract rvalue reference observer of the stored exception. NoValuePolicy::narrow_exception_check() is first invoked, then the reference to the exception is returned. As a valid default constructed exception is always present, no undefined behaviour occurs unless NoValuePolicy::narrow_exception_check() does that.
Note that if exception_type is void, only a const overload returning void is present.
Requires: Always available.
Complexity: Depends on NoValuePolicy::narrow_exception_check().
Guarantees: An exception is never thrown.</description>
    </item>
    
    <item>
      <title>`exception_type &amp;exception() &amp;`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_outcome/exception_lvalue/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_outcome/exception_lvalue/</guid>
      <description>Wide contract lvalue reference observer of the stored exception. NoValuePolicy::wide_exception_check() is first invoked, then the reference to the exception is returned. As a valid default constructed exception is always present, no undefined behaviour occurs if NoValuePolicy::wide_exception_check() returns.
Note that if exception_type is void, only a const overload returning void is present.
Requires: Always available.
Complexity: Depends on NoValuePolicy::wide_exception_check().
Guarantees: None.</description>
    </item>
    
    <item>
      <title>`const exception_type &amp;exception() const &amp;`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_outcome/exception_lvalue_const/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_outcome/exception_lvalue_const/</guid>
      <description>Wide contract const lvalue reference observer of the stored exception. NoValuePolicy::wide_exception_check() is first invoked, then the reference to the exception is returned. As a valid default constructed exception is always present, no undefined behaviour occurs if NoValuePolicy::wide_exception_check() returns.
Note that if exception_type is void, only a const overload returning void is present.
Requires: Always available.
Complexity: Depends on NoValuePolicy::wide_exception_check().
Guarantees: None.</description>
    </item>
    
    <item>
      <title>`exception_type &amp;&amp;exception() &amp;&amp;`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_outcome/exception_rvalue/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_outcome/exception_rvalue/</guid>
      <description>Wide contract rvalue reference observer of the stored exception. NoValuePolicy::wide_exception_check() is first invoked, then the reference to the exception is returned. As a valid default constructed exception is always present, no undefined behaviour occurs if NoValuePolicy::wide_exception_check() returns.
Note that if exception_type is void, only a const overload returning void is present.
Requires: Always available.
Complexity: Depends on NoValuePolicy::wide_exception_check().
Guarantees: None.</description>
    </item>
    
    <item>
      <title>`const exception_type &amp;&amp;exception() const &amp;&amp;`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_outcome/exception_rvalue_const/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_outcome/exception_rvalue_const/</guid>
      <description>Wide contract const rvalue reference observer of the stored exception. NoValuePolicy::wide_exception_check() is first invoked, then the reference to the exception is returned. As a valid default constructed exception is always present, no undefined behaviour occurs if NoValuePolicy::wide_exception_check() returns.
Note that if exception_type is void, only a const overload returning void is present.
Requires: Always available.
Complexity: Depends on NoValuePolicy::wide_exception_check().
Guarantees: None.</description>
    </item>
    
    <item>
      <title>`exception_type failure() const noexcept`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_outcome/failure/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_outcome/failure/</guid>
      <description>Synthesising observer of the stored exception or error. If an exception is available, returns a copy of that directly. If an error is available, and not an exception, an ADL discovered free function auto basic_outcome_failure_exception_from_error(const EC &amp;amp;) is invoked. Default overloads for this function are defined in Outcome for  std::error_code and boost::system::error_code, these return std::make_exception_ptr(std::system_error(ec)) and boost::copy_exception(boost::system::system_error(ec)) respectively.
Requires: Both the traits is_error_code_available&amp;lt;T&amp;gt; and is_exception_ptr_available&amp;lt;T&amp;gt; are true.
Complexity: Depends on basic_outcome_failure_exception_from_error(const EC &amp;amp;).</description>
    </item>
    
    <item>
      <title>`bool operator==(const basic_result&lt;A, B, C&gt; &amp;) const`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_outcome/equality_basic_result/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_outcome/equality_basic_result/</guid>
      <description>Returns true if this outcome compares equal to the other result. Comparison is done using operator== on value_type or error_type if the currently chosen state is the same for both outcome and result, otherwise false is returned. Note that if the outcome is excepted, it will never compare equal to a result.
Requires: operator== must be a valid expression between value_type and A, and between error_type and B. If value_type is void, then so must be A; similarly for error_type and B.</description>
    </item>
    
    <item>
      <title>`bool operator==(const basic_result&lt;A, B, C&gt; &amp;) const`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_result/equality_basic_result/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_result/equality_basic_result/</guid>
      <description>Returns true if this result compares equal to the other result. Comparison is done using operator== on either value_type or error_type if the currently chosen state is the same for both results, otherwise false is returned.
Requires: operator== must be a valid expression between value_type and A, and between error_type and B. If value_type is void, then so must be A; similarly for error_type and B.
Complexity: Whatever the underlying operator== have.</description>
    </item>
    
    <item>
      <title>`bool operator==(const basic_outcome&lt;A, B, C, D&gt; &amp;) const`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_outcome/equality_basic_outcome/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_outcome/equality_basic_outcome/</guid>
      <description>Returns true if this outcome compares equal to the other outcome. Comparison is done using operator== on value_type or error_type and/or exception_type if the currently chosen state is the same for both outcomes, otherwise false is returned.
Requires: operator== must be a valid expression between value_type and A, and between error_type and B, and between exception_type and C. If value_type is void, then so must be A; similarly for error_type and B; similarly for exception_type and C.</description>
    </item>
    
    <item>
      <title>`bool operator==(const success_type&lt;A&gt; &amp;) const`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_outcome/inequality_success_type/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_outcome/inequality_success_type/</guid>
      <description>Returns true if this result is successful and its value compares equal to the value in the success type sugar. Comparison is done using operator== on value_type and A. If A is void, this call aliases bool has_value() const noexcept.
Requires: operator== must be a valid expression between value_type and A, or A is void. If value_type is void, then so must be A.
Complexity: Whatever the underlying operator== has. Constexpr and noexcept of underlying operations is propagated.</description>
    </item>
    
    <item>
      <title>`bool operator==(const success_type&lt;A&gt; &amp;) const`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_result/inequality_success_type/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_result/inequality_success_type/</guid>
      <description>Returns true if this result is successful and its value compares equal to the value in the success type sugar. Comparison is done using operator== on value_type and A. If A is void, this call aliases bool has_value() const noexcept.
Requires: operator== must be a valid expression between value_type and A, or A is void. If value_type is void, then so must be A.
Complexity: Whatever the underlying operator== has. Constexpr and noexcept of underlying operations is propagated.</description>
    </item>
    
    <item>
      <title>`bool operator==(const failure_type&lt;A, B&gt; &amp;) const`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_outcome/equality_failure_type/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_outcome/equality_failure_type/</guid>
      <description>Returns true if this outcome is unsuccessful and its error compares equal to the error in the failure type sugar. Comparison is done using operator== on error_type and A and on exception_type and B.
Requires: operator== must be a valid expression between error_type and A, or A is void; operator== must be a valid expression between exception_type and B, or B is void. If error_type is void, then so must be A; if exception_type is void, then so must be B.</description>
    </item>
    
    <item>
      <title>`bool operator==(const failure_type&lt;A, void&gt; &amp;) const`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_result/equality_failure_type/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_result/equality_failure_type/</guid>
      <description>Returns true if this result is unsuccessful and its error compares equal to the error in the failure type sugar. Comparison is done using operator== on error_type and A. If A is void, this call aliases bool has_error() const noexcept.
Requires: operator== must be a valid expression between error_type and A, or A is void. If error_type is void, then so must be A.
Complexity: Whatever the underlying operator== has. Constexpr and noexcept of underlying operations is propagated.</description>
    </item>
    
    <item>
      <title>`bool operator!=(const basic_result&lt;A, B, C&gt; &amp;) const`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_result/inequality_basic_result/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_result/inequality_basic_result/</guid>
      <description>Returns true if this result does not compare equal to the other result. Comparison is done using operator!= on either value_type or error_type if the currently chosen state is the same for both results, otherwise true is returned.
Requires: operator!= must be a valid expression between value_type and A, and between error_type and B. If value_type is void, then so must be A; similarly for error_type and B.
Complexity: Whatever the underlying operator!</description>
    </item>
    
    <item>
      <title>`bool operator!=(const basic_result&lt;A, B, C&gt; &amp;) const`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_outcome/inequality_basic_result/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_outcome/inequality_basic_result/</guid>
      <description>Returns true if this outcome does not compare equal to the other result. Comparison is done using operator!= on value_type or error_type if the currently chosen state is the same for both outcome and result, otherwise true is returned. Note that an excepted outcome is always unequal to a result.
Requires: operator!= must be a valid expression between value_type and A, and between error_type and B. If value_type is void, then so must be A; similarly for error_type and B.</description>
    </item>
    
    <item>
      <title>`bool operator!=(const basic_outcome&lt;A, B, C, D&gt; &amp;) const`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_outcome/inequality_basic_outcome/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_outcome/inequality_basic_outcome/</guid>
      <description>Returns true if this outcome does not compare equal to the other outcome. Comparison is done using operator!= on value_type, error_type and/or exception_type if the currently chosen state is the same for both outcomes, otherwise true is returned.
Requires: operator!= must be a valid expression between value_type and A, and between error_type and B, and between exception_type and C. If value_type is void, then so must be A; similarly for error_type and B; similarly for exception_type and C.</description>
    </item>
    
    <item>
      <title>`bool operator!=(const success_type&lt;A&gt; &amp;) const`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_outcome/equality_success_type/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_outcome/equality_success_type/</guid>
      <description>Returns true if this outcome is not successful or its value does not compares equal to the value in the success type sugar. Comparison is done using operator!= on value_type and A. If A is void, this call aliases bool has_error() const noexcept.
Requires: operator!= must be a valid expression between value_type and A, or A is void. If value_type is void, then so must be A.
Complexity: Whatever the underlying operator!</description>
    </item>
    
    <item>
      <title>`bool operator!=(const success_type&lt;A&gt; &amp;) const`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_result/equality_success_type/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_result/equality_success_type/</guid>
      <description>Returns true if this result is not successful or its value does not compares equal to the value in the success type sugar. Comparison is done using operator!= on value_type and A. If A is void, this call aliases bool has_error() const noexcept.
Requires: operator!= must be a valid expression between value_type and A, or A is void. If value_type is void, then so must be A.
Complexity: Whatever the underlying operator!</description>
    </item>
    
    <item>
      <title>`bool operator!=(const failure_type&lt;A, B&gt; &amp;) const`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_outcome/inequality_failure_type/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_outcome/inequality_failure_type/</guid>
      <description>Returns true if this outcome is successful or its error or exception does not compare equal to the error in the failure type sugar. Comparison is done using operator!= on error_type and A and on exception_type and B.
Requires: operator!= must be a valid expression between error_type and A, or A is void; operator!= must be a valid expression between exception_type and B, or B is void. If error_type is void, then so must be A; if exception_type is void, then so must be B.</description>
    </item>
    
    <item>
      <title>`bool operator!=(const failure_type&lt;A, void&gt; &amp;) const`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_result/inequality_failure_type/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_result/inequality_failure_type/</guid>
      <description>Returns true if this result is successful or its error does not compare equal to the error in the failure type sugar. Comparison is done using operator!= on error_type and A. If A is void, this call aliases bool has_value() const noexcept.
Requires: operator!= must be a valid expression between error_type and A, or A is void. If error_type is void, then so must be A.
Complexity: Whatever the underlying operator!</description>
    </item>
    
    <item>
      <title>`void swap(basic_outcome &amp;)`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_outcome/swap/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_outcome/swap/</guid>
      <description>Swap one basic_outcome with another.
Requires: Always available.
Complexity: Same as for the swap() implementations of the value_type, error_type and exception_type. The noexcept of underlying operations is propagated.
Guarantees: If an exception is thrown during the operation, the state of all three operands on entry is guaranteed restored, if at least two of the underlying operations is marked noexcept. If one or zero is marked noexcept, an attempt is made to undo the partially completed operation.</description>
    </item>
    
    <item>
      <title>`void swap(basic_result &amp;)`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_result/swap/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_result/swap/</guid>
      <description>Swap one basic_result with another.
Requires: Always available.
Complexity: Same as for the swap() implementations of the value_type and error_type. The noexcept of underlying operations is propagated.
Guarantees: If an exception is thrown during the operation, the state of both operands on entry is guaranteed restored, if at least one of the underlying operations is marked noexcept. If neither is marked noexcept, an attempt is made to undo the partially completed operation.</description>
    </item>
    
    <item>
      <title>`auto as_failure() const &amp;`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_result/as_failure_lvalue/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_result/as_failure_lvalue/</guid>
      <description>Return the output from free function auto failure(T &amp;amp;&amp;amp;, ...) containing a copy of any errored state. The error state is accessed using const error_type &amp;amp;assume_error() const &amp;amp; noexcept.
Requires: Always available.
Complexity: Whatever that of error_type&amp;rsquo;s copy constructor is.
Guarantees: None.</description>
    </item>
    
    <item>
      <title>`failure_type&lt;error_type, exception_type&gt; as_failure() const &amp;`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_outcome/as_failure_lvalue/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_outcome/as_failure_lvalue/</guid>
      <description>Return the output from free function auto failure(T &amp;amp;&amp;amp;, ...) containing a copy of any errored and/or excepted state. The error and/or exception state is accessed using const error_type &amp;amp;assume_error() const &amp;amp; noexcept and const exception_type &amp;amp;assume_exception() const &amp;amp; noexcept.
Requires: Always available.
Complexity: Whatever that of error_type&amp;rsquo;s and/or exception_type&amp;rsquo;s copy constructor is.
Guarantees: None.</description>
    </item>
    
    <item>
      <title>`auto as_failure() &amp;&amp;`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_result/as_failure_rvalue/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_result/as_failure_rvalue/</guid>
      <description>Return the output from free function auto failure(T &amp;amp;&amp;amp;, ...) containing a move from any errored state, thus leaving the result&amp;rsquo;s error value in a moved-from state. Depending on the choice of error_type, this function may therefore be destructive. The error state is accessed using error_type &amp;amp;&amp;amp;assume_error() &amp;amp;&amp;amp; noexcept.
Requires: Always available.
Complexity: Whatever that of error_type&amp;rsquo;s move constructor is.
Guarantees: None.</description>
    </item>
    
    <item>
      <title>`failure_type&lt;error_type, exception_type&gt; as_failure() &amp;&amp;`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_outcome/as_failure_rvalue/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_outcome/as_failure_rvalue/</guid>
      <description>Return the output from free function auto failure(T &amp;amp;&amp;amp;, ...) containing a move from any errored and/or excepted state, thus leaving the outcome&amp;rsquo;s error and exception values in a moved-from state. Depending on the choice of error_type and/or exception_type, this function may therefore be destructive. The error and exception states are accessed using error_type &amp;amp;&amp;amp;assume_error() &amp;amp;&amp;amp; noexcept and exception_type &amp;amp;&amp;amp;assume_exception() &amp;amp;&amp;amp; noexcept.
Requires: Always available.
Complexity: Whatever that of error_type&amp;rsquo;s and/or exception_type&amp;rsquo;s move constructor is.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://ned14.github.io/outcome/_footer/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/_footer/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://ned14.github.io/outcome/_header/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/_header/</guid>
      <description>Outcome 2.1 library documentation</description>
    </item>
    
    <item>
      <title>ASIO/Networking TS</title>
      <link>https://ned14.github.io/outcome/recipes/asio-integration/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/recipes/asio-integration/</guid>
      <description>Thanks to Christos Stratopoulos for this Outcome recipe.
Use case Boost.ASIO and standalone ASIO provide the async_result customisation point for adapting arbitrary third party libraries, such as Outcome, into ASIO.
Historically in ASIO you need to pass completion handler instances to the ASIO asynchronous i/o initiation functions. These get executed when the i/o completes.
// Dynamically allocate a buffer to read into. This must be move-only  // so it can be attached to the completion handler, hence the unique_ptr.</description>
    </item>
    
    <item>
      <title>Acknowledgements</title>
      <link>https://ned14.github.io/outcome/credits/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/credits/</guid>
      <description>github contributors .ghContributors{ display:flex; flex-flow: wrap; align-content: flex-start } .ghContributors  div{ width: 50% ; display: inline-flex; margin-bottom: 5px; } .ghContributors  div label{ padding-left: 4px ; } .ghContributors  div span{ font-size: x-small; padding-left: 4px ; }   @ned14 1040 commits   @akrzemi1 44 commits   @hazelnusse 7 commits   @libboze 2 commits   @johnthagen 2 commits   @menuet 2 commits   @norbertwenzel 1 commits   @vinipsmaker 1 commits   @andoks 1 commits   @catskul 1 commits   @jenkins-nedprod 1 commits   This pretty, modern C++ documentation  Hugo - static website generator of this documentation.</description>
    </item>
    
    <item>
      <title>Constrained template macros</title>
      <link>https://ned14.github.io/outcome/reference/macros/template/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/macros/template/</guid>
      <description>Overridable: All of the following macros are overridable, define before inclusion.
Header: &amp;lt;outcome/config.hpp&amp;gt;
These macros expand into either the syntax for directly specifying constrained templates in C++ 20, or into a SFINAE based emulation for earlier C++ versions. Form of usage looks as follows:
OUTCOME_TEMPLATE(classErrorCondEnum) OUTCOME_TREQUIRES( // If this is a valid expression  OUTCOME_TEXPR(error_type(make_error_code(ErrorCondEnum()))), // If this predicate is true  OUTCOME_TPRED(predicate::template enable_error_condition_converting_constructor&amp;lt;ErrorCondEnum&amp;gt;) // Any additional requirements follow here .</description>
    </item>
    
    <item>
      <title>Version macros</title>
      <link>https://ned14.github.io/outcome/reference/macros/version/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/macros/version/</guid>
      <description>Overridable: None of the following macros are overridable.
Header: &amp;lt;outcome/config.hpp&amp;gt;
 OUTCOME_VERSION_MAJOR &amp;lt;number&amp;gt;
Major version for cmake and DLL version stamping.
 OUTCOME_VERSION_MINOR &amp;lt;number&amp;gt;
Minor version for cmake and DLL version stamping.
 OUTCOME_VERSION_PATCH &amp;lt;number&amp;gt;
Patch version for cmake and DLL version stamping.
 OUTCOME_VERSION_REVISION &amp;lt;number&amp;gt;
Revision version for cmake and DLL version stamping.
 OUTCOME_UNSTABLE_VERSION &amp;lt;number&amp;gt;
Defined between stable releases of Outcome. It means the inline namespace will be permuted per-commit to ensure ABI uniqueness such that multiple versions of Outcome in a single process space cannot collide.</description>
    </item>
    
    <item>
      <title>`OUTCOME_DISABLE_EXECINFO`</title>
      <link>https://ned14.github.io/outcome/reference/macros/disable_execinfo/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/macros/disable_execinfo/</guid>
      <description>If defined, disables the use of the &amp;lt;execinfo.h&amp;gt; header (or the win32 emulation).
Some embedded Linux toolchains do not define &amp;lt;execinfo.h&amp;gt;, thus disabling C++ exceptions on those toolchains produces a failure to find this file. Avoid that problem by defining this macro to disable stack backtrace support entirely.
Overridable: Define before inclusion.
Default: Defined if __ANDROID__ is defined, else undefined.
Header: &amp;lt;outcome/config.hpp&amp;gt;</description>
    </item>
    
    <item>
      <title>`OUTCOME_NODISCARD`</title>
      <link>https://ned14.github.io/outcome/reference/macros/nodiscard/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/macros/nodiscard/</guid>
      <description>Compiler-specific markup used to tell the compiler than the return value of a function should not be discarded without examining it.
Overridable: Define before inclusion.
Default: To [[nodiscard]] if on C++ 17 or higher, __attribute__((warn_unused_result)) if on clang, SAL _Must_inspect_result_ if on MSVC, otherwise nothing.
Header: &amp;lt;outcome/config.hpp&amp;gt;</description>
    </item>
    
    <item>
      <title>`OUTCOME_REQUIRES(...)`</title>
      <link>https://ned14.github.io/outcome/reference/macros/requires/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/macros/requires/</guid>
      <description>A C++ 20 requires(...), if available.
Overridable: Define before inclusion.
Default: To requires(...) if on C++ 20 or later, else to nothing.
Header: &amp;lt;outcome/config.hpp&amp;gt;</description>
    </item>
    
    <item>
      <title>`OUTCOME_SYMBOL_VISIBLE`</title>
      <link>https://ned14.github.io/outcome/reference/macros/symbol_visible/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/macros/symbol_visible/</guid>
      <description>Compiler-specific markup used to mark throwable types as always having default ELF symbol visibility, without which it will be impossible to catch throws of such types across shared library boundaries on ELF only.
Overridable: Define before inclusion.
Default: Standalone Outcome: To __attribute__((visibility(&amp;quot;default&amp;quot;)) on GCC and clang when targeting ELF, otherwise nothing. Boost.Outcome: To BOOST_SYMBOL_VISIBLE. 
Header: &amp;lt;outcome/config.hpp&amp;gt;</description>
    </item>
    
    <item>
      <title>`OUTCOME_THREAD_LOCAL`</title>
      <link>https://ned14.github.io/outcome/reference/macros/thread_local/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/macros/thread_local/</guid>
      <description>Compiler-specific markup used to mark variables as having thread local storage duration.
This isn&amp;rsquo;t used inside Outcome, but is used by its unit test suite.
 Overridable: Define before inclusion.
Default: To thread_local if the compiler implements C++ 11 thread_local, else __thread for the one supported compiler (older Mac OS XCode) which does not.
Header: &amp;lt;outcome/config.hpp&amp;gt;</description>
    </item>
    
    <item>
      <title>`OUTCOME_THROW_EXCEPTION(expr)`</title>
      <link>https://ned14.github.io/outcome/reference/macros/throw_exception/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/macros/throw_exception/</guid>
      <description>Throws a C++ exception, or equivalent thereof.
Overridable: Define before inclusion.
Default: Standalone Outcome (C++ exceptions enabled): To throw expr Standalone Outcome (C++ exceptions disabled): To OUTCOME_V2_NAMESPACE::detail::do_fatal_exit(#expr) which is a function which prints a useful error message including a stack backtrace (where available) to stderr before calling abort(). Boost.Outcome: To BOOST_THROW_EXCEPTION(expr). 
Header: &amp;lt;outcome/config.hpp&amp;gt;</description>
    </item>
    
    <item>
      <title>`OUTCOME_TRY(var, expr)`</title>
      <link>https://ned14.github.io/outcome/reference/macros/try/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/macros/try/</guid>
      <description>Evaluate an expression which results in a type matching the ValueOrError&amp;lt;T, E&amp;gt; concept, assigning T to a variable called var if successful, immediately returning try_operation_return_as(expr) from the calling function if unsuccessful.
Overridable: Not overridable.
Definition: See OUTCOME_TRYV(expr) for most of the mechanics.
If successful, an auto &amp;amp;&amp;amp;var is initialised to the expression result&amp;rsquo;s .assume_value() if available, else to its .value(). This binds a reference possibly to the T stored inside the bound result of the expression, but possibly also to a temporary emitted from the value observer function.</description>
    </item>
    
    <item>
      <title>`OUTCOME_TRYV(expr)/OUTCOME_TRY(expr)`</title>
      <link>https://ned14.github.io/outcome/reference/macros/tryv/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/macros/tryv/</guid>
      <description>Evaluate an expression which results in a type matching the ValueOrError&amp;lt;T, E&amp;gt; concept, continuing execution if successful, immediately returning try_operation_return_as(expr) from the calling function if unsuccessful.
The difference between the OUTCOME_TRYV(expr) and OUTCOME_TRY(expr) editions is that the latter will set a variable if two or more macro arguments are present (see OUTCOME_TRY(var, expr)). The former requires the T to be void.
Overridable: Not overridable.
Definition: Firstly the expression&amp;rsquo;s temporary is bound to a uniquely named, stack allocated, auto &amp;amp;&amp;amp;.</description>
    </item>
    
    <item>
      <title>`OUTCOME_TRYX(expr)`</title>
      <link>https://ned14.github.io/outcome/reference/macros/tryx/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/macros/tryx/</guid>
      <description>Evaluate an expression which results in a type matching the ValueOrError&amp;lt;T, E&amp;gt; concept, emitting the T if successful, immediately returning try_operation_return_as(expr) from the calling function if unsuccessful.
Availability: GCC and clang only. Use #ifdef OUTCOME_TRYX to determine if available.
Overridable: Not overridable.
Definition: See OUTCOME_TRYV(expr) for most of the mechanics.
This macro makes use of a proprietary extension in GCC and clang to emit the T from a successful expression. You can thus use OUTCOME_TRYX(expr) directly in expressions e.</description>
    </item>
    
    <item>
      <title>`OUTCOME_USE_STD_IN_PLACE_TYPE`</title>
      <link>https://ned14.github.io/outcome/reference/macros/in_place_type/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/macros/in_place_type/</guid>
      <description>How to implement in_place_type_t&amp;lt;T&amp;gt; and in_place_type&amp;lt;T&amp;gt;.
If set to 1, the &amp;lt;utility&amp;gt; header is included, and std::in_place_type_t&amp;lt;T&amp;gt; is aliased into OUTCOME_V2_NAMESPACE::in_place_type_t&amp;lt;T&amp;gt; along with std::in_place_type&amp;lt;T&amp;gt;.
If set to 0, a local emulation is used.
Overridable: Define before inclusion.
Default: If the current compiler implements C++ 17 or later, if unset this macro is defaulted to 1, otherwise it is defaulted to 0.
Header: &amp;lt;outcome/config.hpp&amp;gt;</description>
    </item>
    
    <item>
      <title>`OUTCOME_USE_STD_IS_NOTHROW_SWAPPABLE`</title>
      <link>https://ned14.github.io/outcome/reference/macros/is_nothrow_swappable/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/macros/is_nothrow_swappable/</guid>
      <description>Whether to implement is_nothrow_swappable&amp;lt;T&amp;gt; as std::is_nothrow_swappable&amp;lt;T&amp;gt;, or else use a local emulation.
Overridable: Define before inclusion.
Default: If the current compiler implements C++ 17 or later, if unset this macro is defaulted to 1, otherwise it is defaulted to 0.
Header: &amp;lt;outcome/config.hpp&amp;gt;</description>
    </item>
    
    <item>
      <title>`ValueOrError&lt;T, E&gt;`</title>
      <link>https://ned14.github.io/outcome/reference/concepts/valueorerror/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/concepts/valueorerror/</guid>
      <description>If on C++ 20 or the Concepts TS is enabled, a boolean concept matching types with a public .has_value() observer which returns bool, a public .value() observer function, and a public .error() observer function.
If without Concepts, a static constexpr bool which is true for types matching the same requirements, using a SFINAE based emulation.
This concept matches expected-like types such as  P0323 std::expected&amp;lt;T, E&amp;gt;, one of which is basic_result&amp;lt;T, E, NoValuePolicy&amp;gt;.</description>
    </item>
    
    <item>
      <title>`ValueOrNone&lt;T&gt;`</title>
      <link>https://ned14.github.io/outcome/reference/concepts/valueornone/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/concepts/valueornone/</guid>
      <description>If on C++ 20 or the Concepts TS is enabled, a boolean concept matching types with a public .has_value() observer which returns bool, and a public .value() observer function.
If without Concepts, a static constexpr bool which is true for types matching the same requirements, using a SFINAE based emulation.
This concept matches optional-like types such as  std::optional&amp;lt;T&amp;gt;. Note it also matches  P0323 std::expected&amp;lt;T, E&amp;gt;, which also has an optional-like interface.</description>
    </item>
    
    <item>
      <title>`all_narrow`</title>
      <link>https://ned14.github.io/outcome/reference/policies/all_narrow/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/policies/all_narrow/</guid>
      <description>Policy class defining that hard undefined behaviour should occur on incorrect narrow and wide value, error or exception observation.
Inherits publicly from base, and simply defines its wide value, error and exception observer policies to call their corresponding narrow editions.
Included by &amp;lt;basic_result.hpp&amp;gt;, and so is always available when basic_result is available.
Requires: Nothing.
Namespace: OUTCOME_V2_NAMESPACE::policy
Header: &amp;lt;outcome/policy/all_narrow.hpp&amp;gt;</description>
    </item>
    
    <item>
      <title>`auto basic_outcome_failure_exception_from_error(const EC &amp;)`</title>
      <link>https://ned14.github.io/outcome/reference/functions/policy/basic_outcome_failure_exception_from_error/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/functions/policy/basic_outcome_failure_exception_from_error/</guid>
      <description>Synthesises an exception type from an error type, used by the exception_type failure() const noexcept observers. ADL discovered. Default overloads for this function are defined in Outcome for  std::error_code and boost::system::error_code, these return std::make_exception_ptr(std::system_error(ec)) and boost::copy_exception(boost::system::system_error(ec)) respectively.
Overridable: Argument dependent lookup.
Requires: Nothing.
Namespace: Namespace of EC type.
Header: &amp;lt;outcome/std_outcome.hpp&amp;gt;, &amp;lt;outcome/boost_outcome.hpp&amp;gt;</description>
    </item>
    
    <item>
      <title>`auto failure(T &amp;&amp;, ...)`</title>
      <link>https://ned14.github.io/outcome/reference/functions/failure/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/functions/failure/</guid>
      <description>Returns appropriate type sugar for constructing an unsuccessful result or outcome, usually failure_type&amp;lt;EC, EP = void&amp;gt; with a decayed T.
Two default overloads are provided, one taking a single parameter returning failure_type&amp;lt;std::decay_t&amp;lt;T&amp;gt;&amp;gt;, the other taking two parameters returning failure_type&amp;lt;std::decay_t&amp;lt;T&amp;gt;, std::decay_t&amp;lt;U&amp;gt;&amp;gt;. Both overloads perfectly forward their inputs.
Note that failure() overloads are permitted by Outcome to return something other than failure_type. For example, basic_result&amp;rsquo;s auto as_failure() const &amp;amp; returns whatever type failure() returns, and OUTCOME_TRY(var, expr) by default returns for failure whatever .</description>
    </item>
    
    <item>
      <title>`auto success(T &amp;&amp;)`</title>
      <link>https://ned14.github.io/outcome/reference/functions/success/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/functions/success/</guid>
      <description>Returns appropriate type sugar for constructing a successful result or outcome, usually success_type&amp;lt;T&amp;gt; with a decayed T.
Two default overloads are provided, one taking a single parameter returning success_type&amp;lt;std::decay_t&amp;lt;T&amp;gt;&amp;gt; and perfectly forwarding the input. The other overload takes no parameters, and returns success_type&amp;lt;void&amp;gt;, which usually causes the construction of the receiving basic_result or basic_outcome&amp;rsquo;s with a default construction of their value type.
Overridable: By Argument Dependent Lookup (ADL).
Requires: Always available.</description>
    </item>
    
    <item>
      <title>`auto try_operation_return_as(T &amp;&amp;)`</title>
      <link>https://ned14.github.io/outcome/reference/functions/try_operation_return_as_t/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/functions/try_operation_return_as_t/</guid>
      <description>This implementation of try_operation_return_as(expr) returns whatever the input type&amp;rsquo;s .as_failure() member function returns. basic_result and basic_outcome provide such a member function, see auto as_failure() const &amp;amp;.
Requires: That the expression std::declval&amp;lt;T&amp;gt;().as_failure() is a valid expression.
Namespace: OUTCOME_V2_NAMESPACE
Header: &amp;lt;outcome/try.hpp&amp;gt;</description>
    </item>
    
    <item>
      <title>`bad_outcome_access`</title>
      <link>https://ned14.github.io/outcome/reference/types/bad_outcome_access/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/bad_outcome_access/</guid>
      <description>Exception type publicly inheriting from  std::logic_error indicating an incorrect observation of value or error or exception occurred by basic_outcome&amp;lt;T, EC, EP, NoValuePolicy&amp;gt;.
No member functions are added in addition to std::logic_error. Typical .what() strings are:
 &amp;quot;no value&amp;quot; &amp;quot;no error&amp;quot; &amp;quot;no exception&amp;quot;  Requires: Nothing.
Namespace: OUTCOME_V2_NAMESPACE
Header: &amp;lt;outcome/bad_access.hpp&amp;gt;</description>
    </item>
    
    <item>
      <title>`bad_result_access_with&lt;EC&gt;`</title>
      <link>https://ned14.github.io/outcome/reference/types/bad_result_access_with/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/bad_result_access_with/</guid>
      <description>Exception type publicly inheriting from bad_result_access, and thus also  std::logic_error, indicating an incorrect observation of value occurred. The error value at the time of the exception throw is moved or copied into this type, and is available using the .error() observer which comes in lvalue ref, const lvalue ref, rvalue ref, and const rvalue ref overloads.
The primary purpose of this exception type is to enable standing in for  P0323 std::expected&amp;lt;T, E&amp;gt;&amp;rsquo;s bad_expected_access&amp;lt;E&amp;gt; which is thrown on incorrect wide value observation.</description>
    </item>
    
    <item>
      <title>`bad_result_access`</title>
      <link>https://ned14.github.io/outcome/reference/types/bad_result_access/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/bad_result_access/</guid>
      <description>Exception type publicly inheriting from  std::logic_error indicating an incorrect observation of value or error occurred by basic_result&amp;lt;T, E, NoValuePolicy&amp;gt;.
No member functions are added in addition to std::logic_error. Typical .what() strings are:
 &amp;quot;no value&amp;quot; &amp;quot;no error&amp;quot;  Requires: Nothing.
Namespace: OUTCOME_V2_NAMESPACE
Header: &amp;lt;outcome/bad_access.hpp&amp;gt;</description>
    </item>
    
    <item>
      <title>`boost_checked&lt;T, E = boost::system::error_code&gt;`</title>
      <link>https://ned14.github.io/outcome/reference/aliases/boost_checked/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/aliases/boost_checked/</guid>
      <description>A type alias to a basic_result&amp;lt;T, E, NoValuePolicy&amp;gt; configured with boost::system::error_code and policy::throw_bad_result_access&amp;lt;EC&amp;gt;.
This type alias always references the boost edition of things, unlike checked&amp;lt;T, E = varies&amp;gt; which references either this alias or std_checked&amp;lt;T, E = std::error_code&amp;gt;.
Namespace: OUTCOME_V2_NAMESPACE
Header: &amp;lt;outcome/boost_result.hpp&amp;gt;</description>
    </item>
    
    <item>
      <title>`boost_outcome&lt;T, EC = boost::system::error_code, EP = boost::exception_ptr, NoValuePolicy = policy::default_policy&lt;T, EC, EP&gt;&gt;`</title>
      <link>https://ned14.github.io/outcome/reference/aliases/boost_outcome/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/aliases/boost_outcome/</guid>
      <description>A type alias to a basic_outcome&amp;lt;T, EC, EP, NoValuePolicy&amp;gt; configured with boost::system::error_code, boost::exception_ptr and policy::default_policy.
This type alias always references the std edition of things, unlike outcome&amp;lt;T, EC = varies, EP = varies, NoValuePolicy = policy::default_policy&amp;lt;T, EC, EP&amp;gt;&amp;gt; which references either this alias or std_outcome&amp;lt;T, EC = std::error_code, EP = std::exception_ptr, NoValuePolicy = policy::default_policy&amp;lt;T, EC, EP&amp;gt;&amp;gt;.
Namespace: OUTCOME_V2_NAMESPACE
Header: &amp;lt;outcome/boost_outcome.hpp&amp;gt;</description>
    </item>
    
    <item>
      <title>`boost_result&lt;T, E = boost::system::error_code, NoValuePolicy = policy::default_policy&lt;T, E, void&gt;&gt;`</title>
      <link>https://ned14.github.io/outcome/reference/aliases/boost_result/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/aliases/boost_result/</guid>
      <description>A type alias to a basic_result&amp;lt;T, E, NoValuePolicy&amp;gt; configured with boost::system::error_code and policy::default_policy.
This type alias always references the boost edition of things, unlike result&amp;lt;T, E = varies, NoValuePolicy = policy::default_policy&amp;lt;T, E, void&amp;gt;&amp;gt; which references either this alias or std_result&amp;lt;T, E = std::error_code, NoValuePolicy = policy::default_policy&amp;lt;T, E, void&amp;gt;&amp;gt;.
Namespace: OUTCOME_V2_NAMESPACE
Header: &amp;lt;outcome/boost_result.hpp&amp;gt;</description>
    </item>
    
    <item>
      <title>`boost_unchecked&lt;T, E = boost::system::error_code&gt;`</title>
      <link>https://ned14.github.io/outcome/reference/aliases/boost_unchecked/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/aliases/boost_unchecked/</guid>
      <description>A type alias to a basic_result&amp;lt;T, E, NoValuePolicy&amp;gt; configured with boost::system::error_code and policy::all_narrow.
This type alias always references the boost edition of things, unlike unchecked&amp;lt;T, E = varies&amp;gt; which references either this alias or std_unchecked&amp;lt;T, E = std::error_code&amp;gt;.
Namespace: OUTCOME_V2_NAMESPACE
Header: &amp;lt;outcome/boost_result.hpp&amp;gt;</description>
    </item>
    
    <item>
      <title>`checked&lt;T, E = varies&gt;`</title>
      <link>https://ned14.github.io/outcome/reference/aliases/checked/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/aliases/checked/</guid>
      <description>A type alias to either std_checked&amp;lt;T, E = std::error_code&amp;gt; (standalone edition) or boost_checked&amp;lt;T, E = boost::system::error_code&amp;gt; (Boost edition). This means that checked&amp;lt;T&amp;gt; uses the appropriate default alias depending on which edition of Outcome is in use.
Namespace: OUTCOME_V2_NAMESPACE
Header: &amp;lt;outcome/result.hpp&amp;gt;</description>
    </item>
    
    <item>
      <title>`decltype(auto) error_code(T &amp;&amp;)`</title>
      <link>https://ned14.github.io/outcome/reference/functions/policy/error_code/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/functions/policy/error_code/</guid>
      <description>Extracts a boost::system::error_code or  std::error_code from the input via ADL discovery of a suitable make_error_code(T) function.
Overridable: Argument dependent lookup.
Requires: Always available.
Namespace: OUTCOME_V2_NAMESPACE::policy
Header: &amp;lt;outcome/std_result.hpp&amp;gt;</description>
    </item>
    
    <item>
      <title>`decltype(auto) exception_ptr(T &amp;&amp;)`</title>
      <link>https://ned14.github.io/outcome/reference/functions/policy/exception_ptr/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/functions/policy/exception_ptr/</guid>
      <description>Extracts a boost::exception_ptr or  std::exception_ptr from the input via ADL discovery of a suitable make_exception_ptr(T) function.
Overridable: Argument dependent lookup.
Requires: Always available.
Namespace: OUTCOME_V2_NAMESPACE::policy
Header: &amp;lt;outcome/std_result.hpp&amp;gt;</description>
    </item>
    
    <item>
      <title>`default_policy&lt;T, EC, EP&gt;`</title>
      <link>https://ned14.github.io/outcome/reference/aliases/default_policy/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/aliases/default_policy/</guid>
      <description>A type alias to a no-value policy selected based on traits matching of T, EC and EP. It is defined as follows:
 If EC and EP is void, choose terminate.
 If is_error_code_available&amp;lt;T&amp;gt; true for EC, choose error_code_throw_as_system_error&amp;lt;T, EC, EP&amp;gt; for basic_outcome or error_code_throw_as_system_error&amp;lt;T, EC, void&amp;gt; for basic_result.
 If is_exception_ptr_available&amp;lt;T&amp;gt; true for EC or EP, choose exception_ptr_rethrow&amp;lt;T, EC, EP&amp;gt; for basic_outcome or exception_ptr_rethrow&amp;lt;T, EC, void&amp;gt; for basic_result.
 Else choose fail_to_compile_observers, which fails the build with a useful message.</description>
    </item>
    
    <item>
      <title>`error_code_throw_as_system_error&lt;T, EC, EP&gt;`</title>
      <link>https://ned14.github.io/outcome/reference/policies/error_code_throw_as_system_error_outcome/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/policies/error_code_throw_as_system_error_outcome/</guid>
      <description>Note: This policy class specialisation can only be used with basic_outcome, not basic_result. Use error_code_throw_as_system_error&amp;lt;T, EC, void&amp;gt; with basic_result.
Policy class defining that on incorrect wide value observation, EP ought to be rethrown if possible, then the ADL discovered free function outcome_throw_as_system_error_with_payload(impl.assume_error()) should be called. Some precanned overloads of that function are listed here.
Incorrect wide error observation performs:
OUTCOME_THROW_EXCEPTION(bad_outcome_access(&amp;#34;no error&amp;#34;));  Incorrect wide exception observation performs:
OUTCOME_THROW_EXCEPTION(bad_outcome_access(&amp;#34;no exception&amp;#34;));  Inherits publicly from base, and its narrow value, error and exception observer policies are inherited from there.</description>
    </item>
    
    <item>
      <title>`error_code_throw_as_system_error&lt;T, EC, void&gt;`</title>
      <link>https://ned14.github.io/outcome/reference/policies/error_code_throw_as_system_error_result/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/policies/error_code_throw_as_system_error_result/</guid>
      <description>Note: This policy class specialisation can only be used with basic_result, not basic_outcome. Use error_code_throw_as_system_error&amp;lt;T, EC, EP&amp;gt; with basic_outcome.
Policy class defining that the ADL discovered free function outcome_throw_as_system_error_with_payload(impl.assume_error()) should be called on incorrect wide value observation. Some precanned overloads of that function are listed here.
Incorrect wide error observation performs:
OUTCOME_THROW_EXCEPTION(bad_result_access(&amp;#34;no error&amp;#34;));  Inherits publicly from base, and its narrow value, error and exception observer policies are inherited from there.</description>
    </item>
    
    <item>
      <title>`exception_ptr_rethrow&lt;T, EC, EP&gt;`</title>
      <link>https://ned14.github.io/outcome/reference/policies/exception_ptr_rethrow_outcome/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/policies/exception_ptr_rethrow_outcome/</guid>
      <description>Note: This policy class specialisation can only be used with basic_outcome, not basic_result. Use exception_ptr_rethrow&amp;lt;T, EC, void&amp;gt; with basic_result.
Policy class defining that the ADL discovered free function rethrow_exception(impl.assume_exception()) if possible, followed by rethrow_exception(impl.assume_error()) should be called on incorrect wide value observation. Generally this will ADL discover  std::rethrow_exception() or boost::rethrow_exception() depending on the EC type.
Incorrect wide error observation performs:
OUTCOME_THROW_EXCEPTION(bad_outcome_access(&amp;#34;no error&amp;#34;));  Incorrect wide exception observation performs:
OUTCOME_THROW_EXCEPTION(bad_outcome_access(&amp;#34;no exception&amp;#34;));  Inherits publicly from base, and its narrow value, error and exception observer policies are inherited from there.</description>
    </item>
    
    <item>
      <title>`exception_ptr_rethrow&lt;T, EC, void&gt;`</title>
      <link>https://ned14.github.io/outcome/reference/policies/exception_ptr_rethrow_result/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/policies/exception_ptr_rethrow_result/</guid>
      <description>Note: This policy class specialisation can only be used with basic_result, not basic_outcome. Use exception_ptr_rethrow&amp;lt;T, EC, EP&amp;gt; with basic_outcome.
Policy class defining that the ADL discovered free function rethrow_exception(impl.assume_error()) should be called on incorrect wide value observation. Generally this will ADL discover  std::rethrow_exception() or boost::rethrow_exception() depending on the EC type.
Incorrect wide error observation performs:
OUTCOME_THROW_EXCEPTION(bad_result_access(&amp;#34;no error&amp;#34;));  Inherits publicly from base, and its narrow value, error and exception observer policies are inherited from there.</description>
    </item>
    
    <item>
      <title>`fail_to_compile_observers`</title>
      <link>https://ned14.github.io/outcome/reference/policies/fail_to_compile_observers/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/policies/fail_to_compile_observers/</guid>
      <description>Upon attempting to compile the wide observer policy functions, the following static assertion occurs which fails the build:
 Attempt to wide observe value, error or exception for a result/outcome given an EC or E type which is not void, and for whom trait::has_error_code_v, trait::has_exception_ptr_v, and trait::has_exception_ptr_v are all false. Please specify a NoValuePolicy to tell result/outcome what to do, or else use a more specific convenience type alias such as uncheckedto indicate you want the wide observers to be narrow, or checkedto indicate you always want an exception throw etc.</description>
    </item>
    
    <item>
      <title>`failure_type&lt;EC, EP = void&gt;`</title>
      <link>https://ned14.github.io/outcome/reference/types/failure_type/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/failure_type/</guid>
      <description>Type sugar for constructing an unsuccessful result or outcome. Generally not constructed directly, but via the free function failure(T &amp;amp;&amp;amp;, ...). Detectable using is_failure_type&amp;lt;T&amp;gt;.
This is a regular wrapper type, with defaulted default, copy and move constructor, defaulted assignment, and defaulted destructor.
Member type aliases error_type and exception_type indicate EC and E.
There is an explicit initialising constructor taking any types U and V which will forward construct the contained error_type and exception_type respectively.</description>
    </item>
    
    <item>
      <title>`in_place_type_t&lt;T&gt;`</title>
      <link>https://ned14.github.io/outcome/reference/types/in_place_type_t/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/in_place_type_t/</guid>
      <description>Either std::in_place_type_t&amp;lt;T&amp;gt; or a local emulation, depending on the OUTCOME_USE_STD_IN_PLACE_TYPE macro.
Note that the templated variable in_place_type is also aliased or emulated locally.
Requires: Nothing.
Namespace: OUTCOME_V2_NAMESPACE
Header: &amp;lt;outcome/config.hpp&amp;gt;</description>
    </item>
    
    <item>
      <title>`is_basic_outcome&lt;T&gt;`</title>
      <link>https://ned14.github.io/outcome/reference/traits/is_basic_outcome/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/traits/is_basic_outcome/</guid>
      <description>An integral constant type true for basic_outcome&amp;lt;T, EC, EP, NoValuePolicy&amp;gt; types.
Overridable: Not overridable.
Namespace: OUTCOME_V2_NAMESPACE
Header: &amp;lt;outcome/basic_outcome.hpp&amp;gt;
Variable alias: is_basic_outcome_v&amp;lt;T&amp;gt;</description>
    </item>
    
    <item>
      <title>`is_basic_result&lt;T&gt;`</title>
      <link>https://ned14.github.io/outcome/reference/traits/is_basic_result/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/traits/is_basic_result/</guid>
      <description>An integral constant type true for basic_result&amp;lt;T, E, NoValuePolicy&amp;gt; types.
Overridable: Not overridable.
Namespace: OUTCOME_V2_NAMESPACE
Header: &amp;lt;outcome/basic_result.hpp&amp;gt;
Variable alias: is_basic_result_v&amp;lt;T&amp;gt;</description>
    </item>
    
    <item>
      <title>`is_error_code_available&lt;T&gt;`</title>
      <link>https://ned14.github.io/outcome/reference/traits/is_error_code_available/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/traits/is_error_code_available/</guid>
      <description>True if an error code can be constructed from a T e.g. if there exists an ADL discovered free function make_error_code(T).
Overridable: By template specialisation into the trait namespace.
Default: True if T is an error code, else to metaprogramming which performs the ADL discovery of make_error_code(T). Note that the STL defines multiple overloads of an ADL discovered free function  std::make_error_code(T) for its error enumerations, as does Boost.System for the Boost error enumerations.</description>
    </item>
    
    <item>
      <title>`is_error_type&lt;E&gt;`</title>
      <link>https://ned14.github.io/outcome/reference/traits/is_error_type/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/traits/is_error_type/</guid>
      <description>A customisable integral constant type true for E types which are to receive error throwing no-value policies.
Overridable: By template specialisation into the trait namespace.
Default: False. Specialisations to true exist for:
 &amp;lt;outcome/boost_result.hpp&amp;gt;
 boost::system::error_code boost::system::errc::errc_t boost::exception_ptr  &amp;lt;outcome/std_result.hpp&amp;gt;
 std::error_code std::errc std::exception_ptr   Namespace: OUTCOME_V2_NAMESPACE::trait
Header: &amp;lt;outcome/trait.hpp&amp;gt;</description>
    </item>
    
    <item>
      <title>`is_error_type_enum&lt;E, Enum&gt;`</title>
      <link>https://ned14.github.io/outcome/reference/traits/is_error_type_enum/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/traits/is_error_type_enum/</guid>
      <description>A customisable integral constant type true for E types constructible from Enum types which are to receive error throwing no-value policies
Overridable: By template specialisation into the trait namespace.
Default: False. Specialisations exist for:
 &amp;lt;outcome/boost_result.hpp&amp;gt;
 boost::system::error_code to boost::system::is_error_condition_enum&amp;lt;Enum&amp;gt;::value.  &amp;lt;outcome/std_result.hpp&amp;gt;
 std::error_code to std::is_error_condition_enum&amp;lt;Enum&amp;gt;::value.   Namespace: OUTCOME_V2_NAMESPACE::trait
Header: &amp;lt;outcome/trait.hpp&amp;gt;</description>
    </item>
    
    <item>
      <title>`is_exception_ptr_available&lt;T&gt;`</title>
      <link>https://ned14.github.io/outcome/reference/traits/is_exception_ptr_available/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/traits/is_exception_ptr_available/</guid>
      <description>True if an exception ptr can be constructed from a T e.g. if there exists an ADL discovered free function make_exception_ptr(T).
Overridable: By template specialisation into the trait namespace.
Default: True if T is an exception ptr, else to metaprogramming which performs the ADL discovery of make_exception_ptr(T). Note that the STL defines an ADL discovered free function  std::make_exception_ptr(T). Thus this trait will pick up that free function.
Namespace: OUTCOME_V2_NAMESPACE::trait</description>
    </item>
    
    <item>
      <title>`is_failure_type&lt;T&gt;`</title>
      <link>https://ned14.github.io/outcome/reference/traits/is_failure_type/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/traits/is_failure_type/</guid>
      <description>An integral constant boolean variable true for failure_type&amp;lt;EC, EP = void&amp;gt; types.
Overridable: Not overridable.
Namespace: OUTCOME_V2_NAMESPACE
Header: &amp;lt;outcome/success_failure.hpp&amp;gt;</description>
    </item>
    
    <item>
      <title>`is_success_type&lt;T&gt;`</title>
      <link>https://ned14.github.io/outcome/reference/traits/is_success_type/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/traits/is_success_type/</guid>
      <description>An integral constant boolean variable true for success_type&amp;lt;T&amp;gt; types.
Overridable: Not overridable.
Namespace: OUTCOME_V2_NAMESPACE
Header: &amp;lt;outcome/success_failure.hpp&amp;gt;</description>
    </item>
    
    <item>
      <title>`outcome&lt;T, EC = varies, EP = varies, NoValuePolicy = policy::default_policy&lt;T, EC, EP&gt;&gt;`</title>
      <link>https://ned14.github.io/outcome/reference/aliases/outcome/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/aliases/outcome/</guid>
      <description>A type alias to either std_outcome&amp;lt;T, EC = std::error_code, EP = std::exception_ptr, NoValuePolicy = policy::default_policy&amp;lt;T, EC, EP&amp;gt;&amp;gt; (standalone edition) or boost_outcome&amp;lt;T, EC = boost::system::error_code, EP = boost::exception_ptr, NoValuePolicy = policy::default_policy&amp;lt;T, EC, EP&amp;gt;&amp;gt; (Boost edition), and policy::default_policy. This means that outcome&amp;lt;T&amp;gt; uses the appropriate default alias depending on which edition of Outcome is in use.
Namespace: OUTCOME_V2_NAMESPACE
Header: &amp;lt;outcome/outcome.hpp&amp;gt;</description>
    </item>
    
    <item>
      <title>`result&lt;T, E = varies, NoValuePolicy = policy::default_policy&lt;T, E, void&gt;&gt;`</title>
      <link>https://ned14.github.io/outcome/reference/aliases/result/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/aliases/result/</guid>
      <description>A type alias to either std_result&amp;lt;T, E = std::error_code, NoValuePolicy = policy::default_policy&amp;lt;T, E, void&amp;gt;&amp;gt; (standalone edition) or boost_result&amp;lt;T, E = boost::system::error_code, NoValuePolicy = policy::default_policy&amp;lt;T, E, void&amp;gt;&amp;gt; (Boost edition), and policy::default_policy. This means that result&amp;lt;T&amp;gt; uses the appropriate default alias depending on which edition of Outcome is in use.
Namespace: OUTCOME_V2_NAMESPACE
Header: &amp;lt;outcome/result.hpp&amp;gt;</description>
    </item>
    
    <item>
      <title>`std::error_code error_from_exception(std::exception_ptr &amp;&amp;ep = std::current_exception(), std::error_code not_matched = std::make_error_code(std::errc::resource_unavailable_try_again)) noexcept`</title>
      <link>https://ned14.github.io/outcome/reference/functions/error_from_exception/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/functions/error_from_exception/</guid>
      <description>This function saves writing boilerplate by rethrowing ep within a try block, with a long sequence of catch() handlers, one for every standard C++ exception type which has a near or exact equivalent code in  std::errc.
If matched, ep is set to a default constructed  std::exception_ptr, and a  std::error_code is constructed using the ADL discovered free function make_error_code() upon the std::errc enumeration value matching the thrown exception.</description>
    </item>
    
    <item>
      <title>`std::experimental::unexpected&lt;E&gt; try_operation_return_as(std::experimental::expected&lt;T, E&gt;)`</title>
      <link>https://ned14.github.io/outcome/reference/functions/try_operation_return_as_expected/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/functions/try_operation_return_as_expected/</guid>
      <description>This implementation of try_operation_return_as(expr) returns an unexpected for any expected input. This allows the use of functions returning std::experimental::expected&amp;lt;T, E&amp;gt; in OUTCOME_TRY(...).
Requires: Always available.
Namespace: OUTCOME_V2_NAMESPACE
Header: &amp;lt;outcome/try.hpp&amp;gt;</description>
    </item>
    
    <item>
      <title>`std::istream &amp;operator&gt;&gt;(std::istream &amp;, basic_outcome&lt;T, EC, EP, NoValuePolicy&gt; &amp;)`</title>
      <link>https://ned14.github.io/outcome/reference/functions/iostream/outcome_operator_in/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/functions/iostream/outcome_operator_in/</guid>
      <description>Deserialises a basic_outcome from a std::istream.
Serialisation format is:
&amp;lt;unsigned int flags&amp;gt;&amp;lt;space&amp;gt;&amp;lt;value_type if set and not void&amp;gt;&amp;lt;error_type if set and not void&amp;gt;&amp;lt;exception_type if set and not void&amp;gt;  Overridable: Not overridable.
Requires: That operator&amp;gt;&amp;gt; is a valid expression for std::istream and T, EC and EP.
Namespace: OUTCOME_V2_NAMESPACE
Header: &amp;lt;outcome/iostream_support.hpp&amp;gt; (must be explicitly included manually).</description>
    </item>
    
    <item>
      <title>`std::istream &amp;operator&gt;&gt;(std::istream &amp;, basic_result&lt;T, E, NoValuePolicy&gt; &amp;)`</title>
      <link>https://ned14.github.io/outcome/reference/functions/iostream/result_operator_in/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/functions/iostream/result_operator_in/</guid>
      <description>Deserialises a basic_result from a std::istream.
Serialisation format is:
&amp;lt;unsigned int flags&amp;gt;&amp;lt;space&amp;gt;&amp;lt;value_type if set and not void&amp;gt;&amp;lt;error_type if set and not void&amp;gt;  Overridable: Not overridable.
Requires: That operator&amp;gt;&amp;gt; is a valid expression for std::istream and T and E.
Namespace: OUTCOME_V2_NAMESPACE
Header: &amp;lt;outcome/iostream_support.hpp&amp;gt; (must be explicitly included manually).</description>
    </item>
    
    <item>
      <title>`std::ostream &amp;operator&lt;&lt;(std::ostream &amp;, const basic_outcome&lt;T, EC, EP, NoValuePolicy&gt; &amp;)`</title>
      <link>https://ned14.github.io/outcome/reference/functions/iostream/outcome_operator_out/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/functions/iostream/outcome_operator_out/</guid>
      <description>Serialises a basic_outcome to a std::ostream.
Serialisation format is:
&amp;lt;unsigned int flags&amp;gt;&amp;lt;space&amp;gt;&amp;lt;value_type if set and not void&amp;gt;&amp;lt;error_type if set and not void&amp;gt;&amp;lt;exception_type if set and not void&amp;gt;  This is the wrong function to use if you wish to print human readable output. Use std::string print(const basic_outcome&amp;lt;T, EC, EP, NoValuePolicy&amp;gt; &amp;amp;) instead.
Overridable: Not overridable.
Requires: That operator&amp;lt;&amp;lt; is a valid expression for std::ostream and T, EC and EP.
Namespace: OUTCOME_V2_NAMESPACE</description>
    </item>
    
    <item>
      <title>`std::ostream &amp;operator&lt;&lt;(std::ostream &amp;, const basic_result&lt;T, E, NoValuePolicy&gt; &amp;)`</title>
      <link>https://ned14.github.io/outcome/reference/functions/iostream/result_operator_out/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/functions/iostream/result_operator_out/</guid>
      <description>Serialises a basic_result to a std::ostream.
Serialisation format is:
&amp;lt;unsigned int flags&amp;gt;&amp;lt;space&amp;gt;&amp;lt;value_type if set and not void&amp;gt;&amp;lt;error_type if set and not void&amp;gt;  This is the wrong function to use if you wish to print human readable output. Use std::string print(const basic_result&amp;lt;T, E, NoValuePolicy&amp;gt; &amp;amp;) instead.
Overridable: Not overridable.
Requires: That operator&amp;lt;&amp;lt; is a valid expression for std::ostream and T and E.
Namespace: OUTCOME_V2_NAMESPACE
Header: &amp;lt;outcome/iostream_support.hpp&amp;gt; (must be explicitly included manually).</description>
    </item>
    
    <item>
      <title>`std::string print(const basic_outcome&lt;T, EC, EP, NoValuePolicy&gt; &amp;)`</title>
      <link>https://ned14.github.io/outcome/reference/functions/iostream/outcome_print/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/functions/iostream/outcome_print/</guid>
      <description>Returns a string containing a human readable rendition of the basic_outcome.
Overridable: Not overridable.
Requires: Always available.
Namespace: OUTCOME_V2_NAMESPACE
Header: &amp;lt;outcome/iostream_support.hpp&amp;gt; (must be explicitly included manually).</description>
    </item>
    
    <item>
      <title>`std::string print(const basic_result&lt;T, E, NoValuePolicy&gt; &amp;)`</title>
      <link>https://ned14.github.io/outcome/reference/functions/iostream/result_print/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/functions/iostream/result_print/</guid>
      <description>Returns a string containing a human readable rendition of the basic_result.
Overridable: Not overridable.
Requires: Always available.
Namespace: OUTCOME_V2_NAMESPACE
Header: &amp;lt;outcome/iostream_support.hpp&amp;gt; (must be explicitly included manually).</description>
    </item>
    
    <item>
      <title>`std_checked&lt;T, E = std::error_code&gt;`</title>
      <link>https://ned14.github.io/outcome/reference/aliases/std_checked/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/aliases/std_checked/</guid>
      <description>A type alias to a basic_result&amp;lt;T, E, NoValuePolicy&amp;gt; configured with  std::error_code and policy::throw_bad_result_access&amp;lt;EC&amp;gt;.
This type alias always references the std edition of things, unlike checked&amp;lt;T, E = varies&amp;gt; which references either this alias or boost_checked&amp;lt;T, E = boost::system::error_code&amp;gt;.
Namespace: OUTCOME_V2_NAMESPACE
Header: &amp;lt;outcome/std_result.hpp&amp;gt;</description>
    </item>
    
    <item>
      <title>`std_outcome&lt;T, EC = std::error_code, EP = std::exception_ptr, NoValuePolicy = policy::default_policy&lt;T, EC, EP&gt;&gt;`</title>
      <link>https://ned14.github.io/outcome/reference/aliases/std_outcome/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/aliases/std_outcome/</guid>
      <description>A type alias to a basic_outcome&amp;lt;T, EC, EP, NoValuePolicy&amp;gt; configured with  std::error_code,  std::exception_ptr and policy::default_policy.
This type alias always references the std edition of things, unlike outcome&amp;lt;T, EC = varies, EP = varies, NoValuePolicy = policy::default_policy&amp;lt;T, EC, EP&amp;gt;&amp;gt; which references either this alias or boost_outcome&amp;lt;T, EC = boost::system::error_code, EP = boost::exception_ptr, NoValuePolicy = policy::default_policy&amp;lt;T, EC, EP&amp;gt;&amp;gt;.
Namespace: OUTCOME_V2_NAMESPACE
Header: &amp;lt;outcome/std_outcome.hpp&amp;gt;</description>
    </item>
    
    <item>
      <title>`std_result&lt;T, E = std::error_code, NoValuePolicy = policy::default_policy&lt;T, E, void&gt;&gt;`</title>
      <link>https://ned14.github.io/outcome/reference/aliases/std_result/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/aliases/std_result/</guid>
      <description>A type alias to a basic_result&amp;lt;T, E, NoValuePolicy&amp;gt; configured with  std::error_code and policy::default_policy.
This type alias always references the std edition of things, unlike result&amp;lt;T, E = varies, NoValuePolicy = policy::default_policy&amp;lt;T, E, void&amp;gt;&amp;gt; which references either this alias or boost_result&amp;lt;T, E = boost::system::error_code, NoValuePolicy = policy::default_policy&amp;lt;T, E, void&amp;gt;&amp;gt;.
Namespace: OUTCOME_V2_NAMESPACE
Header: &amp;lt;outcome/std_result.hpp&amp;gt;</description>
    </item>
    
    <item>
      <title>`std_unchecked&lt;T, E = std::error_code&gt;`</title>
      <link>https://ned14.github.io/outcome/reference/aliases/std_unchecked/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/aliases/std_unchecked/</guid>
      <description>A type alias to a basic_result&amp;lt;T, E, NoValuePolicy&amp;gt; configured with  std::error_code and policy::all_narrow.
This type alias always references the std edition of things, unlike unchecked&amp;lt;T, E = varies&amp;gt; which references either this alias or boost_unchecked&amp;lt;T, E = boost::system::error_code&amp;gt;.
Namespace: OUTCOME_V2_NAMESPACE
Header: &amp;lt;outcome/std_result.hpp&amp;gt;</description>
    </item>
    
    <item>
      <title>`success_type&lt;T&gt;`</title>
      <link>https://ned14.github.io/outcome/reference/types/success_type/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/success_type/</guid>
      <description>Type sugar for constructing a successful result or outcome. Generally not constructed directly, but via the free function success(T &amp;amp;&amp;amp;). Detectable using is_success_type&amp;lt;T&amp;gt;.
This is a regular wrapper type, with defaulted default, copy and move constructor, defaulted assignment, and defaulted destructor.
A member type alias value_type indicates T.
There is an explicit initialising constructor taking any type U which is not a success_type&amp;lt;T&amp;gt;, and which will forward construct the contained T from that U.</description>
    </item>
    
    <item>
      <title>`terminate`</title>
      <link>https://ned14.github.io/outcome/reference/policies/terminate/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/policies/terminate/</guid>
      <description>Policy class defining that  std::terminate() should be called on incorrect wide value, error or exception observation.
Inherits publicly from base, and its narrow value, error and exception observer policies are inherited from there.
Included by &amp;lt;basic_result.hpp&amp;gt;, and so is always available when basic_result is available.
Requires: Nothing.
Namespace: OUTCOME_V2_NAMESPACE::policy
Header: &amp;lt;outcome/policy/terminate.hpp&amp;gt;</description>
    </item>
    
    <item>
      <title>`throw_bad_result_access&lt;EC&gt;`</title>
      <link>https://ned14.github.io/outcome/reference/policies/throw_bad_result_access/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/policies/throw_bad_result_access/</guid>
      <description>Policy class defining that bad_result_access_with&amp;lt;EC&amp;gt; should be thrown on incorrect wide value observation. The primary purpose of this policy is to enable standing in for  P0323 std::expected&amp;lt;T, E&amp;gt; which throws a bad_expected_access&amp;lt;E&amp;gt; on incorrect wide value observation. This is why it is only ever EC which is thrown with bad_result_access_with&amp;lt;EC&amp;gt; on value observation only, and only when there is an error available.
If used in basic_outcome, and the outcome is exceptioned and so no error is available, incorrect wide value observation performs instead:</description>
    </item>
    
    <item>
      <title>`try_operation_return_as(expr)`</title>
      <link>https://ned14.github.io/outcome/reference/converters/try_operation_return_as/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/converters/try_operation_return_as/</guid>
      <description>A customisable converter of ValueOrError&amp;lt;T, E&amp;gt; concept matching types to a returnable failure type.
Overridable: Argument dependent lookup.
Default: A number of implementations are provided by default:
 try_operation_return_as(T &amp;amp;&amp;amp;) which requires T to provide an .as_failure() member function in order to be available. This is selected for all basic_result and basic_outcome types. See auto try_operation_return_as(T &amp;amp;&amp;amp;).
 Copy and move editions of try_operation_return_as(std::experimental::expected&amp;lt;T, E&amp;gt;) which return a std::experimental::unexpected&amp;lt;E&amp;gt; for the input&amp;rsquo;s .</description>
    </item>
    
    <item>
      <title>`type_can_be_used_in_basic_result&lt;R&gt;`</title>
      <link>https://ned14.github.io/outcome/reference/traits/type_can_be_used_in_basic_result/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/traits/type_can_be_used_in_basic_result/</guid>
      <description>A constexpr boolean true for types permissible in basic_result&amp;lt;T, E, NoValuePolicy&amp;gt;.
Overridable: Not overridable.
Definition: True for a type which:
 Is not a reference. Is not an in_place_type_t&amp;lt;T&amp;gt;. Is not a success_type&amp;lt;T&amp;gt;. Is not a failure_type&amp;lt;EC, EP = void&amp;gt;. Is not an array. Is either void, or else is an Object and is Destructible.  Namespace: OUTCOME_V2_NAMESPACE::trait
Header: &amp;lt;outcome/trait.hpp&amp;gt;</description>
    </item>
    
    <item>
      <title>`uint16_t spare_storage(const basic_result|basic_outcome *) noexcept`</title>
      <link>https://ned14.github.io/outcome/reference/functions/hooks/spare_storage/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/functions/hooks/spare_storage/</guid>
      <description>Returns the sixteen bits of spare storage in the specified result or outcome. You can set these bits using void set_spare_storage(basic_result|basic_outcome *, uint16_t) noexcept.
Overridable: Not overridable.
Requires: Nothing.
Namespace: OUTCOME_V2_NAMESPACE::hooks
Header: &amp;lt;outcome/basic_result.hpp&amp;gt;</description>
    </item>
    
    <item>
      <title>`unchecked&lt;T, E = varies&gt;`</title>
      <link>https://ned14.github.io/outcome/reference/aliases/unchecked/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/aliases/unchecked/</guid>
      <description>A type alias to either std_unchecked&amp;lt;T, E = std::error_code&amp;gt; (standalone edition) or boost_unchecked&amp;lt;T, E = boost::system::error_code&amp;gt; (Boost edition). This means that unchecked&amp;lt;T&amp;gt; uses the appropriate default alias depending on which edition of Outcome is in use.
Namespace: OUTCOME_V2_NAMESPACE
Header: &amp;lt;outcome/result.hpp&amp;gt;</description>
    </item>
    
    <item>
      <title>`value_or_error&lt;T, U&gt;`</title>
      <link>https://ned14.github.io/outcome/reference/converters/value_or_error/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/converters/value_or_error/</guid>
      <description>A customisable converter of ValueOrError&amp;lt;T, E&amp;gt; concept matching types. It must have the following form:
// `T` will be the destination basic_result or basic_outcome. // `U` will be the decayed form of the `ValueOrError&amp;lt;T, E&amp;gt;` concept matching input type. template &amp;lt;classT&amp;gt; struct value_or_error&amp;lt;T, U&amp;gt; { // False to indicate that this converter wants `basic_result`/`basic_outcome` to reject all other `basic_result`  static constexpr bool enable_result_inputs = false; // False to indicate that this converter wants `basic_outcome` to reject all other `basic_outcome`  static constexpr bool enable_outcome_inputs = false; // `X` will be the raw input form of `U`.</description>
    </item>
    
    <item>
      <title>`void hook_outcome_construction(T *, U &amp;&amp;) noexcept`</title>
      <link>https://ned14.github.io/outcome/reference/functions/hooks/hook_outcome_construction/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/functions/hooks/hook_outcome_construction/</guid>
      <description>One of the constructor hooks for basic_outcome&amp;lt;T, EC, EP, NoValuePolicy&amp;gt;, generally invoked by the implicit constructors of basic_outcome. See each constructor&amp;rsquo;s documentation to see which specific hook it invokes.
Overridable: By Argument Dependent Lookup.
Requires: Nothing.
Namespace: OUTCOME_V2_NAMESPACE::hooks
Header: &amp;lt;outcome/basic_outcome.hpp&amp;gt;</description>
    </item>
    
    <item>
      <title>`void hook_outcome_construction(T *, U &amp;&amp;, V &amp;&amp;) noexcept`</title>
      <link>https://ned14.github.io/outcome/reference/functions/hooks/hook_outcome_construction2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/functions/hooks/hook_outcome_construction2/</guid>
      <description>One of the constructor hooks for basic_outcome&amp;lt;T, EC, EP, NoValuePolicy&amp;gt;, generally invoked by the implicit constructors of basic_outcome which consume two arguments. See each constructor&amp;rsquo;s documentation to see which specific hook it invokes.
Overridable: By Argument Dependent Lookup.
Requires: Nothing.
Namespace: OUTCOME_V2_NAMESPACE::hooks
Header: &amp;lt;outcome/basic_outcome.hpp&amp;gt;</description>
    </item>
    
    <item>
      <title>`void hook_outcome_copy_construction(T *, U &amp;&amp;) noexcept`</title>
      <link>https://ned14.github.io/outcome/reference/functions/hooks/hook_outcome_copy_construction/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/functions/hooks/hook_outcome_copy_construction/</guid>
      <description>One of the constructor hooks for basic_outcome&amp;lt;T, EC, EP, NoValuePolicy&amp;gt;, generally invoked by the converting copy constructors of basic_outcome (NOT the standard copy constructor). See each constructor&amp;rsquo;s documentation to see which specific hook it invokes.
Overridable: By Argument Dependent Lookup.
Requires: Nothing.
Namespace: OUTCOME_V2_NAMESPACE::hooks
Header: &amp;lt;outcome/basic_outcome.hpp&amp;gt;</description>
    </item>
    
    <item>
      <title>`void hook_outcome_copy_construction(T *, U &amp;&amp;, V &amp;&amp;) noexcept`</title>
      <link>https://ned14.github.io/outcome/reference/functions/hooks/hook_outcome_copy_construction2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/functions/hooks/hook_outcome_copy_construction2/</guid>
      <description>One of the constructor hooks for basic_outcome&amp;lt;T, EC, EP, NoValuePolicy&amp;gt;, generally invoked by the converting copy constructors of basic_outcome (NOT the standard copy constructor) which consume two arguments. See each constructor&amp;rsquo;s documentation to see which specific hook it invokes.
Overridable: By Argument Dependent Lookup.
Requires: Nothing.
Namespace: OUTCOME_V2_NAMESPACE::hooks
Header: &amp;lt;outcome/basic_outcome.hpp&amp;gt;</description>
    </item>
    
    <item>
      <title>`void hook_outcome_in_place_construction(T *, in_place_type_t&lt;U&gt;, Args &amp;&amp;...) noexcept`</title>
      <link>https://ned14.github.io/outcome/reference/functions/hooks/hook_outcome_in_place_construction/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/functions/hooks/hook_outcome_in_place_construction/</guid>
      <description>One of the constructor hooks for basic_outcome&amp;lt;T, EC, EP, NoValuePolicy&amp;gt;, generally invoked by the in-place constructors of basic_outcome. See each constructor&amp;rsquo;s documentation to see which specific hook it invokes.
Overridable: By Argument Dependent Lookup.
Requires: Nothing.
Namespace: OUTCOME_V2_NAMESPACE::hooks
Header: &amp;lt;outcome/basic_outcome.hpp&amp;gt;</description>
    </item>
    
    <item>
      <title>`void hook_outcome_move_construction(T *, U &amp;&amp;) noexcept`</title>
      <link>https://ned14.github.io/outcome/reference/functions/hooks/hook_outcome_move_construction/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/functions/hooks/hook_outcome_move_construction/</guid>
      <description>One of the constructor hooks for basic_outcome&amp;lt;T, EC, EP, NoValuePolicy&amp;gt;, generally invoked by the converting move constructors of basic_outcome (NOT the standard move constructor). See each constructor&amp;rsquo;s documentation to see which specific hook it invokes.
Overridable: By Argument Dependent Lookup.
Requires: Nothing.
Namespace: OUTCOME_V2_NAMESPACE::hooks
Header: &amp;lt;outcome/basic_outcome.hpp&amp;gt;</description>
    </item>
    
    <item>
      <title>`void hook_outcome_move_construction(T *, U &amp;&amp;, V &amp;&amp;) noexcept`</title>
      <link>https://ned14.github.io/outcome/reference/functions/hooks/hook_outcome_move_construction2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/functions/hooks/hook_outcome_move_construction2/</guid>
      <description>One of the constructor hooks for basic_outcome&amp;lt;T, EC, EP, NoValuePolicy&amp;gt;, generally invoked by the converting move constructors of basic_outcome (NOT the standard move constructor) which consume two arguments. See each constructor&amp;rsquo;s documentation to see which specific hook it invokes.
Overridable: By Argument Dependent Lookup.
Requires: Nothing.
Namespace: OUTCOME_V2_NAMESPACE::hooks
Header: &amp;lt;outcome/basic_outcome.hpp&amp;gt;</description>
    </item>
    
    <item>
      <title>`void hook_result_construction(T *, U &amp;&amp;) noexcept`</title>
      <link>https://ned14.github.io/outcome/reference/functions/hooks/hook_result_construction/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/functions/hooks/hook_result_construction/</guid>
      <description>One of the constructor hooks for basic_result&amp;lt;T, E, NoValuePolicy&amp;gt;, generally invoked by the implicit constructors of basic_result. See each constructor&amp;rsquo;s documentation to see which specific hook it invokes.
Overridable: By Argument Dependent Lookup.
Requires: Nothing.
Namespace: OUTCOME_V2_NAMESPACE::hooks
Header: &amp;lt;outcome/basic_result.hpp&amp;gt;</description>
    </item>
    
    <item>
      <title>`void hook_result_copy_construction(T *, U &amp;&amp;) noexcept`</title>
      <link>https://ned14.github.io/outcome/reference/functions/hooks/hook_result_copy_construction/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/functions/hooks/hook_result_copy_construction/</guid>
      <description>One of the constructor hooks for basic_result&amp;lt;T, E, NoValuePolicy&amp;gt;, generally invoked by the converting copy constructors of basic_result (NOT the standard copy constructor). See each constructor&amp;rsquo;s documentation to see which specific hook it invokes.
Overridable: By Argument Dependent Lookup.
Requires: Nothing.
Namespace: OUTCOME_V2_NAMESPACE::hooks
Header: &amp;lt;outcome/basic_result.hpp&amp;gt;</description>
    </item>
    
    <item>
      <title>`void hook_result_in_place_construction(T *, in_place_type_t&lt;U&gt;, Args &amp;&amp;...) noexcept`</title>
      <link>https://ned14.github.io/outcome/reference/functions/hooks/hook_result_in_place_construction/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/functions/hooks/hook_result_in_place_construction/</guid>
      <description>One of the constructor hooks for basic_result&amp;lt;T, E, NoValuePolicy&amp;gt;, generally invoked by the in-place constructors of basic_result. See each constructor&amp;rsquo;s documentation to see which specific hook it invokes.
Overridable: By Argument Dependent Lookup.
Requires: Nothing.
Namespace: OUTCOME_V2_NAMESPACE::hooks
Header: &amp;lt;outcome/basic_result.hpp&amp;gt;</description>
    </item>
    
    <item>
      <title>`void hook_result_move_construction(T *, U &amp;&amp;) noexcept`</title>
      <link>https://ned14.github.io/outcome/reference/functions/hooks/hook_result_move_construction/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/functions/hooks/hook_result_move_construction/</guid>
      <description>One of the constructor hooks for basic_result&amp;lt;T, E, NoValuePolicy&amp;gt;, generally invoked by the converting move constructors of basic_result (NOT the standard move constructor). See each constructor&amp;rsquo;s documentation to see which specific hook it invokes.
Overridable: By Argument Dependent Lookup.
Requires: Nothing.
Namespace: OUTCOME_V2_NAMESPACE::hooks
Header: &amp;lt;outcome/basic_result.hpp&amp;gt;</description>
    </item>
    
    <item>
      <title>`void outcome_throw_as_system_error_with_payload(BoostErrorCodeEnum &amp;&amp;)`</title>
      <link>https://ned14.github.io/outcome/reference/functions/policy/outcome_throw_as_system_error_with_payload_boost_enum/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/functions/policy/outcome_throw_as_system_error_with_payload_boost_enum/</guid>
      <description>A specialisation of outcome_throw_as_system_error_with_payload() for types where boost::system::errc::is_error_code_enum&amp;lt;BoostErrorCodeEnum&amp;gt; or boost::system::errc::is_error_condition_enum&amp;lt;BoostErrorCodeEnum&amp;gt; is true. This executes OUTCOME_THROW_EXCEPTION(expr) with a boost::system::system_error constructed from the result of the ADL discovered free function make_error_code(BoostErrorCodeEnum).
Overridable: Argument dependent lookup.
Requires: Either boost::system::errc::is_error_code_enum&amp;lt;T&amp;gt; or boost::system::errc::is_error_condition_enum&amp;lt;T&amp;gt; to be true for a decayed BoostErrorCodeEnum.
Namespace: boost::system
Header: &amp;lt;outcome/boost_result.hpp&amp;gt;</description>
    </item>
    
    <item>
      <title>`void outcome_throw_as_system_error_with_payload(ErrorCodeEnum &amp;&amp;)`</title>
      <link>https://ned14.github.io/outcome/reference/functions/policy/outcome_throw_as_system_error_with_payload_std_enum/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/functions/policy/outcome_throw_as_system_error_with_payload_std_enum/</guid>
      <description>A specialisation of outcome_throw_as_system_error_with_payload() for types where std::is_error_code_enum&amp;lt;ErrorCodeEnum&amp;gt; or std::is_error_condition_enum&amp;lt;ErrorCodeEnum&amp;gt; is true. This executes OUTCOME_THROW_EXCEPTION(expr) with a  std::system_error constructed from the result of the ADL discovered free function make_error_code(ErrorCodeEnum).
Overridable: Argument dependent lookup.
Requires: Either  std::is_error_code_enum&amp;lt;T&amp;gt; or  std::is_error_condition_enum&amp;lt;T&amp;gt; to be true for a decayed ErrorCodeEnum.
Namespace: std
Header: &amp;lt;outcome/std_result.hpp&amp;gt;</description>
    </item>
    
    <item>
      <title>`void outcome_throw_as_system_error_with_payload(const boost::system::error_code &amp;)`</title>
      <link>https://ned14.github.io/outcome/reference/functions/policy/outcome_throw_as_system_error_with_payload_boost_error_code/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/functions/policy/outcome_throw_as_system_error_with_payload_boost_error_code/</guid>
      <description>A specialisation of outcome_throw_as_system_error_with_payload() for boost::system::error_code. This executes OUTCOME_THROW_EXCEPTION(expr) with a boost::system::system_error constructed from the input.
Overridable: Argument dependent lookup.
Requires: Nothing.
Namespace: boost::system
Header: &amp;lt;outcome/boost_result.hpp&amp;gt;</description>
    </item>
    
    <item>
      <title>`void outcome_throw_as_system_error_with_payload(const std::error_code &amp;)`</title>
      <link>https://ned14.github.io/outcome/reference/functions/policy/outcome_throw_as_system_error_with_payload_std_error_code/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/functions/policy/outcome_throw_as_system_error_with_payload_std_error_code/</guid>
      <description>A specialisation of outcome_throw_as_system_error_with_payload() for std::error_code. This executes OUTCOME_THROW_EXCEPTION(expr) with a  std::system_error constructed from the input.
Overridable: Argument dependent lookup.
Requires: Nothing.
Namespace: std
Header: &amp;lt;outcome/std_result.hpp&amp;gt;</description>
    </item>
    
    <item>
      <title>`void override_outcome_exception(basic_outcome&lt;T, EC, EP, NoValuePolicy&gt; *, U &amp;&amp;) noexcept`</title>
      <link>https://ned14.github.io/outcome/reference/functions/hooks/override_outcome_exception/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/functions/hooks/override_outcome_exception/</guid>
      <description>Overrides the exception to something other than what was constructed. You almost certainly never want to use this function. A much better way of overriding the exception returned is to create a custom no-value policy which lazily synthesises a custom exception object at the point of need.
The only reason that this function exists is because some people have very corner case needs where a custom no-value policy can&amp;rsquo;t be used, and where move-constructing a new outcome from an old outcome with the exception state replaced isn&amp;rsquo;t possible (e.</description>
    </item>
    
    <item>
      <title>`void set_spare_storage(basic_result|basic_outcome *, uint16_t) noexcept`</title>
      <link>https://ned14.github.io/outcome/reference/functions/hooks/set_spare_storage/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/functions/hooks/set_spare_storage/</guid>
      <description>Sets the sixteen bits of spare storage in the specified result or outcome. You can retrieve these bits later using uint16_t spare_storage(const basic_result|basic_outcome *) noexcept.
Overridable: Not overridable.
Requires: Nothing.
Namespace: OUTCOME_V2_NAMESPACE::hooks
Header: &amp;lt;outcome/basic_result.hpp&amp;gt;</description>
    </item>
    
    <item>
      <title>`void try_throw_std_exception_from_error(std::error_code ec, const std::string &amp;msg = std::string{})`</title>
      <link>https://ned14.github.io/outcome/reference/functions/try_throw_std_exception_from_error/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/functions/try_throw_std_exception_from_error/</guid>
      <description>This function saves writing boilerplate by throwing a standard library exception type equivalent to the supplied error code, with an optional custom message.
If the function returns, there is no standard library exception type equivalent to the supplied error code. The following codes produce the following exception throws:
 EINVAL std::invalid_argument EDOM std::domain_error E2BIG std::length_error ERANGE std::out_of_range EOVERFLOW std::overflow_error ENOMEM std::bad_alloc  The choice to refer to POSIX errno values above reflects the matching algorithm.</description>
    </item>
    
  </channel>
</rss>