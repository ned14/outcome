<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Home on Outcome documentation</title>
    <link>https://ned14.github.io/outcome/</link>
    <description>Recent content in Home on Outcome documentation</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Tue, 16 Jul 2024 21:33:35 +0100</lastBuildDate>
    
	<atom:link href="https://ned14.github.io/outcome/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Before we begin</title>
      <link>https://ned14.github.io/outcome/tutorial/essential/before/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/tutorial/essential/before/</guid>
      <description>Outcome v2 namespace It is recommended that you refer to entities from this Outcome v2 via the following namespace alias:
namespace outcome = OUTCOME_V2_NAMESPACE; View this code on Github On standalone Outcome only, as patches and modifications are applied to this library, namespaces get permuted in order to not to cause binary incompatibility. At some point namespace outcome_v2 will be defined, and this will be the preferred namespace. Until then OUTCOME_V2_NAMESPACE denotes the most recently updated version, getting closer to outcome_v2.</description>
    </item>
    
    <item>
      <title>Incommensurate E types</title>
      <link>https://ned14.github.io/outcome/tutorial/advanced/interop/problem/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/tutorial/advanced/interop/problem/</guid>
      <description>Back in the essential tutorial section on result, we studied a likely very common initial choice of E type: a strongly typed enum. We saw how by marking up strongly typed enums to tell the C++ standard library what they are, they gain implicit convertibility into std::error_code, and we then pointed out that you might as well now always set E = std::error_code, as that comes with the enormous advantage that you can use the boilerplate saving OUTCOME_TRY macro when the E type is always the same.</description>
    </item>
    
    <item>
      <title>The main advantages</title>
      <link>https://ned14.github.io/outcome/experimental/advantages/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/experimental/advantages/</guid>
      <description>The main advantages of choosing &amp;lt;outcome/experimental&amp;gt; over default Outcome:
 Codegen is tighter and less verbose1, sometimes remarkably so.
 Build time impact is markedly lower, barely above the inclusion of naked &amp;lt;basic_result.hpp&amp;gt;, as the STL allocator machinery and std::string et al is not dragged into inclusion by including &amp;lt;system_error&amp;gt;. Note that &amp;lt;outcome/experimental/status_outcome.hpp&amp;gt; bring in &amp;lt;exception&amp;gt;, however &amp;lt;outcome/experimental/status_result.hpp&amp;gt; brings in no extra system headers.
 More discipline is imposed on your use of Outcome, leading to less ambiguous code which is easier to optimise by the compiler, lower cost to maintain, and lower cognitive load to audit code based on experimental Outcome for correctness.</description>
    </item>
    
    <item>
      <title>value_or_error Concept</title>
      <link>https://ned14.github.io/outcome/tutorial/advanced/interop/value-or-error/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/tutorial/advanced/interop/value-or-error/</guid>
      <description>Something not really mentioned until now is how Outcome interoperates with the proposed  P0323 std::expected&amp;lt;T, E&amp;gt; , whose design lands in between unchecked&amp;lt;T, E = varies&amp;gt; and checked&amp;lt;T, E = varies&amp;gt; (both of which are type aliases hard coding no-value policies as previously covered in this tutorial).
Expected and Outcome are isomorphic to one another in design intent, but interoperation for code using Expected and Outcome ought to be seamless thanks to the proposed ValueOrError concept framework, a subset of which Outcome implements.</description>
    </item>
    
    <item>
      <title>A custom no-value policy</title>
      <link>https://ned14.github.io/outcome/tutorial/essential/no-value/custom/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/tutorial/essential/no-value/custom/</guid>
      <description>If you want your basic_outcome&amp;lt;&amp;gt; or basic_result&amp;lt;&amp;gt; instances to call std::abort() whenever .value() is called on an object that does not contain a value, or .error() is called on an object that does not contain an error, you will need to define your own no-value policy as follows:
struct abort_policy : outcome::policy::base { template &amp;lt;classImpl&amp;gt; static constexpr void wide_value_check(Impl &amp;amp;&amp;amp;self) { if(!base::_has_value(std::forward&amp;lt;Impl&amp;gt;(self))) std::abort(); } template &amp;lt;classImpl&amp;gt; static constexpr void wide_error_check(Impl &amp;amp;&amp;amp;self) { if(!</description>
    </item>
    
    <item>
      <title>Approximate map between error code designs</title>
      <link>https://ned14.github.io/outcome/experimental/map/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/experimental/map/</guid>
      <description>Much of the design of Boost.System (which went on to become &amp;lt;system_error&amp;gt;) has been retained in proposed &amp;lt;system_error2&amp;gt;, so an approximate map between &amp;lt;system_error2&amp;gt; and &amp;lt;system_error&amp;gt; and Boost.System can be given:
  C++ 17 &amp;lt;system_error&amp;gt;Boost.SystemProposed &amp;lt;system_error2&amp;gt;  std::errc boost::system::errc experimental::errc (almost identical)  std::error_category boost::system::error_category experimental::status_code_domain  std::generic_category boost::system::generic_category experimental::generic_code_domain  std::system_category boost::system::system_category One of: experimental::posix_code_domain (POSIX systems) experimental::win32_code_domain (Microsoft Windows) experimental::nt_code_domain (Microsoft Windows)  Note that there are more precanned code categories though they require additional header inclusions: com_code, getaddrinfo_code.</description>
    </item>
    
    <item>
      <title>C system error results</title>
      <link>https://ned14.github.io/outcome/experimental/c-api/from-c/system_code/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/experimental/c-api/from-c/system_code/</guid>
      <description>In v2.2.11, C Result support went from second tier to first tier status, and now you can create, query and manipulate a subset of Result types entirely from within C by including &amp;lt;outcome/experimental/result.h&amp;gt;.
The subset supported are those result&amp;lt;T, E&amp;gt; which are a status_result&amp;lt;T&amp;gt; i.e. the E is hardcoded to experimental::error which is the type erased runtime polymorphic holder for any errored status_code whose payload is not bigger than an intptr_t.</description>
    </item>
    
    <item>
      <title>Coroutine TRY operation</title>
      <link>https://ned14.github.io/outcome/tutorial/essential/coroutines/try/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/tutorial/essential/coroutines/try/</guid>
      <description>As one cannot call statement return from within a Coroutine, the very first part of Outcome&amp;rsquo;s support for Coroutines is OUTCOME_CO_TRYV(expr)/OUTCOME_CO_TRY(expr) , which is literally the same as OUTCOME_TRY() except that co_return is called to return early instead of return.
eager&amp;lt;result&amp;lt;std::string&amp;gt;&amp;gt; to_string(int x) { if(x &amp;gt;= 0) { OUTCOME_CO_TRY(convert(x)); } co_return &amp;#34;out of range&amp;#34;; } </description>
    </item>
    
    <item>
      <title>Define a custom code domain</title>
      <link>https://ned14.github.io/outcome/experimental/worked-example-long/preamble/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/experimental/worked-example-long/preamble/</guid>
      <description>Firstly let&amp;rsquo;s alias the experimental Outcome namespace into something less tedious to type, declare our custom status code type, and get started on defining the custom status code domain implementation.
namespace outcome_e = OUTCOME_V2_NAMESPACE::experimental; // To define a `file_io_error` which participates in the P1028 world // of `std::error`, we must first declare, then define, a custom code // domain which extends `posix_code` (the std error coding for POSIX // failures). The following is fairly standard boilerplate for defining // a custom code domain.</description>
    </item>
    
    <item>
      <title>Exceptions</title>
      <link>https://ned14.github.io/outcome/motivation/exceptions/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/motivation/exceptions/</guid>
      <description>Exceptions are the default mechanism in C++ for reporting, propagating and processing the information about function failures. Their main advantage is the ability to describe the &amp;ldquo;success dependency&amp;rdquo; between functions: if you want to say that calling function g() depends on the successful execution of function f(), you just put g() below f() and that&amp;rsquo;s it:
int a() { f(); g(); // don&amp;#39;t call g() and further if f() fails  return h(); // don&amp;#39;t call h() if g() fails }  In the C++ Standard terms this means that f() is sequenced before g().</description>
    </item>
    
    <item>
      <title>Implicit construction</title>
      <link>https://ned14.github.io/outcome/experimental/worked-example/implicit-construction/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/experimental/worked-example/implicit-construction/</guid>
      <description>The preceding code had the compiler stamp out a custom status code domain for a user supplied enum. You now get the following types:
// This is the status code generated for your custom enum type. It will implicitly construct from // values of enum custom_failure. using custom_failure_code = SYSTEM_ERROR2_NAMESPACE::quick_status_code_from_enum_code&amp;lt;custom_failure&amp;gt;; namespace outcome_e = OUTCOME_V2_NAMESPACE::experimental; // You don&amp;#39;t usually need to use the status code type explicitly, because this &amp;#34;just works&amp;#34;: outcome_e::status_result&amp;lt;int&amp;gt; positive_only(int x) { if(x &amp;lt; 0) { // Outcome&amp;#39;s result sees that status_code will implicitly construct from this enum,  // and it returns an errored result  return custom_failure::bad_argument; } return x; } // Semantic comparisons work bool test(int x) { if(auto r = positive_only(x); !</description>
    </item>
    
    <item>
      <title>Keeping state</title>
      <link>https://ned14.github.io/outcome/tutorial/advanced/hooks/keeping_state/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/tutorial/advanced/hooks/keeping_state/</guid>
      <description>The first thing we are going to need is somewhere to store the stack backtrace. We could take the easier route and simply store it into an allocated block and keep the pointer as a custom payload in a result&amp;lt;T, std::pair&amp;lt;error_code, std::unique_ptr&amp;lt;stack_backtrace&amp;gt;&amp;gt;&amp;gt; (see previous section on Custom payloads). But let us assume that we care so deeply about bounded execution times that ever calling malloc is unacceptable.
We therefore are going to need some completely static and trivially typed storage perhaps kept per-thread to avoid the need to keep mutexes.</description>
    </item>
    
    <item>
      <title>The Filesystem TS</title>
      <link>https://ned14.github.io/outcome/tutorial/advanced/payload/copy_file/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/tutorial/advanced/payload/copy_file/</guid>
      <description>Something which has long annoyed the purists in the C++ leadership is the problem of dual overloads in error_code capable standard library APIs.
Consider the copy_file() API from the Filesystem TS:
namespace filesystem { /*! Copies the file at path `from` to path `to`. \returns True if file was successfully copied. \throws On failure throws `filesystem_error(ec.message(), from, to, ec)` with `ec` being the error code reported by the operating system. */ bool copy_file(const path &amp;amp;from, const path &amp;amp;to); /*!</description>
    </item>
    
    <item>
      <title>The HTTP library</title>
      <link>https://ned14.github.io/outcome/tutorial/advanced/interop/httplib/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/tutorial/advanced/interop/httplib/</guid>
      <description>Let us imagine a simple application: it fetches a HTTP page using a HTTP library, sends it through HTML tidy via the htmltidy library, and then writes it to disc using a filelib library. So three third party libraries, two using Outcome in incompatible ways, and the third being a C library just for kicks.
Let us imagine that the HTTP library has the following public interface:
// This is some standalone library implementing high level HTTP namespace httplib { // These are the error code that this HTTP library can return  enum classstatus_code { success = 0, // not the HTTP success code of 200  // A subset of all HTTP status codes for brevity  bad_request = 400, access_denied = 401, logon_failed = 402, forbidden = 403, not_found = 404, internal_error = 500 }; // This is the error type that this HTTP library can return  struct failure { status_code status{status_code::success}; std::string url{}; // The failing URL  }; // Localise a result implementation to this library, holding  // the logic error of incorrect observation to mean program  // termination.</description>
    </item>
    
    <item>
      <title>Two phase construction</title>
      <link>https://ned14.github.io/outcome/tutorial/advanced/constructors/two-phase-init/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/tutorial/advanced/constructors/two-phase-init/</guid>
      <description>The first thing to do is to break your object&amp;rsquo;s construction into two phases:
 Place the object into a state where it can be legally destructed without doing any initialisation which could throw an exception (i.e. everything done in phase 1 is constexpr). This phase usually involves initialising member variables to various default values, most often using default member initialisers. Most standard C++ library objects and containers have constexpr constructors, and thus can be initialised during phase 1.</description>
    </item>
    
    <item>
      <title>std exception throws</title>
      <link>https://ned14.github.io/outcome/alternatives/exceptions/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/alternatives/exceptions/</guid>
      <description>(Note that we assume a table-based EH implementation here, a SJLJ EH implementaton would have even happy and sad path runtime overhead. Table-based EH implementations are almost universal on x64, ARM and AArch64 targets).
C++ exception throws came in the original C++ 98 standard &amp;ndash; at that time, not all the major compilers implemented them yet, and several of those who did did not have efficient implementations, plus in the original days some compiler vendors still patented things like EH implementation techniques to try and maintain a competitive advantage over rival compilers.</description>
    </item>
    
    <item>
      <title>The HTMLTidy library</title>
      <link>https://ned14.github.io/outcome/tutorial/advanced/interop/tidylib/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/tutorial/advanced/interop/tidylib/</guid>
      <description>// There actually is a library for tidying HTML into XHTML called HTMLTidy // See http://www.html-tidy.org/ // HTMLTidy is actually a great tool for dealing with 1990s-era tag soup // HTML, I highly recommend it.  // This isn&amp;#39;t the API for Tidy, but let&amp;#39;s assume it&amp;#39;s a C library returning // errno domained error codes. out must be freed with free() after use. extern &amp;#34;C&amp;#34; int tidy_html(char **out, size_t *outlen, const char *in, size_t inlen); View this code on Github A C API may not initially appear to be a T|E based API, but if failure returns some domained error code and causes no other effects, and success returns some value, then it is effectively a &amp;ldquo;split&amp;rdquo; T|E API.</description>
    </item>
    
    <item>
      <title>A file handle</title>
      <link>https://ned14.github.io/outcome/tutorial/advanced/constructors/file_handle/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/tutorial/advanced/constructors/file_handle/</guid>
      <description>Borrowing from llfio::file_handle which uses this design pattern1, here is a simplified file_handle implementation:
classfile_handle { int _fd{-1}; // file descriptor  struct stat _stat { 0 }; // stat of the fd at open  // Phase 1 private constexpr constructor  constexpr file_handle() {} public: using path_type = filesystem::path; //! The behaviour of the handle: does it read, read and write, or atomic append?  enum classmode : unsigned char // bit 0 set means writable  { unchanged = 0, none = 2, //!</description>
    </item>
    
    <item>
      <title>ADL bridging</title>
      <link>https://ned14.github.io/outcome/tutorial/advanced/hooks/adl_bridging/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/tutorial/advanced/hooks/adl_bridging/</guid>
      <description>In Outcome v2.2 the ADL-based event hooks were replaced with policy-based event hooks (next page). The code in this section is still valid in v2.2 onwards, it&amp;rsquo;s just that ADL is no longer used to find the hooks.
 In a previous section, we used the failure_info type to create the ADL bridge into the namespace where the ADL discovered outcome_throw_as_system_error_with_payload() function was to be found.
Here we do the same, but more directly by creating a thin clone of std::error_code into the local namespace.</description>
    </item>
    
    <item>
      <title>Built-in policies</title>
      <link>https://ned14.github.io/outcome/tutorial/essential/no-value/builtin/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/tutorial/essential/no-value/builtin/</guid>
      <description>These are the predefined policies built into Outcome:
&amp;nbsp;
all_narrow If there is an observation of a value/error/exception which is not present, the program is put into a hard undefined behaviour situation. The compiler literally compiles no code for an invalid observation &amp;ndash; the CPU &amp;ldquo;runs off&amp;rdquo; into the unknown.
As bad as this may sound, it generates the most optimal code, and such hard UB is very tool-friendly for detection e.</description>
    </item>
    
    <item>
      <title>Coroutine awaitables</title>
      <link>https://ned14.github.io/outcome/tutorial/essential/coroutines/awaitables/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/tutorial/essential/coroutines/awaitables/</guid>
      <description>The second part of the support is provided by header &amp;lt;outcome/coroutine_support.hpp&amp;gt; (or &amp;lt;outcome/experimental/coroutine_support.hpp&amp;gt; if you want Coroutine support for Experimental Outcome). This adds into namespace OUTCOME_V2_NAMESPACE::awaitables (or OUTCOME_V2_NAMESPACE::experimental::awaitables) these awaitable types suitable for returning from a Coroutinised function:
 eager&amp;lt;T, Executor = void&amp;gt; An eagerly evaluated Coroutine: invoking co_await upon a function returning one of these immediately begins the execution of the function now. If the function never suspends, the overhead is similar to calling an ordinary function.</description>
    </item>
    
    <item>
      <title>Declare a Result</title>
      <link>https://ned14.github.io/outcome/experimental/c-api/from-c/declare/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/experimental/c-api/from-c/declare/</guid>
      <description>// Declare to C a Result with a happy value of intptr_t CXX_DECLARE_RESULT_SYSTEM(result_int, intptr_t) // Save oneself typing out CXX_RESULT_SYSTEM(result_int) all the time typedef CXX_RESULT_SYSTEM(result_int) result; // Our custom C enum enum c_enum { c_enum_not_found, c_enum_bad_argument }; // Make a custom status code domain for this C enum CXX_DECLARE_RESULT_SYSTEM_FROM_ENUM(result_int, // The C Result type declared above  c_enum, // The C enum we wish to wrap  &amp;#34;{74ceb994-7622-3a21-07f0-b016aa705585}&amp;#34;, // Unique UUID for this domain  // Mappings of C enum values to textual description and semantic equivalances to generic codes  {c_enum::c_enum_not_found, &amp;#34;item not found&amp;#34;, {errc::no_such_file_or_directory}}, {c_enum::c_enum_bad_argument, &amp;#34;invoked wrong&amp;#34;, {errc::invalid_argument}}) // Make helper macros #define SUCCESS(v) CXX_MAKE_RESULT_SYSTEM_SUCCESS(result_int, (v)) #define FAILURE(v) CXX_MAKE_RESULT_SYSTEM_FROM_ENUM(result_int, c_enum, (v)) View this code on Github The key to making C programming easy is to alias the long complex things into short easy thing.</description>
    </item>
    
    <item>
      <title>Example C&#43;&#43; function</title>
      <link>https://ned14.github.io/outcome/experimental/c-api/from-cxx/example/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/experimental/c-api/from-cxx/example/</guid>
      <description>Let us start with a simple C++ function which we wish to make available to C code:
namespace outcome_e = OUTCOME_V2_NAMESPACE::experimental; // Fill the supplied buffer with the integer v converted to a string, // returning length of string minus null terminator outcome_e::status_result&amp;lt;size_t&amp;gt; to_string(char *buffer, size_t bufferlen, int v) noexcept { try { // Could throw an exception!  std::string temp(std::to_string(v)); // Will this string exceed the supplied buffer?  if(temp.</description>
    </item>
    
    <item>
      <title>Inspecting result&lt;T, EC&gt;</title>
      <link>https://ned14.github.io/outcome/tutorial/essential/result/inspecting/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/tutorial/essential/result/inspecting/</guid>
      <description>Suppose we will be writing a function print_half that takes a std::string representing an integer and prints half the integer:
outcome::result&amp;lt;void&amp;gt; print_half(const std::string&amp;amp; text); View this code on Github The type result&amp;lt;void&amp;gt; means that there is no value to be returned upon success, but that the operation might still fail, and we may be interested in inspecting the cause of the failure. The class template result&amp;lt;&amp;gt; is declared with the attribute [[nodiscard]], which means the compiler will warn you if you forget to inspect the returned object (in C++ 17 or later).</description>
    </item>
    
    <item>
      <title>Major differences</title>
      <link>https://ned14.github.io/outcome/experimental/differences/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/experimental/differences/</guid>
      <description>The major design differences between &amp;lt;system_error&amp;gt; and proposed &amp;lt;system_error2&amp;gt; are as follows:
 experimental::status_code&amp;lt;DomainType&amp;gt; can represent warnings and form-of-success codes as well as failure codes. experimental::errored_status_code&amp;lt;DomainType&amp;gt; is more similar to std::error_code, in that it can only represent failures (this is enforced by C++ 20 contract or runtime assertion check).
 The code&amp;rsquo;s domain implementation defines the payload type to be transported around by experimental::status_code&amp;lt;DomainType&amp;gt;, rather than it being hardcoded to int as in std::error_code.</description>
    </item>
    
    <item>
      <title>The File I/O library</title>
      <link>https://ned14.github.io/outcome/tutorial/advanced/interop/filelib/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/tutorial/advanced/interop/filelib/</guid>
      <description>The File I/O library we shall be using is very similar to the one we saw earlier in this tutorial:
// You may remember this from the tutorial section on Custom Payloads namespace filelib { // Error code + paths related to a failure. Also causes ADL discovery  // to check this namespace.  struct failure_info { std::error_code ec; path path1{}, path2{}; }; // Tell Outcome that failure_info is to be treated as a std::error_code  inline const std::error_code &amp;amp;make_error_code(const failure_info &amp;amp;fi) { return fi.</description>
    </item>
    
    <item>
      <title>The payload</title>
      <link>https://ned14.github.io/outcome/experimental/worked-example-long/value_type/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/experimental/worked-example-long/value_type/</guid>
      <description>We define the code domain&amp;rsquo;s value_type &amp;ndash; the payload to be transported by status codes using this code domain &amp;ndash; to be a POSIX errno value, an integer line number and a const char pointer.
public: // This is the value type for `file_io_error`. We add line number and source file path.  struct value_type { typename outcome_e::posix_code::value_type errcode; // from POSIX, as we inherit from _posix_code_domain  // Our additional payload  int lineno; // from __LINE__  const char *file; // from __FILE__  // Could also place a backtrace of void *[16] here .</description>
    </item>
    
    <item>
      <title>Upgrade guide v2.1 =&gt; v2.2</title>
      <link>https://ned14.github.io/outcome/changelog/upgrade_v21_v22/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/changelog/upgrade_v21_v22/</guid>
      <description>In the start of 2020, after a year of listening to user feedback since entering Boost, Outcome v2.2 was published with a number of breaking source changes from Outcome v2.1 The full year of 2020 (three Boost releases) was given to announcing those upcoming changes, and testing the v2.2 branch in production. In late December 2020, Outcome v2.2 became the default Outcome, and all Outcome v2.1 code shall need to be upgraded to work with v2.</description>
    </item>
    
    <item>
      <title>Upgrading the Filesystem TS</title>
      <link>https://ned14.github.io/outcome/tutorial/advanced/payload/copy_file2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/tutorial/advanced/payload/copy_file2/</guid>
      <description>An Outcome based solution to the dual overload problem is straightforward:
namespace filesystem2 { // Error code + paths related to a failure. Also causes ADL discovery to check this namespace.  struct failure_info { std::error_code ec; path path1, path2; }; // Tell Outcome that failure_info is to be treated as a std::error_code  inline const std::error_code &amp;amp;make_error_code(const failure_info &amp;amp;fi) { return fi.ec; } // Localise an outcome implementation specific to this namespace.</description>
    </item>
    
    <item>
      <title>errno</title>
      <link>https://ned14.github.io/outcome/motivation/errno/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/motivation/errno/</guid>
      <description>The idiom of returning, upon failure, a special value and storing an error code (an int) inside a global (or thread-local) object errno is inherited from C, and used in its Standard Library:
int readValue(const char * filename) { FILE* f = fopen(filename, &amp;#34;r&amp;#34;); if (f == NULL) return 0; // special value indicating failure  // keep errno value set by fopen()  int i; int r = fscanf(f, &amp;#34;%d&amp;#34;, &amp;amp;i); if (r == 0 || r == EOF) { // special values: i not read  errno = ENODATA; // choose error value to return  return 0; fclose(f); errno = 0; // clear error info (success)  return i; }  One advantage (to some, and a disadvantage to others) of this technique is that it uses familiar control statements (if and return) to indicate all execution paths that handle failures.</description>
    </item>
    
    <item>
      <title>std error codes</title>
      <link>https://ned14.github.io/outcome/alternatives/error_code/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/alternatives/error_code/</guid>
      <description>std::error_code came originally from boost::error_code which was designed around 2008 as part of implementing Filesystem and Networking. They are a simple trivially copyable type offering improved type safety and functionality over C enumerations. You can read more about how std::error_code works here. They were standardised in the C++ 11 standard, and have been available in Boost since 2008.
Pros:  Predictable runtime overhead on the happy path.
 Predictable runtime overhead on the sad path.</description>
    </item>
    
    <item>
      <title>The Application</title>
      <link>https://ned14.github.io/outcome/tutorial/advanced/interop/app/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/tutorial/advanced/interop/app/</guid>
      <description>The application is of course also based on Outcome, and like the HTTP library is also of mixed-failure design in that failure can be returned via error code, type erased exception_ptr or indeed a C++ exception throw.
// This is the namespace of the application which is connecting together the httplib, // filelib and tidylib libraries into a solution. namespace app { // Create an ADL bridge so copy/move hooks will be searched for in this namespace  struct error_code : public std::error_code { // passthrough  using std::error_code::error_code; error_code() = default; error_code(std::error_code ec) : std::error_code(ec) { } }; // Localise an outcome implementation for this namespace  template &amp;lt;classT&amp;gt; using outcome = //  OUTCOME_V2_NAMESPACE::outcome&amp;lt;T, error_code /*, std::exception_ptr */&amp;gt;; using OUTCOME_V2_NAMESPACE::success; } // namespace app View this code on Github Here we localise a passthrough error_code solely for the purpose of ADL bridging, otherwise the localised outcome configured is the default one which comes with Outcome.</description>
    </item>
    
    <item>
      <title>Auto-throwing filesystem_error</title>
      <link>https://ned14.github.io/outcome/tutorial/advanced/payload/copy_file3/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/tutorial/advanced/payload/copy_file3/</guid>
      <description>Something not mentioned at all until now (and properly described in the next section, Default actions) is that Outcome can be programmed take various actions when the user tries to observe .value() when there is no value, and so on for the other possible state observations.
Seeing as we are replacing the throwing overload of copy_file() in the Filesystem TS with a result returning edition instead, it would make sense if an attempt to observe the value of an unsuccessful fs_result threw the exact same filesystem_error as the Filesystem TS does.</description>
    </item>
    
    <item>
      <title>Calling it from C</title>
      <link>https://ned14.github.io/outcome/experimental/c-api/from-cxx/example2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/experimental/c-api/from-cxx/example2/</guid>
      <description>Firstly we need to declare to C our result returning C++ function:
// Declare our C++ function&amp;#39;s returning result type. Only needs to be done once. // This declares an `status_result&amp;lt;size_t, system_code&amp;gt;` which is an alias to // `basic_result&amp;lt;size_t, status_code&amp;lt;erased&amp;lt;intptr_t&amp;gt;&amp;gt;&amp;gt;`. // // The first parameter is some unique identifier for this type which will be used // whenever we reference this type in the future. CXX_DECLARE_RESULT_SYSTEM(to_string_rettype, size_t) // Tell C about our extern C++ function `to_string()` extern CXX_RESULT_SYSTEM(to_string_rettype) _Z9to_stringPcmi(char *buffer, size_t bufferlen, int v); View this code on Github Now let&amp;rsquo;s call the C++ function from C:</description>
    </item>
    
    <item>
      <title>Error codes</title>
      <link>https://ned14.github.io/outcome/motivation/error_codes/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/motivation/error_codes/</guid>
      <description>Error codes are reasonable error handling technique, also working in C. In this case the information is also stored as an int, but returned by value, which makes it possible to make functions pure (side-effect-free and referentially transparent).
int readInt(const char * filename, int&amp;amp; val) { FILE* fd; int r = openFile(filename, /*out*/ fd); if (r != 0) return r; // return whatever error openFile() returned  r = readInt(fd, /*out*/ val); if (r !</description>
    </item>
    
    <item>
      <title>Hook result</title>
      <link>https://ned14.github.io/outcome/tutorial/advanced/hooks/hook_result/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/tutorial/advanced/hooks/hook_result/</guid>
      <description>We now tell Outcome that for every instance of our localised result&amp;lt;T&amp;gt;, that on failure construction only, we want custom code to be run which increments the current slot in TLS storage and writes the current stack backtrace into it.
For Outcome before v2.2, we must do this by inserting a specially named free function into a namespace searched by ADL:
namespace error_code_extended { // Specialise the result construction hook for our localised result  // We hook any non-copy, non-move, non-inplace construction, capturing a stack backtrace  // if the result is errored.</description>
    </item>
    
    <item>
      <title>Inspecting outcome&lt;T, EC, EP&gt;</title>
      <link>https://ned14.github.io/outcome/tutorial/essential/outcome/inspecting/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/tutorial/essential/outcome/inspecting/</guid>
      <description>Continuing with the previous example, in Layer3 we have function z which again reports failures via exceptions. It will call function h from Layer2_old which returns outcome&amp;lt;int&amp;gt; (which may store an int or a std::error_code or a std::exception_ptr). The goal is to unpack it to either the successful return value int or to throw an appropriate exception: if we are storing an std::exception_ptr, just rethrow it. If we are storing a std::error_code throw it as std::system_error, which is designed to store std::error_code&amp;rsquo;s:</description>
    </item>
    
    <item>
      <title>Mapping the HTTP library into the Application `1/2`</title>
      <link>https://ned14.github.io/outcome/tutorial/advanced/interop/app-map-httplib1/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/tutorial/advanced/interop/app-map-httplib1/</guid>
      <description>Firstly, remember that we are the application writer who has the problem of integrating three third party libraries into our application&amp;rsquo;s Outcome-based failure handling mechanism. We cannot modify those third party library sources; we must be non-intrusive.
We start by dealing with the HTTP library. We will integrate this into our application by wrapping up httplib::failure into a custom STL exception type. We then type erase it into an exception_ptr instance.</description>
    </item>
    
    <item>
      <title>Phase 2 construction</title>
      <link>https://ned14.github.io/outcome/tutorial/advanced/constructors/static-constructor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/tutorial/advanced/constructors/static-constructor/</guid>
      <description>Its phase 2 constructor:
// Phase 2 static member constructor function, which cannot throw inline outcome::result&amp;lt;file_handle&amp;gt; file_handle::file(file_handle::path_type path, file_handle::mode mode) noexcept { // Perform phase 1 of object construction  file_handle ret; // Perform phase 2 of object construction  int flags = 0; switch(mode) { case mode::attr_read: case mode::read: flags = O_RDONLY; break; case mode::attr_write: case mode::write: flags = O_RDWR; break; case mode::append: flags = O_APPEND; break; default: return std::errc::invalid_argument; } ret.</description>
    </item>
    
    <item>
      <title>Returning Outcome types from Coroutines</title>
      <link>https://ned14.github.io/outcome/tutorial/essential/coroutines/returning/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/tutorial/essential/coroutines/returning/</guid>
      <description>eager&amp;lt;T, Executor = void&amp;gt; and lazy&amp;lt;T, Executor = void&amp;gt; and their atomic editions are completely standard awaitables with no special behaviours, except if T is a basic_result or basic_outcome. In that situation, the following occurs:
If the Coroutine throws a C++ exception which was not handled inside the Coroutine body, Outcome&amp;rsquo;s awaitable types try to convert it into a form which your Result or Outcome type being returned can transport. For example:</description>
    </item>
    
    <item>
      <title>TRY operations</title>
      <link>https://ned14.github.io/outcome/tutorial/essential/result/try/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/tutorial/essential/result/try/</guid>
      <description>In the implementation of function print_half we have seen the usage of the macro OUTCOME_TRYV(expr)/OUTCOME_TRY(expr) :
OUTCOME_TRY (auto i, BigInt::fromString(text));  The OUTCOME_TRY macro uses C macro overloading to select between two implementations based on the number of input parameters. If there is exactly one input parameter i.e. without the i, the control statement is roughly equivalent to:
auto __result = BigInt::fromString(text); if (!__result) return __result.as_failure();  Where __result is a compile time generated unique name.</description>
    </item>
    
    <item>
      <title>The constructor</title>
      <link>https://ned14.github.io/outcome/experimental/worked-example-long/constructor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/experimental/worked-example-long/constructor/</guid>
      <description>Code domains are 100% constexpr to construct and destruct, as are status codes. This enables the compiler to 100% instantiate both only in its mind, and to emit zero code and thus zero overhead.
Unfortunately it also means that it must be possible for each domain to be instantiated an infinite number of times, and being 100% in constexpr, any instances never have a unique address in memory either. Thus we cannot compare domains for equivalence using their address in memory, as  std::error_category does.</description>
    </item>
    
    <item>
      <title>Using a Result</title>
      <link>https://ned14.github.io/outcome/experimental/c-api/from-c/use/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/experimental/c-api/from-c/use/</guid>
      <description>This models the earlier C++ example of use, and its C equivalent isn&amp;rsquo;t much more verbose thanks to our helper typedefs and macros:
result positive_only(int x) { if(x &amp;lt; 0) { return FAILURE(c_enum_bad_argument); } return SUCCESS(x); } bool test(int x) { result r = positive_only(x); if(CXX_RESULT_HAS_ERROR(r)) { if(outcome_status_code_equal_generic(&amp;amp;r.error, EINVAL)) { fprintf(stderr, &amp;#34;Positive numbers only!\n&amp;#34;); return false; } } return true; } View this code on Github For this to link, the CXX_DECLARE_RESULT_SYSTEM_FROM_ENUM macro needs to be compiled at least once within C++ within the final binary to emit the extern functions needed by C.</description>
    </item>
    
    <item>
      <title>std expected</title>
      <link>https://ned14.github.io/outcome/alternatives/expected/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/alternatives/expected/</guid>
      <description>std::expected&amp;lt;T, E&amp;gt; came originally from an experimental monadic and generic programming library outside of Boost written by Boost and WG21 developers around 2013. Before Outcome v1, I deployed the then Expected into a large codebase and I was dismayed with the results, especially on build times. You can read here how those experiences led me to develop Outcome v1.
std::expected&amp;lt;T, E&amp;gt; is a constrained variant type with a strong preference for the successful type T which it models like a std::optional&amp;lt;T&amp;gt;.</description>
    </item>
    
    <item>
      <title>v2.2 major changes</title>
      <link>https://ned14.github.io/outcome/changelog/v22/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/changelog/v22/</guid>
      <description>Major changes in v2.2 over v2.1 are listed here.
 A new trait is_move_bitcopying&amp;lt;T&amp;gt; is added, which opts types into a library-based emulation of P1029 move = bitcopies. Experimental std::error is opted in by default. If this trait is true for your T or E type, Outcome will track moved-from status for your type, and will only call your type&amp;rsquo;s destructor if it was not moved from. If your compiler&amp;rsquo;s optimiser is sufficiently able to fold code, this improves codegen quality for Experimental Outcome very considerably, approaching the same gains as P1029 types would have.</description>
    </item>
    
    <item>
      <title>Mapping the HTTP library into the Application `2/2`</title>
      <link>https://ned14.github.io/outcome/tutorial/advanced/interop/app-map-httplib2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/tutorial/advanced/interop/app-map-httplib2/</guid>
      <description>If you remember the tutorial section on the value_or_error Concept, this is an example of how to implement a custom value_or_error Concept converter in Outcome:
// Inject custom ValueOrError conversion OUTCOME_V2_NAMESPACE_BEGIN namespace convert { // Provide custom ValueOrError conversion from  // httplib::result&amp;lt;U&amp;gt; into any app::outcome&amp;lt;T&amp;gt;  template &amp;lt;classT, classU&amp;gt; //  struct value_or_error&amp;lt;app::outcome&amp;lt;T&amp;gt;, httplib::result&amp;lt;U&amp;gt;&amp;gt; { // False to indicate that this converter wants `result`/`outcome`  // to NOT reject all other `result`  static constexpr bool enable_result_inputs = true; // False to indicate that this converter wants `outcome` to NOT  // reject all other `outcome`  static constexpr bool enable_outcome_inputs = true; template &amp;lt;classX, //  typename = std::enable_if_t&amp;lt;std::is_same&amp;lt;httplib::result&amp;lt;U&amp;gt;, std::decay_t&amp;lt;X&amp;gt;&amp;gt;::value //  &amp;amp;&amp;amp; std::is_constructible&amp;lt;T, U&amp;gt;::value&amp;gt;&amp;gt; //  constexpr app::outcome&amp;lt;T&amp;gt; operator()(X &amp;amp;&amp;amp;src) { // Forward any successful value, else synthesise an exception ptr  return src.</description>
    </item>
    
    <item>
      <title>Custom exception ptr</title>
      <link>https://ned14.github.io/outcome/tutorial/advanced/hooks/poke_exception/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/tutorial/advanced/hooks/poke_exception/</guid>
      <description>If you merely want result to capture stack backtraces without calling a memory allocator and retaining any triviality of copy which is important for optimisation, you already have everything you need.
But let&amp;rsquo;s keep going by intercepting any construction of our localised outcome from our localised result, retrieving any stored backtrace and using it to synthesise an exception ptr with a message text including the backtrace. Firstly let us look at the function which synthesises the exception ptr:</description>
    </item>
    
    <item>
      <title>Mapping the File I/O library into the Application</title>
      <link>https://ned14.github.io/outcome/tutorial/advanced/interop/app-map-filelib/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/tutorial/advanced/interop/app-map-filelib/</guid>
      <description>To handle the File I/O library, once again we turn to custom ValueOrError converters:
// Inject custom ValueOrError conversion OUTCOME_V2_NAMESPACE_BEGIN namespace convert { // Provide custom ValueOrError conversion from filelib::result&amp;lt;U&amp;gt;  // into any app::outcome&amp;lt;T&amp;gt;  template &amp;lt;classT, classU&amp;gt; //  struct value_or_error&amp;lt;app::outcome&amp;lt;T&amp;gt;, filelib::result&amp;lt;U&amp;gt;&amp;gt; { // True to indicate that this converter wants `result`/`outcome`  // to NOT reject all other `result`  static constexpr bool enable_result_inputs = true; // False to indicate that this converter wants `outcome` to NOT  // reject all other `outcome`  static constexpr bool enable_outcome_inputs = true; template &amp;lt;classX, //  typename = std::enable_if_t&amp;lt;std::is_same&amp;lt;filelib::result&amp;lt;U&amp;gt;, std::decay_t&amp;lt;X&amp;gt;&amp;gt;::value //  &amp;amp;&amp;amp; std::is_constructible&amp;lt;T, U&amp;gt;::value&amp;gt;&amp;gt; //  constexpr app::outcome&amp;lt;T&amp;gt; operator()(X &amp;amp;&amp;amp;src) { // Forward any successful value  if(src.</description>
    </item>
    
    <item>
      <title>Outcome (proposed std result)</title>
      <link>https://ned14.github.io/outcome/alternatives/outcome/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/alternatives/outcome/</guid>
      <description>Outcome (the library described by this documentation) originated in a negative reaction to then originally proposed std::expected&amp;lt;T, E&amp;gt;, though what got eventually standardised as std::expected&amp;lt;T, E&amp;gt; looks much more like Outcome&amp;rsquo;s result&amp;lt;T, E&amp;gt; than the original Expected. You can read here how those experiences led me to develop Outcome v1. Outcome comes in both standalone and Boost editions, and its current design was completed in 2018.
Outcome&amp;rsquo;s core is two workhorse types and a macro:</description>
    </item>
    
    <item>
      <title>Phase 3</title>
      <link>https://ned14.github.io/outcome/tutorial/advanced/constructors/metaprogrammg1/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/tutorial/advanced/constructors/metaprogrammg1/</guid>
      <description>We have built our first two phases of construction for file_handle, and for some users they might be happy writing:
outcome::result&amp;lt;file_handle&amp;gt; fh1 = file_handle::file(&amp;#34;hello&amp;#34; /*, file_handle::mode::read */); if(!fh1) { std::cerr &amp;lt;&amp;lt; &amp;#34;Opening file &amp;#39;hello&amp;#39; failed with &amp;#34; &amp;lt;&amp;lt; fh1.error().message() &amp;lt;&amp;lt; std::endl; } View this code on Github &amp;hellip; and be done with it.
But wouldn&amp;rsquo;t it be nicer if we could instead write:
outcome::result&amp;lt;file_handle&amp;gt; fh2 = make&amp;lt;file_handle&amp;gt;{&amp;#34;hello&amp;#34; /*, file_handle::mode::read */}(); if(!</description>
    </item>
    
    <item>
      <title>String refs</title>
      <link>https://ned14.github.io/outcome/experimental/worked-example-long/string_ref/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/experimental/worked-example-long/string_ref/</guid>
      <description>&amp;lt;system_error2&amp;gt; does not use std::string to return possibly statically or dynamically allocated strings, and thus avoids dragging in a lot of the standard library which impacts build times.
Instead status code domains have a string_ref, which has a polymorphic implementation which may or may not manage a dynamic memory allocation using an atomic reference counter. Due to this polymorphism, you don&amp;rsquo;t need to worry which implementation is actually in use under the bonnet when you pass around string_ref instances.</description>
    </item>
    
    <item>
      <title>TRY a C Result</title>
      <link>https://ned14.github.io/outcome/experimental/c-api/from-c/try/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/experimental/c-api/from-c/try/</guid>
      <description>Thanks to much of the magic of OUTCOME_TRY(var, expr) being implemented using C preprocessor metaprogramming, we can offer a very similar experience for the C try operation and without needing anything compiled in C++ as support functions:
result test2(int x) { CXX_RESULT_SYSTEM_TRY(int v, // what to set to value if successful  fprintf(stderr, &amp;#34;Positive numbers only!\n&amp;#34;), // what cleanup to run if unsuccessful  positive_only(x)); return SUCCESS(v + 1); } View this code on Github The principle difference is that you can specify a cleanup routine to perform if failure is encountered.</description>
    </item>
    
    <item>
      <title>TRY is greedy</title>
      <link>https://ned14.github.io/outcome/tutorial/essential/result/try_greedy/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/tutorial/essential/result/try_greedy/</guid>
      <description>OUTCOME_TRYV(expr)/OUTCOME_TRY(expr) has &amp;lsquo;greedier&amp;rsquo; implicit conversion semantics than basic_result&amp;lt;T, E, NoValuePolicy&amp;gt; . For example, this code won&amp;rsquo;t compile:
outcome::result&amp;lt;int, std::error_code&amp;gt; test(outcome::result&amp;lt;int, std::errc&amp;gt; r) { return r; // you need to use explicit construction here  // i.e. return outcome::result&amp;lt;int&amp;gt;(r); }  This is chosen because there is a non-trivial conversion between std::errc and std::error_code, so even though that conversion is implicit for std::error_code, Outcome does not expose the implicitness here in order to keep the implicit constructor count low (implicit constructors add significantly to build times).</description>
    </item>
    
    <item>
      <title>`operator co_await` as TRY operator</title>
      <link>https://ned14.github.io/outcome/tutorial/essential/coroutines/co_await/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/tutorial/essential/coroutines/co_await/</guid>
      <description>Many people have requested that operator co_await be overloaded to behave as a TRY operator when supplied with an Outcome type.
Outcome does not implement that extension, nor will we accept PRs contributing support for this. We think you should use OUTCOME_CO_TRY() as this will lead to more maintainable and future proof code.
However, we deliberately do not get in the way of you implementing that overload yourself in your own Outcome-based code.</description>
    </item>
    
    <item>
      <title>`status_result` and `status_outcome`</title>
      <link>https://ned14.github.io/outcome/experimental/status_result/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/experimental/status_result/</guid>
      <description>status_result and status_outcome are type aliases to basic_result&amp;lt;T, E, NoValuePolicy&amp;gt; and basic_outcome&amp;lt;T, EC, EP, NoValuePolicy&amp;gt; in the usual way, but with a defaulted NoValuePolicy which selects on the basis of status_code&amp;lt;DomainType&amp;gt; instead.
If the E type is not some status_code&amp;lt;&amp;gt;, the default policy selector will complain.
 The specifications are:
experimental::status_result&amp;lt;T, E = experimental::error&amp;gt; experimental::status_outcome&amp;lt;T, E = experimental::error, EP = std::exception_ptr&amp;gt;  So, the default E is the erased errored status code system_code, which can represent any generic_code, posix_code, win32_code, nt_code, com_code and many other integer error and status codings.</description>
    </item>
    
    <item>
      <title>std::error_code</title>
      <link>https://ned14.github.io/outcome/motivation/std_error_code/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/motivation/std_error_code/</guid>
      <description>Type std::error_code has been designed to be sufficiently small and trivial to be cheaply passed around, and at the same time be able to store sufficient information to represent any error situation from any library/sub-system in the world without a clash. Its representation is basically:
classerror_code { error_category* domain; // domain from which the error originates  int value; // numeric value of error within the domain };  Here, domain indicates the library from which the error originates.</description>
    </item>
    
    <item>
      <title>Mapping the HTMLTidy library into the Application</title>
      <link>https://ned14.github.io/outcome/tutorial/advanced/interop/app-map-tidylib/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/tutorial/advanced/interop/app-map-tidylib/</guid>
      <description>Once again, we create a custom STL exception type to represent failure from the HTMLTidy library. We also create an app namespace wrapper for the C tidy_html() function which is more C++ friendly.
namespace app { // Specialise an exception type for tidylib errors  struct tidylib_error : std::system_error { // passthrough  using std::system_error::system_error; tidylib_error() = default; explicit tidylib_error(int c) : std::system_error(c, std::generic_category()) { } }; // Create a C++ invoking wrapper for the tidylib C API, modifying data with the returned data,  // returing a unique_ptr to release storage on scope exit.</description>
    </item>
    
    <item>
      <title>Hook outcome</title>
      <link>https://ned14.github.io/outcome/tutorial/advanced/hooks/hook_outcome/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/tutorial/advanced/hooks/hook_outcome/</guid>
      <description>The final step is to add event hooks for the very specific case of when our localised outcome is copy or move constructed from our localised result.
You ought to be very careful that the noexcept-ness of these matches the noexcept-ness of the types in the outcome. You may have noticed that poke_exception() creates a std::string and appends to it. This can throw an exception. If the copy and/or move constructors of T, EC and EP are noexcept, then so will be outcome&amp;rsquo;s copy and/or move constructor.</description>
    </item>
    
    <item>
      <title>In use</title>
      <link>https://ned14.github.io/outcome/tutorial/advanced/interop/app-go/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/tutorial/advanced/interop/app-go/</guid>
      <description>This is how you might now write application code using these three libraries:
namespace app { // A markup function to indicate when we are ValueOrError converting  template &amp;lt;classT&amp;gt; inline outcome&amp;lt;typename T::value_type&amp;gt; ext(T &amp;amp;&amp;amp;v) { //  return outcome&amp;lt;typename T::value_type&amp;gt;(std::move(v)); } outcome&amp;lt;void&amp;gt; go() // NOT noexcept, this can throw STL exceptions e.g. bad_alloc  { // Note that explicit construction is required when converting between differing types  // of outcome and result.</description>
    </item>
    
    <item>
      <title>LEAF</title>
      <link>https://ned14.github.io/outcome/alternatives/leaf/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/alternatives/leaf/</guid>
      <description>As much as Outcome originated in a negative reaction to the then originally proposed std::expected&amp;lt;T, E&amp;gt;, LEAF originated in a negative reaction to Outcome. Some of the perceived issues with Outcome were (LEAF&amp;rsquo;s own rendition of this can be viewed here):
 Outcome based code is visually cluttered, as both happy and sad paths appear in code.
 Outcome based code generates branchy code at runtime, which impacts low end CPUs and first time code execution.</description>
    </item>
    
    <item>
      <title>Plugging a library into `std::error_code`</title>
      <link>https://ned14.github.io/outcome/motivation/plug_error_code/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/motivation/plug_error_code/</guid>
      <description>See here for this guide, but for boost::system::error_code.
This section illustrates how you can hook into the std::error_code system from the Standard Library in order to work with your own set of error codes. As is usually the case in C++, doing this is straightforward but requires typing boilerplate to tell the C++ STL about your custom error type. This is not part of Outcome library, but we still provide this short guide here, because how to do this is not well documented [1].</description>
    </item>
    
    <item>
      <title>Redefining `message()`</title>
      <link>https://ned14.github.io/outcome/experimental/worked-example-long/message/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/experimental/worked-example-long/message/</guid>
      <description>You may remember that our custom _file_io_error_domain inherits from outcome_e::posix_code::domain_type, and thus does not have to implement the many pure virtual functions required by outcome_e::status_code_domain.
What we do need to do is reimplement _do_message() to append the file and line information to the POSIX error description string returned by outcome_e::posix_code::domain_type. This causes the status code&amp;rsquo;s .message() observer to return a string with the extra payload information represented in text.
// Return a string describing a specific code.</description>
    </item>
    
    <item>
      <title>TRY avoiding copy/move</title>
      <link>https://ned14.github.io/outcome/tutorial/essential/result/try_ref/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/tutorial/essential/result/try_ref/</guid>
      <description>OUTCOME_TRYV(expr)/OUTCOME_TRY(expr) works by creating an internal uniquely named variable which holds the value emitted by the expression. This implies that a copy or move operation shall be performed on the object emitted (unless you are on C++ 17 or later, which has guaranteed copy elision), which may be undesirable for your use case.
You can tell OUTCOME_TRY to use a reference rather than a value for the internal uniquely named variable like this:</description>
    </item>
    
    <item>
      <title>construct&lt;T&gt;</title>
      <link>https://ned14.github.io/outcome/tutorial/advanced/constructors/metaprogrammg2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/tutorial/advanced/constructors/metaprogrammg2/</guid>
      <description>First, we need a base definition for make&amp;lt;T&amp;gt;:
template &amp;lt;classT&amp;gt; struct make { outcome::result&amp;lt;T&amp;gt; operator()() const noexcept { //  static_assert(!std::is_same&amp;lt;T, T&amp;gt;::value, //  &amp;#34;make&amp;lt;T&amp;gt;() was not specialised for the type T supplied&amp;#34;); } }; View this code on Github This fails a static assert if the type is ever instantiated unspecialised.
We then specialise for make&amp;lt;file_handle&amp;gt;:
template &amp;lt;&amp;gt; struct make&amp;lt;file_handle&amp;gt; { file_handle::path_type _path; file_handle::mode _mode{file_handle::mode::read}; // Any other args, default initialised if necessary, follow here .</description>
    </item>
    
    <item>
      <title>Conclusion</title>
      <link>https://ned14.github.io/outcome/tutorial/advanced/interop/conclusion/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/tutorial/advanced/interop/conclusion/</guid>
      <description>This worked example was in fact excessively complex: a quicker route to achieving the same thing would be to add explicit converting constructors to app::error_code for each of the third party library E types. One then could have saved oneself with having to bother injecting custom converters into the OUTCOME_V2_NAMESPACE::convert namespace. If you control your application&amp;rsquo;s E type, then that is probably a better, and certainly simpler, approach.
However there are occasions when you don&amp;rsquo;t have control over the implementation of the destination E type e.</description>
    </item>
    
    <item>
      <title>Plugging a library into `boost::system::error_code`</title>
      <link>https://ned14.github.io/outcome/motivation/plug_error_code2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/motivation/plug_error_code2/</guid>
      <description>See here for this guide, but for std::error_code.
This section illustrates how you can hook into the boost::system::error_code system from the Boost in order to work with your own set of error codes. As is usually the case in C++, doing this is straightforward but requires typing boilerplate to tell Boost.System about your custom error type. This is not part of Outcome library, but we still provide this short guide here, because how to do this is not well documented [1].</description>
    </item>
    
    <item>
      <title>Alternatives</title>
      <link>https://ned14.github.io/outcome/tutorial/advanced/constructors/metaprogrammg3/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/tutorial/advanced/constructors/metaprogrammg3/</guid>
      <description>No doubt many will dislike the two-stage invocation pattern i.e.
make&amp;lt;file_handle&amp;gt;{&amp;#34;hello&amp;#34;}();  So let us examine the most obvious alternative: a templated free function make&amp;lt;T&amp;gt;.
Due to the inability to partially specialise templated functions in C++, you need to use tagged overloading e.g.
template&amp;lt;class... Args&amp;gt; inline outcome::result&amp;lt;file_handle&amp;gt; make(std::in_place_type_t&amp;lt;file_handle&amp;gt;, Args&amp;amp;&amp;amp; ... args) { return file_handle::file(std::forward&amp;lt;Args&amp;gt;(args)...); } ... // Now you must always write this: make(std::in_place_type&amp;lt;file_handle&amp;gt;, &amp;#34;hello&amp;#34;);  Tagged overloading is fine for smaller projects, but for larger code bases:</description>
    </item>
    
    <item>
      <title>Constexpr domain source</title>
      <link>https://ned14.github.io/outcome/experimental/worked-example-long/source/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/experimental/worked-example-long/source/</guid>
      <description>Back in The constructor, we declared but did not implement a .get() function which returns a constexpr static instance of the domain. We implement this now:
// 100% constexpr instantiation constexpr _file_io_error_domain file_io_error_domain; inline constexpr const _file_io_error_domain &amp;amp;_file_io_error_domain::get() { return file_io_error_domain; } View this code on Github As this is 100% constexpr, it can be (and is under optimisation) implemented entirely in the mind of the compiler with no run time representation.</description>
    </item>
    
    <item>
      <title>Narrow contracts</title>
      <link>https://ned14.github.io/outcome/motivation/narrow_contract/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/motivation/narrow_contract/</guid>
      <description>A program&amp;rsquo;s thread of execution can enter a &amp;ldquo;disappointing&amp;rdquo; state for two reasons:
 due to disappointing situation in the environment (operating system, external input), or due to a bug in the program.  The key to handling these disappointments correctly is to identify to which category they belong, and use the tools adequate for a given category. In this tutorial when we say &amp;ldquo;error&amp;rdquo; or &amp;ldquo;failure&amp;rdquo; we only refer to the first category.</description>
    </item>
    
    <item>
      <title>Implicit conversion</title>
      <link>https://ned14.github.io/outcome/experimental/worked-example-long/implicit_conversion/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/experimental/worked-example-long/implicit_conversion/</guid>
      <description>Back in The payload, we mentioned that there was no default implicit conversion of file_io_error (status_code&amp;lt;_file_io_error_domain&amp;gt;) to error, as error is too small to hold _file_io_error_domain::value_type.
We can tell the framework about available implicit conversions by defining an ADL discovered free function make_status_code() which takes our custom status code as input, and returns an error:
// Now tell `error` how it can implicitly construct from `file_io_error`. // This is done by us defining a free function called `make_status_code()` // which is discovered using ADL.</description>
    </item>
    
    <item>
      <title>Tying it all together</title>
      <link>https://ned14.github.io/outcome/experimental/outcome/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/experimental/outcome/</guid>
      <description>Firstly let&amp;rsquo;s alias a more convenient form of status_result:
template &amp;lt;classT, classE = outcome_e::error&amp;gt; using result = // outcome_e::status_result&amp;lt;T, E, outcome_e::policy::default_status_result_policy&amp;lt;T, E&amp;gt;&amp;gt;; View this code on Github (The defaulting of default_result_policy is superfluous, it&amp;rsquo;s already the default)
What follows now is very standard Outcome code. Indeed, it would compile just fine under standard Outcome with only a few typedefs.
result&amp;lt;file_handle, file_io_error&amp;gt; open_file(const char *path) // models throws(file_io_error) { file_handle ret(::fopen(path, &amp;#34;r&amp;#34;)); if(ret) return ret; return file_io_error({errno, __LINE__, __FILE__}); } result&amp;lt;void&amp;gt; open_resource() // models throws(std::error) { for(;;) { result&amp;lt;file_handle, file_io_error&amp;gt; r = open_file(&amp;#34;some file&amp;#34;); if(r) break; file_io_error e = r.</description>
    </item>
    
    <item>
      <title>`basic_outcome() = delete`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_outcome/default/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_outcome/default/</guid>
      <description>The default constructor for basic outcome is always disabled.</description>
    </item>
    
    <item>
      <title>`basic_result() = delete`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_result/default/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_result/default/</guid>
      <description>The default constructor for basic result is always disabled.</description>
    </item>
    
    <item>
      <title>`static void _ub(Impl &amp;&amp;)`</title>
      <link>https://ned14.github.io/outcome/reference/policies/base/ub/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/policies/base/ub/</guid>
      <description>This is a special function which does compiler-specific stuff to tell the compiler that this function can never, ever, ever be executed. The compiler&amp;rsquo;s optimiser will hard assume that this function can never be executed, and will prune the possibility of it being executed completely. Generally this means that the code path stops dead, and if execution does proceed down this path, it will run off the end of a branch which doesn&amp;rsquo;t go anywhere.</description>
    </item>
    
    <item>
      <title>`basic_outcome(basic_outcome &amp;&amp;)`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_outcome/move_constructor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_outcome/move_constructor/</guid>
      <description>Move constructor.
Requires: that value_type, error_type and exception_type all implement a move constructor.
Complexity: Same as for value_type&amp;rsquo;s, error_type&amp;rsquo;s and exception_type&amp;rsquo;s move constructors. Constexpr, triviality and noexcept of underlying operations is propagated.
Guarantees: If an exception is thrown during the operation, the object is left in a partially completed state, as per the normal rules for the same operation on a struct.</description>
    </item>
    
    <item>
      <title>`basic_result(basic_result &amp;&amp;)`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_result/move_constructor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_result/move_constructor/</guid>
      <description>Move constructor.
Requires: that value_type and error_type both implement a move constructor.
Complexity: Same as for value_type&amp;rsquo;s and error_type&amp;rsquo;s move constructors. Constexpr, triviality and noexcept of underlying operations is propagated.
Guarantees: If an exception is thrown during the operation, the object is left in a partially completed state, as per the normal rules for the same operation on a struct.</description>
    </item>
    
    <item>
      <title>`basic_outcome(const basic_outcome &amp;)`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_outcome/copy_constructor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_outcome/copy_constructor/</guid>
      <description>Copy constructor.
Requires: that value_type, error_type and exception_type all implement a copy constructor.
Complexity: Same as for value_type&amp;rsquo;s, error_type&amp;rsquo;s and exception_type&amp;rsquo;s copy constructors. Constexpr, triviality and noexcept of underlying operations is propagated.
Guarantees: If an exception is thrown during the operation, the object is left in a partially completed state, as per the normal rules for the same operation on a struct.</description>
    </item>
    
    <item>
      <title>`basic_result(const basic_result &amp;)`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_result/copy_constructor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_result/copy_constructor/</guid>
      <description>Copy constructor.
Requires: that value_type and error_type both implement a copy constructor.
Complexity: Same as for value_type&amp;rsquo;s and error_type&amp;rsquo;s copy constructors. Constexpr, triviality and noexcept of underlying operations is propagated.
Guarantees: If an exception is thrown during the operation, the object is left in a partially completed state, as per the normal rules for the same operation on a struct.</description>
    </item>
    
    <item>
      <title>`basic_outcome &amp;operator=(basic_outcome &amp;&amp;)`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_outcome/move_assignment/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_outcome/move_assignment/</guid>
      <description>Move assignment.
Requires: that value_type, error_type and exception_type all implement move assignment.
Complexity: If the value_type for both is present, uses value_type&amp;rsquo;s move assignment operator, else either destructs or move constructs value_type as appropriate. error_type&amp;rsquo;s and exception_type&amp;rsquo;s move assignment operator are always used. Constexpr, triviality and noexcept of underlying operations is propagated.
Guarantees: If an exception is thrown during the operation, the object is left in a partially completed state, as per the normal rules for the same operation on a struct.</description>
    </item>
    
    <item>
      <title>`basic_result &amp;operator=(basic_result &amp;&amp;)`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_result/move_assignment/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_result/move_assignment/</guid>
      <description>Move assignment.
Requires: that value_type and error_type both implement move assignment.
Complexity: If the value_type for both is present, uses value_type&amp;rsquo;s move assignment operator, else either destructs or move constructs value_type as appropriate. error_type&amp;rsquo;s move assignment operator is always used. Constexpr, triviality and noexcept of underlying operations is propagated.
Guarantees: If an exception is thrown during the operation, the object is left in a partially completed state, as per the normal rules for the same operation on a struct.</description>
    </item>
    
    <item>
      <title>`basic_outcome &amp;operator=(const basic_outcome &amp;)`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_outcome/copy_assignment/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_outcome/copy_assignment/</guid>
      <description>Copy assignment.
Requires: that value_type, error_type and exception_type all implement copy assignment.
Complexity: If the value_type for both is present, uses value_type&amp;rsquo;s copy assignment operator, else either destructs or copy constructs value_type as appropriate. error_type&amp;rsquo;s and exception_type&amp;rsquo;s copy assignment operator is always used. Constexpr, triviality and noexcept of underlying operations is propagated.
Guarantees: If an exception is thrown during the operation, the object is left in a partially completed state, as per the normal rules for the same operation on a struct.</description>
    </item>
    
    <item>
      <title>`basic_result &amp;operator=(const basic_result &amp;)`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_result/copy_assignment/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_result/copy_assignment/</guid>
      <description>Copy assignment.
Requires: that value_type and error_type both implement copy assignment.
Complexity: If the value_type for both is present, uses value_type&amp;rsquo;s copy assignment operator, else either destructs or copy constructs value_type as appropriate. error_type&amp;rsquo;s copy assignment operator is always used. Constexpr, triviality and noexcept of underlying operations is propagated.
Guarantees: If an exception is thrown during the operation, the object is left in a partially completed state, as per the normal rules for the same operation on a struct.</description>
    </item>
    
    <item>
      <title>`~basic_outcome()`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_outcome/destructor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_outcome/destructor/</guid>
      <description>Destructor.
Requires: Always available.
Complexity: Same as for value_type&amp;rsquo;s, error_type&amp;rsquo;s and exception_type&amp;rsquo;s destructors. Constexpr, triviality and noexcept of underlying operations is propagated.</description>
    </item>
    
    <item>
      <title>`~basic_result()`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_result/destructor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_result/destructor/</guid>
      <description>Destructor.
Requires: Always available.
Complexity: Same as for value_type&amp;rsquo;s and error_type&amp;rsquo;s destructors. Constexpr, triviality and noexcept of underlying operations is propagated.</description>
    </item>
    
    <item>
      <title>`basic_outcome(Args...) = delete`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_outcome/disabling_catchall/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_outcome/disabling_catchall/</guid>
      <description>Disabling catchall constructor used to give useful diagnostic error when trying to use non-inplace constructors when predicate::constructors_enabled is false.
Requires: predicate::constructors_enabled is false.
Complexity: N/A.</description>
    </item>
    
    <item>
      <title>`basic_result(Args...) = delete`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_result/disabling_catchall/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_result/disabling_catchall/</guid>
      <description>Disabling catchall constructor used to give useful diagnostic error when trying to use non-inplace constructors when predicate::constructors_enabled is false.
Requires: predicate::constructors_enabled is false.
Complexity: N/A.</description>
    </item>
    
    <item>
      <title>`basic_outcome(X &amp;&amp;) = delete`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_outcome/disabling_implicit_constructor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_outcome/disabling_implicit_constructor/</guid>
      <description>Disabling implicit constructor used to give useful diagnostic error when trying to use implicit constructors when predicate::implicit_constructors_enabled is false.
Requires: predicate::implicit_constructors_enabled is false.
Complexity: N/A.</description>
    </item>
    
    <item>
      <title>`basic_result(X &amp;&amp;) = delete`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_result/disabling_implicit_constructor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_result/disabling_implicit_constructor/</guid>
      <description>Disabling implicit constructor used to give useful diagnostic error when trying to use implicit constructors when predicate::implicit_constructors_enabled is false.
Requires: predicate::implicit_constructors_enabled is false.
Complexity: N/A.</description>
    </item>
    
    <item>
      <title>`basic_outcome(R &amp;&amp;)`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_outcome/implicit_value_converting_constructor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_outcome/implicit_value_converting_constructor/</guid>
      <description>Implicit value_type constructor. Calls void on_outcome_construction(T *, U &amp;amp;&amp;amp;) noexcept with this and R.
Requires: predicate::enable_value_converting_constructor&amp;lt;R&amp;gt; is true.
Complexity: Same as for value_type&amp;rsquo;s copy or move constructor. Constexpr, triviality and noexcept of underlying operations is propagated.</description>
    </item>
    
    <item>
      <title>`basic_result(R &amp;&amp;)`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_result/implicit_value_converting_constructor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_result/implicit_value_converting_constructor/</guid>
      <description>Implicit value_type constructor. Calls void on_result_construction(T *, U &amp;amp;&amp;amp;) noexcept with this and R.
Requires: predicate::enable_value_converting_constructor&amp;lt;R&amp;gt; is true.
Complexity: Same as for value_type&amp;rsquo;s copy or move constructor. Constexpr, triviality and noexcept of underlying operations is propagated.</description>
    </item>
    
    <item>
      <title>`basic_outcome(S &amp;&amp;)`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_outcome/implicit_error_converting_constructor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_outcome/implicit_error_converting_constructor/</guid>
      <description>Implicit error_type constructor. Calls void on_outcome_construction(T *, U &amp;amp;&amp;amp;) noexcept with this and S.
Requires: predicate::enable_error_converting_constructor&amp;lt;S&amp;gt; is true.
Complexity: Same as for error_type&amp;rsquo;s copy or move constructor. Constexpr, triviality and noexcept of underlying operations is propagated.</description>
    </item>
    
    <item>
      <title>`basic_result(S &amp;&amp;)`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_result/implicit_error_converting_constructor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_result/implicit_error_converting_constructor/</guid>
      <description>Implicit error_type constructor. Calls void on_result_construction(T *, U &amp;amp;&amp;amp;) noexcept with this and S.
Requires: predicate::enable_error_converting_constructor&amp;lt;S&amp;gt; is true.
Complexity: Same as for error_type&amp;rsquo;s copy or move constructor. Constexpr, triviality and noexcept of underlying operations is propagated.</description>
    </item>
    
    <item>
      <title>`basic_outcome(ErrorCondEnum &amp;&amp;)`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_outcome/implicit_error_condition_converting_constructor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_outcome/implicit_error_condition_converting_constructor/</guid>
      <description>Implicit error_type from ErrorCondEnum constructor. Calls void on_outcome_construction(T *, U &amp;amp;&amp;amp;) noexcept with this and ErrorCondEnum.
Requires: predicate::enable_error_condition_converting_constructor&amp;lt;R&amp;gt; is true.
Complexity: Same as for error_type&amp;rsquo;s copy or move constructor from the result of make_error_code(ErrorCondEnum). Constexpr, triviality and noexcept of underlying operations is propagated.
Guarantees: If an exception is thrown during the operation, the state of the input is left indeterminate.</description>
    </item>
    
    <item>
      <title>`basic_result(ErrorCondEnum &amp;&amp;)`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_result/implicit_error_condition_converting_constructor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_result/implicit_error_condition_converting_constructor/</guid>
      <description>Implicit error_type from ErrorCondEnum constructor. Calls void on_result_construction(T *, U &amp;amp;&amp;amp;) noexcept with this and ErrorCondEnum.
Requires: predicate::enable_error_condition_converting_constructor&amp;lt;R&amp;gt; is true.
Complexity: Same as for error_type&amp;rsquo;s copy or move constructor from the result of make_error_code(ErrorCondEnum). Constexpr, triviality and noexcept of underlying operations is propagated.
Guarantees: If an exception is thrown during the operation, the state of the input is left indeterminate.</description>
    </item>
    
    <item>
      <title>`static bool _has_value(Impl &amp;&amp;) noexcept`</title>
      <link>https://ned14.github.io/outcome/reference/policies/base/has_value/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/policies/base/has_value/</guid>
      <description>Returns true if a value is present in the implementation passed in. Constexpr where possible.
Requires: Always available.
Complexity: Constant time.
Guarantees: Never throws an exception.</description>
    </item>
    
    <item>
      <title>`basic_outcome(P &amp;&amp;)`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_outcome/implicit_exception_converting_constructor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_outcome/implicit_exception_converting_constructor/</guid>
      <description>Implicit exception_type constructor. Calls void on_outcome_construction(T *, U &amp;amp;&amp;amp;) noexcept with this and P.
Requires: predicate::enable_exception_converting_constructor&amp;lt;P&amp;gt; is true.
Complexity: Same as for exception_type&amp;rsquo;s copy or move constructor. Constexpr, triviality and noexcept of underlying operations is propagated.</description>
    </item>
    
    <item>
      <title>`basic_outcome(S &amp;&amp;, P &amp;&amp;)`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_outcome/implicit_error_exception_converting_constructor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_outcome/implicit_error_exception_converting_constructor/</guid>
      <description>Implicit error_type + exception_type constructor. Calls void on_outcome_construction(T *, U &amp;amp;&amp;amp;, V &amp;amp;&amp;amp;) noexcept with this, S and P.
Requires: predicate::enable_error_exception_converting_constructor&amp;lt;S, P&amp;gt; is true.
Complexity: Same as for error_type&amp;rsquo;s and exception_type&amp;rsquo;s copy or move constructor. Constexpr, triviality and noexcept of underlying operations is propagated.</description>
    </item>
    
    <item>
      <title>`static bool _has_error(Impl &amp;&amp;) noexcept`</title>
      <link>https://ned14.github.io/outcome/reference/policies/base/has_error/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/policies/base/has_error/</guid>
      <description>Returns true if an error is present in the implementation passed in. Constexpr where possible.
Requires: Always available.
Complexity: Constant time.
Guarantees: Never throws an exception.</description>
    </item>
    
    <item>
      <title>`static bool _has_exception(Impl &amp;&amp;) noexcept`</title>
      <link>https://ned14.github.io/outcome/reference/policies/base/has_exception/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/policies/base/has_exception/</guid>
      <description>Returns true if an exception is present in the implementation passed in. Constexpr where possible.
Requires: Always available.
Complexity: Constant time.
Guarantees: Never throws an exception.</description>
    </item>
    
    <item>
      <title>`static bool _has_error_is_errno(Impl &amp;&amp;) noexcept`</title>
      <link>https://ned14.github.io/outcome/reference/policies/base/has_error_is_errno/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/policies/base/has_error_is_errno/</guid>
      <description>Returns true if the error code in the implementation passed in has a domain or category matching that of POSIX errno. Constexpr where possible.
Requires: Always available.
Complexity: Constant time.
Guarantees: Never throws an exception.</description>
    </item>
    
    <item>
      <title>`static auto &amp;&amp;_value(Impl &amp;&amp;) noexcept`</title>
      <link>https://ned14.github.io/outcome/reference/policies/base/value/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/policies/base/value/</guid>
      <description>Returns a reference to the value in the implementation passed in. No checking is done to ensure there is a value. Constexpr where possible.
Requires: Always available.
Complexity: Constant time.
Guarantees: Never throws an exception.</description>
    </item>
    
    <item>
      <title>`static auto &amp;&amp;_error(Impl &amp;&amp;) noexcept`</title>
      <link>https://ned14.github.io/outcome/reference/policies/base/error/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/policies/base/error/</guid>
      <description>Returns a reference to the error in the implementation passed in. No checking is done to ensure there is an error. Constexpr where possible.
Requires: Always available.
Complexity: Constant time.
Guarantees: Never throws an exception.</description>
    </item>
    
    <item>
      <title>`static auto &amp;&amp;_exception(Impl &amp;&amp;) noexcept`</title>
      <link>https://ned14.github.io/outcome/reference/policies/base/exception/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/policies/base/exception/</guid>
      <description>Returns a reference to the exception in the implementation passed in. No checking is done to ensure there is an error. Constexpr where possible.
Requires: Always available.
Complexity: Constant time.
Guarantees: Never throws an exception.</description>
    </item>
    
    <item>
      <title>`explicit basic_outcome(concepts::value_or_error&lt;T, E&gt; &amp;&amp;)`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_outcome/explicit_valueorerror_converting_constructor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_outcome/explicit_valueorerror_converting_constructor/</guid>
      <description>Explicit converting constructor from concepts::value_or_error&amp;lt;T, E&amp;gt; concept matching types. Delegates to the basic_result move constructor explicit basic_outcome(basic_result&amp;lt;A, B, C&amp;gt; &amp;amp;&amp;amp;) .
Requires: convert::value_or_error&amp;lt;T, U&amp;gt; has an available call operator, and if the input is a basic_result or basic_outcome, then convert::value_or_error&amp;lt;&amp;gt; has enabled those inputs for that convert::value_or_error&amp;lt;&amp;gt; specialisation.
Complexity: Same as for the copy or move constructor from the input&amp;rsquo;s .value() or .error() respectively. Constexpr, triviality and noexcept of underlying operations is propagated.</description>
    </item>
    
    <item>
      <title>`explicit basic_result(concepts::value_or_error&lt;T, E&gt; &amp;&amp;)`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_result/explicit_valueorerror_converting_constructor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_result/explicit_valueorerror_converting_constructor/</guid>
      <description>Explicit converting constructor from concepts::value_or_error&amp;lt;T, E&amp;gt; concept matching types. Delegates to the basic_result move constructor.
Requires: convert::value_or_error&amp;lt;T, U&amp;gt; has an available call operator, and if the input is a basic_result or basic_outcome, then convert::value_or_error&amp;lt;&amp;gt; has enabled those inputs for that convert::value_or_error&amp;lt;&amp;gt; specialisation.
Complexity: Same as for the copy or move constructor from the input&amp;rsquo;s .value() or .error() respectively. Constexpr, triviality and noexcept of underlying operations is propagated.
Guarantees: If an exception is thrown during the operation, the object is left in a partially completed state, as per the normal rules for the same operation on a struct.</description>
    </item>
    
    <item>
      <title>`static void _set_has_value(Impl &amp;&amp;, bool) noexcept`</title>
      <link>https://ned14.github.io/outcome/reference/policies/base/set_has_value/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/policies/base/set_has_value/</guid>
      <description>Sets whether the implementation has a value by setting or clearing the relevant bit in the flags. Constexpr where possible.
Requires: Always available.
Complexity: Constant time.
Guarantees: Never throws an exception.</description>
    </item>
    
    <item>
      <title>`explicit basic_outcome(const basic_outcome&lt;A, B, C, D&gt; &amp;)`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_outcome/explicit_copy_converting_constructor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_outcome/explicit_copy_converting_constructor/</guid>
      <description>Explicit converting copy constructor from compatible basic_outcome. Calls void on_outcome_copy_construction(T *, U &amp;amp;&amp;amp;) noexcept with this and the input.
Requires: predicate::enable_compatible_conversion&amp;lt;A, B, C, D&amp;gt; is true.
Complexity: Same as for the copy constructors of the underlying types. Constexpr, triviality and noexcept of underlying operations is propagated.
Guarantees: If an exception is thrown during the operation, the object is left in a partially completed state, as per the normal rules for the same operation on a struct.</description>
    </item>
    
    <item>
      <title>`explicit basic_result(const basic_result&lt;R, S, P&gt; &amp;)`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_result/explicit_copy_converting_constructor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_result/explicit_copy_converting_constructor/</guid>
      <description>Explicit converting copy constructor from compatible basic_result. Calls void on_result_copy_construction(T *, U &amp;amp;&amp;amp;) noexcept with this and the input.
Requires: predicate::enable_compatible_conversion&amp;lt;R, S, P&amp;gt; is true.
Complexity: Same as for the copy constructors of the underlying types. Constexpr, triviality and noexcept of underlying operations is propagated.
Guarantees: If an exception is thrown during the operation, the object is left in a partially completed state, as per the normal rules for the same operation on a struct.</description>
    </item>
    
    <item>
      <title>`static void _set_has_error(Impl &amp;&amp;, bool) noexcept`</title>
      <link>https://ned14.github.io/outcome/reference/policies/base/set_has_error/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/policies/base/set_has_error/</guid>
      <description>Sets whether the implementation has an error by setting or clearing the relevant bit in the flags. Constexpr where possible.
Requires: Always available.
Complexity: Constant time.
Guarantees: Never throws an exception.</description>
    </item>
    
    <item>
      <title>`explicit basic_outcome(basic_outcome&lt;A, B, C, D&gt; &amp;&amp;)`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_outcome/explicit_move_converting_constructor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_outcome/explicit_move_converting_constructor/</guid>
      <description>Explicit converting move constructor from compatible basic_outcome. Calls void on_outcome_move_construction(T *, U &amp;amp;&amp;amp;) noexcept with this and the input.
Requires: predicate::enable_compatible_conversion&amp;lt;A, B, C, D&amp;gt; is true.
Complexity: Same as for the move constructors of the underlying types. Constexpr, triviality and noexcept of underlying operations is propagated.
Guarantees: If an exception is thrown during the operation, the object is left in a partially completed state, as per the normal rules for the same operation on a struct.</description>
    </item>
    
    <item>
      <title>`explicit basic_result(basic_result&lt;R, S, P&gt; &amp;&amp;)`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_result/explicit_move_converting_constructor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_result/explicit_move_converting_constructor/</guid>
      <description>Explicit converting move constructor from compatible basic_result. Calls void on_result_move_construction(T *, U &amp;amp;&amp;amp;) noexcept with this and the input.
Requires: predicate::enable_compatible_conversion&amp;lt;R, S, P&amp;gt; is true.
Complexity: Same as for the move constructors of the underlying types. Constexpr, triviality and noexcept of underlying operations is propagated.
Guarantees: If an exception is thrown during the operation, the object is left in a partially completed state, as per the normal rules for the same operation on a struct.</description>
    </item>
    
    <item>
      <title>`explicit basic_result(const basic_result&lt;R, S, P&gt; &amp;)`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_result/explicit_make_error_code_copy_converting_constructor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_result/explicit_make_error_code_copy_converting_constructor/</guid>
      <description>Explicit converting copy constructor from compatible basic_result. Calls void on_result_copy_construction(T *, U &amp;amp;&amp;amp;) noexcept with this and the input.
Requires: predicate::enable_make_error_code_compatible_conversion&amp;lt;R, S, P&amp;gt; is true.
Complexity: Same as for the copy constructors of the underlying types. Constexpr, triviality and noexcept of underlying operations is propagated.
Guarantees: If an exception is thrown during the operation, the object is left in a partially completed state, as per the normal rules for the same operation on a struct.</description>
    </item>
    
    <item>
      <title>`explicit basic_result(basic_result&lt;R, S, P&gt; &amp;&amp;)`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_result/explicit_make_error_code_move_converting_constructor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_result/explicit_make_error_code_move_converting_constructor/</guid>
      <description>Explicit converting move constructor from compatible basic_result. Calls void on_result_move_construction(T *, U &amp;amp;&amp;amp;) noexcept with this and the input.
Requires: predicate::enable_make_error_code_compatible_conversion&amp;lt;R, S, P&amp;gt; is true.
Complexity: Same as for the move constructors of the underlying types. Constexpr, triviality and noexcept of underlying operations is propagated.
Guarantees: If an exception is thrown during the operation, the object is left in a partially completed state, as per the normal rules for the same operation on a struct.</description>
    </item>
    
    <item>
      <title>`explicit basic_result(const basic_result&lt;R, S, P&gt; &amp;)`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_result/explicit_make_exception_ptr_copy_converting_constructor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_result/explicit_make_exception_ptr_copy_converting_constructor/</guid>
      <description>Explicit converting copy constructor from compatible basic_result. Calls void on_result_copy_construction(T *, U &amp;amp;&amp;amp;) noexcept with this and the input.
Requires: predicate::enable_make_exception_ptr_compatible_conversion&amp;lt;R, S, P&amp;gt; is true.
Complexity: Same as for the copy constructors of the underlying types. Constexpr, triviality and noexcept of underlying operations is propagated.
Guarantees: If an exception is thrown during the operation, the object is left in a partially completed state, as per the normal rules for the same operation on a struct.</description>
    </item>
    
    <item>
      <title>`explicit basic_result(basic_result&lt;R, S, P&gt; &amp;&amp;)`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_result/explicit_make_exception_ptr_move_converting_constructor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_result/explicit_make_exception_ptr_move_converting_constructor/</guid>
      <description>Explicit converting move constructor from compatible basic_result. Calls void on_result_move_construction(T *, U &amp;amp;&amp;amp;) noexcept with this and the input.
Requires: predicate::enable_make_exception_ptr_compatible_conversion&amp;lt;R, S, P&amp;gt; is true.
Complexity: Same as for the move constructors of the underlying types. Constexpr, triviality and noexcept of underlying operations is propagated.
Guarantees: If an exception is thrown during the operation, the object is left in a partially completed state, as per the normal rules for the same operation on a struct.</description>
    </item>
    
    <item>
      <title>`explicit basic_outcome(const basic_result&lt;A, B, C&gt; &amp;)`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_outcome/explicit_result_copy_converting_constructor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_outcome/explicit_result_copy_converting_constructor/</guid>
      <description>Explicit converting copy constructor from compatible basic_result. Calls void on_outcome_copy_construction(T *, U &amp;amp;&amp;amp;) noexcept with this and the input.
Requires: predicate::enable_compatible_conversion&amp;lt;A, B, void, C&amp;gt; is true.
Complexity: Same as for the copy constructors of the underlying types. Constexpr, triviality and noexcept of underlying operations is propagated.
Guarantees: If an exception is thrown during the operation, the object is left in a partially completed state, as per the normal rules for the same operation on a struct.</description>
    </item>
    
    <item>
      <title>`static void _set_has_exception(Impl &amp;&amp;, bool) noexcept`</title>
      <link>https://ned14.github.io/outcome/reference/policies/base/set_has_exception/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/policies/base/set_has_exception/</guid>
      <description>Sets whether the implementation has an exception by setting or clearing the relevant bit in the flags. Constexpr where possible.
Requires: Always available.
Complexity: Constant time.
Guarantees: Never throws an exception.</description>
    </item>
    
    <item>
      <title>`explicit basic_outcome(basic_result&lt;A, B, C&gt; &amp;&amp;)`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_outcome/explicit_result_move_converting_constructor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_outcome/explicit_result_move_converting_constructor/</guid>
      <description>Explicit converting move constructor from compatible basic_result. Calls void on_outcome_move_construction(T *, U &amp;amp;&amp;amp;) noexcept with this and the input.
Requires: predicate::enable_compatible_conversion&amp;lt;A, B, void, C&amp;gt; is true.
Complexity: Same as for the move constructors of the underlying types. Constexpr, triviality and noexcept of underlying operations is propagated.
Guarantees: If an exception is thrown during the operation, the object is left in a partially completed state, as per the normal rules for the same operation on a struct.</description>
    </item>
    
    <item>
      <title>`static void _set_has_exception(Impl &amp;&amp;, bool) noexcept`</title>
      <link>https://ned14.github.io/outcome/reference/policies/base/set_has_error_is_errno/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/policies/base/set_has_error_is_errno/</guid>
      <description>Sets whether the implementation&amp;rsquo;s error code has a domain or category matching that of POSIX errno by setting or clearing the relevant bit in the flags. Constexpr where possible.
Requires: Always available.
Complexity: Constant time.
Guarantees: Never throws an exception.</description>
    </item>
    
    <item>
      <title>`explicit basic_outcome(const basic_result&lt;A, B, C&gt; &amp;)`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_outcome/explicit_result_make_error_code_copy_converting_constructor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_outcome/explicit_result_make_error_code_copy_converting_constructor/</guid>
      <description>Explicit converting copy constructor from compatible basic_result. Calls void on_outcome_copy_construction(T *, U &amp;amp;&amp;amp;) noexcept with this and the input.
Requires: predicate::enable_make_error_code_compatible_conversion&amp;lt;A, B, void, C&amp;gt; is true.
Complexity: Same as for the copy constructors of the underlying types. Constexpr, triviality and noexcept of underlying operations is propagated.
Guarantees: If an exception is thrown during the operation, the object is left in a partially completed state, as per the normal rules for the same operation on a struct.</description>
    </item>
    
    <item>
      <title>`explicit basic_outcome(basic_result&lt;A, B, C&gt; &amp;&amp;)`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_outcome/explicit_result_make_error_code_move_converting_constructor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_outcome/explicit_result_make_error_code_move_converting_constructor/</guid>
      <description>Explicit converting move constructor from compatible basic_result. Calls void on_outcome_move_construction(T *, U &amp;amp;&amp;amp;) noexcept with this and the input.
Requires: predicate::enable_make_error_code_compatible_conversion&amp;lt;A, B, void, C&amp;gt; is true.
Complexity: Same as for the move constructors of the underlying types. Constexpr, triviality and noexcept of underlying operations is propagated.
Guarantees: If an exception is thrown during the operation, the object is left in a partially completed state, as per the normal rules for the same operation on a struct.</description>
    </item>
    
    <item>
      <title>`explicit basic_outcome(in_place_type_t&lt;value_type_if_enabled&gt;, Args ...)`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_outcome/explicit_inplace_value_constructor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_outcome/explicit_inplace_value_constructor/</guid>
      <description>Explicit inplace value constructor. Calls void on_outcome_in_place_construction(T *, in_place_type_t&amp;lt;U&amp;gt;, Args &amp;amp;&amp;amp;...) noexcept with this, in_place_type&amp;lt;value_type&amp;gt; and Args ....
Requires: predicate::enable_inplace_value_constructor&amp;lt;Args ...&amp;gt; is true.
Complexity: Same as for the value_type constructor which accepts Args .... Constexpr, triviality and noexcept of underlying operations is propagated.
Guarantees: If an exception is thrown during the operation, the state of the Args is left indeterminate.</description>
    </item>
    
    <item>
      <title>`explicit basic_result(in_place_type_t&lt;value_type_if_enabled&gt;, Args ...)`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_result/explicit_inplace_value_constructor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_result/explicit_inplace_value_constructor/</guid>
      <description>Explicit inplace value constructor. Calls void on_result_in_place_construction(T *, in_place_type_t&amp;lt;U&amp;gt;, Args &amp;amp;&amp;amp;...) noexcept with this, in_place_type&amp;lt;value_type&amp;gt; and Args ....
Requires: predicate::enable_inplace_value_constructor&amp;lt;Args ...&amp;gt; is true.
Complexity: Same as for the value_type constructor which accepts Args .... Constexpr, triviality and noexcept of underlying operations is propagated.
Guarantees: If an exception is thrown during the operation, the state of the Args is left indeterminate.</description>
    </item>
    
    <item>
      <title>`static void narrow_value_check(Impl &amp;&amp;) noexcept`</title>
      <link>https://ned14.github.io/outcome/reference/policies/base/narrow_value_check/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/policies/base/narrow_value_check/</guid>
      <description>Observer policy performing hard UB if no value is present, by calling static void _ub(Impl &amp;amp;&amp;amp;) . Constexpr where possible.
Requires: Always available.
Complexity: Constant time.
Guarantees: Never throws an exception.</description>
    </item>
    
    <item>
      <title>`explicit basic_outcome(in_place_type_t&lt;value_type_if_enabled&gt;, std::initializer_list&lt;U&gt;, Args ...)`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_outcome/explicit_inplace_value_constructor_il/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_outcome/explicit_inplace_value_constructor_il/</guid>
      <description>Explicit inplace value constructor. Calls void on_outcome_in_place_construction(T *, in_place_type_t&amp;lt;U&amp;gt;, Args &amp;amp;&amp;amp;...) noexcept with this, in_place_type&amp;lt;value_type&amp;gt;, &amp;lsquo;std::initializer_list&amp;rsquo; and Args ....
Requires: predicate::enable_inplace_value_constructor&amp;lt;std::initializer_list&amp;lt;U&amp;gt;, Args ...&amp;gt; is true.
Complexity: Same as for the value_type constructor which accepts std::initializer_list&amp;lt;U&amp;gt;, Args .... Constexpr, triviality and noexcept of underlying operations is propagated.
Guarantees: If an exception is thrown during the operation, the state of the Args is left indeterminate.</description>
    </item>
    
    <item>
      <title>`explicit basic_result(in_place_type_t&lt;value_type_if_enabled&gt;, std::initializer_list&lt;U&gt;, Args ...)`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_result/explicit_inplace_value_constructor_il/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_result/explicit_inplace_value_constructor_il/</guid>
      <description>Explicit inplace value constructor. Calls void on_result_in_place_construction(T *, in_place_type_t&amp;lt;U&amp;gt;, Args &amp;amp;&amp;amp;...) noexcept with this, in_place_type&amp;lt;value_type&amp;gt;, &amp;lsquo;std::initializer_list&amp;rsquo; and Args ....
Requires: predicate::enable_inplace_value_constructor&amp;lt;std::initializer_list&amp;lt;U&amp;gt;, Args ...&amp;gt; is true.
Complexity: Same as for the value_type constructor which accepts std::initializer_list&amp;lt;U&amp;gt;, Args .... Constexpr, triviality and noexcept of underlying operations is propagated.
Guarantees: If an exception is thrown during the operation, the state of the Args is left indeterminate.</description>
    </item>
    
    <item>
      <title>`static void narrow_error_check(Impl &amp;&amp;) noexcept`</title>
      <link>https://ned14.github.io/outcome/reference/policies/base/narrow_error_check/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/policies/base/narrow_error_check/</guid>
      <description>Observer policy performing hard UB if no error is present, by calling static void _ub(Impl &amp;amp;&amp;amp;) . Constexpr where possible.
Requires: Always available.
Complexity: Constant time.
Guarantees: Never throws an exception.</description>
    </item>
    
    <item>
      <title>`explicit basic_outcome(in_place_type_t&lt;error_type_if_enabled&gt;, Args ...)`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_outcome/explicit_inplace_error_constructor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_outcome/explicit_inplace_error_constructor/</guid>
      <description>Explicit inplace error constructor. Calls void on_outcome_in_place_construction(T *, in_place_type_t&amp;lt;U&amp;gt;, Args &amp;amp;&amp;amp;...) noexcept with this, in_place_type&amp;lt;error_type&amp;gt; and Args ....
Requires: predicate::enable_inplace_error_constructor&amp;lt;Args ...&amp;gt; is true.
Complexity: Same as for the error_type constructor which accepts Args .... Constexpr, triviality and noexcept of underlying operations is propagated.
Guarantees: If an exception is thrown during the operation, the state of the Args is left indeterminate.</description>
    </item>
    
    <item>
      <title>`explicit basic_result(in_place_type_t&lt;error_type_if_enabled&gt;, Args ...)`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_result/explicit_inplace_error_constructor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_result/explicit_inplace_error_constructor/</guid>
      <description>Explicit inplace error constructor. Calls void on_result_in_place_construction(T *, in_place_type_t&amp;lt;U&amp;gt;, Args &amp;amp;&amp;amp;...) noexcept with this, in_place_type&amp;lt;error_type&amp;gt; and Args ....
Requires: predicate::enable_inplace_error_constructor&amp;lt;Args ...&amp;gt; is true.
Complexity: Same as for the error_type constructor which accepts Args .... Constexpr, triviality and noexcept of underlying operations is propagated.
Guarantees: If an exception is thrown during the operation, the state of the Args is left indeterminate.</description>
    </item>
    
    <item>
      <title>`static void narrow_exception_check(Impl &amp;&amp;) noexcept`</title>
      <link>https://ned14.github.io/outcome/reference/policies/base/narrow_exception_check/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/policies/base/narrow_exception_check/</guid>
      <description>Observer policy performing hard UB if no exception is present, by calling static void _ub(Impl &amp;amp;&amp;amp;) . Constexpr where possible.
Requires: Always available.
Complexity: Constant time.
Guarantees: Never throws an exception.</description>
    </item>
    
    <item>
      <title>`explicit basic_outcome(in_place_type_t&lt;error_type_if_enabled&gt;, std::initializer_list&lt;U&gt;, Args ...)`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_outcome/explicit_inplace_error_constructor_il/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_outcome/explicit_inplace_error_constructor_il/</guid>
      <description>Explicit inplace error constructor. Calls void on_outcome_in_place_construction(T *, in_place_type_t&amp;lt;U&amp;gt;, Args &amp;amp;&amp;amp;...) noexcept with this, in_place_type&amp;lt;error_type&amp;gt;, std::initializer_list&amp;lt;U&amp;gt; and Args ....
Requires: predicate::enable_inplace_error_constructor&amp;lt;std::initializer_list&amp;lt;U&amp;gt;, Args ...&amp;gt; is true.
Complexity: Same as for the error_type constructor which accepts std::initializer_list&amp;lt;U&amp;gt;, Args .... Constexpr, triviality and noexcept of underlying operations is propagated.
Guarantees: If an exception is thrown during the operation, the state of the Args is left indeterminate.</description>
    </item>
    
    <item>
      <title>`explicit basic_result(in_place_type_t&lt;error_type_if_enabled&gt;, std::initializer_list&lt;U&gt;, Args ...)`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_result/explicit_inplace_error_constructor_il/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_result/explicit_inplace_error_constructor_il/</guid>
      <description>Explicit inplace error constructor. Calls void on_result_in_place_construction(T *, in_place_type_t&amp;lt;U&amp;gt;, Args &amp;amp;&amp;amp;...) noexcept with this, in_place_type&amp;lt;error_type&amp;gt;, std::initializer_list&amp;lt;U&amp;gt; and Args ....
Requires: predicate::enable_inplace_error_constructor&amp;lt;std::initializer_list&amp;lt;U&amp;gt;, Args ...&amp;gt; is true.
Complexity: Same as for the error_type constructor which accepts std::initializer_list&amp;lt;U&amp;gt;, Args .... Constexpr, triviality and noexcept of underlying operations is propagated.
Guarantees: If an exception is thrown during the operation, the state of the Args is left indeterminate.</description>
    </item>
    
    <item>
      <title>`explicit basic_outcome(in_place_type_t&lt;exception_type_if_enabled&gt;, Args ...)`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_outcome/explicit_inplace_exception_constructor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_outcome/explicit_inplace_exception_constructor/</guid>
      <description>Explicit inplace exception constructor. Calls void on_outcome_in_place_construction(T *, in_place_type_t&amp;lt;U&amp;gt;, Args &amp;amp;&amp;amp;...) noexcept with this, in_place_type&amp;lt;exception_type&amp;gt; and Args ....
Requires: predicate::enable_inplace_exception_constructor&amp;lt;Args ...&amp;gt; is true.
Complexity: Same as for the exception_type constructor which accepts Args .... Constexpr, triviality and noexcept of underlying operations is propagated.
Guarantees: If an exception is thrown during the operation, the state of the Args is left indeterminate.</description>
    </item>
    
    <item>
      <title>`explicit basic_outcome(in_place_type_t&lt;exception_type_if_enabled&gt;, std::initializer_list&lt;U&gt;, Args ...)`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_outcome/explicit_inplace_exception_constructor_il/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_outcome/explicit_inplace_exception_constructor_il/</guid>
      <description>Explicit inplace exception constructor. Calls void on_outcome_in_place_construction(T *, in_place_type_t&amp;lt;U&amp;gt;, Args &amp;amp;&amp;amp;...) noexcept with this, in_place_type&amp;lt;exception_type&amp;gt;, std::initializer_list&amp;lt;U&amp;gt; and Args ....
Requires: predicate::enable_inplace_exception_constructor&amp;lt;std::initializer_list&amp;lt;U&amp;gt;, Args ...&amp;gt; is true.
Complexity: Same as for the exception_type constructor which accepts std::initializer_list&amp;lt;U&amp;gt;, Args .... Constexpr, triviality and noexcept of underlying operations is propagated.
Guarantees: If an exception is thrown during the operation, the state of the Args is left indeterminate.</description>
    </item>
    
    <item>
      <title>`basic_outcome(A1 &amp;&amp;, A2 &amp;&amp;, Args ...)`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_outcome/implicit_inplace_value_error_exception_constructor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_outcome/implicit_inplace_value_error_exception_constructor/</guid>
      <description>Implicit inplace value or error or exception constructor. Delegates to an appropriate explicit inplace constructor depending on input.
Requires: predicate::enable_inplace_value_error_exception_constructor` is true.
Complexity: Same as for the value_type or error_type or exception_type constructor which accepts A1, A2, Args .... Constexpr, triviality and noexcept of underlying operations is propagated.
Guarantees: If an exception is thrown during the operation, the state of the Args is left indeterminate.</description>
    </item>
    
    <item>
      <title>`basic_result(A1 &amp;&amp;, A2 &amp;&amp;, Args ...)`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_result/implicit_inplace_value_error_constructor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_result/implicit_inplace_value_error_constructor/</guid>
      <description>Implicit inplace value or error constructor. Delegates to an appropriate explicit inplace constructor depending on input.
Requires: predicate::enable_inplace_value_error_constructor` is true.
Complexity: Same as for the value_type or error_type constructor which accepts A1, A2, Args .... Constexpr, triviality and noexcept of underlying operations is propagated.
Guarantees: If an exception is thrown during the operation, the state of the Args is left indeterminate.</description>
    </item>
    
    <item>
      <title>`static void on_outcome_construction(T *, U &amp;&amp;) noexcept`</title>
      <link>https://ned14.github.io/outcome/reference/policies/base/on_outcome_construction/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/policies/base/on_outcome_construction/</guid>
      <description>One of the constructor hooks for basic_outcome&amp;lt;T, EC, EP, NoValuePolicy&amp;gt; , generally invoked by the implicit constructors of basic_outcome. See each constructor&amp;rsquo;s documentation to see which specific hook it invokes.
Requires: Always available.
Guarantees: Never throws an exception.</description>
    </item>
    
    <item>
      <title>`static void on_outcome_construction(T *, U &amp;&amp;, V &amp;&amp;) noexcept`</title>
      <link>https://ned14.github.io/outcome/reference/policies/base/on_outcome_construction2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/policies/base/on_outcome_construction2/</guid>
      <description>One of the constructor hooks for basic_outcome&amp;lt;T, EC, EP, NoValuePolicy&amp;gt; , generally invoked by the implicit constructors of basic_outcome which consume two arguments. See each constructor&amp;rsquo;s documentation to see which specific hook it invokes.
Requires: Always available.
Guarantees: Never throws an exception.</description>
    </item>
    
    <item>
      <title>`static void on_outcome_copy_construction(T *, U &amp;&amp;) noexcept`</title>
      <link>https://ned14.github.io/outcome/reference/policies/base/on_outcome_copy_construction/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/policies/base/on_outcome_copy_construction/</guid>
      <description>One of the constructor hooks for basic_outcome&amp;lt;T, EC, EP, NoValuePolicy&amp;gt; , generally invoked by the converting copy constructors of basic_outcome (NOT the standard copy constructor). See each constructor&amp;rsquo;s documentation to see which specific hook it invokes.
Requires: Always available.
Guarantees: Never throws an exception.</description>
    </item>
    
    <item>
      <title>`static void on_outcome_copy_construction(T *, U &amp;&amp;, V &amp;&amp;) noexcept`</title>
      <link>https://ned14.github.io/outcome/reference/policies/base/on_outcome_copy_construction2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/policies/base/on_outcome_copy_construction2/</guid>
      <description>One of the constructor hooks for basic_outcome&amp;lt;T, EC, EP, NoValuePolicy&amp;gt; , generally invoked by the converting copy constructors of basic_outcome (NOT the standard copy constructor) which consume two arguments. See each constructor&amp;rsquo;s documentation to see which specific hook it invokes.
Requires: Always available.
Guarantees: Never throws an exception.</description>
    </item>
    
    <item>
      <title>`static void on_outcome_in_place_construction(T *, in_place_type_t&lt;U&gt;, Args &amp;&amp;...) noexcept`</title>
      <link>https://ned14.github.io/outcome/reference/policies/base/on_outcome_in_place_construction/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/policies/base/on_outcome_in_place_construction/</guid>
      <description>One of the constructor hooks for basic_outcome&amp;lt;T, EC, EP, NoValuePolicy&amp;gt; , generally invoked by the in-place constructors of basic_outcome. See each constructor&amp;rsquo;s documentation to see which specific hook it invokes.
Requires: Always available.
Guarantees: Never throws an exception.</description>
    </item>
    
    <item>
      <title>`static void on_outcome_move_construction(T *, U &amp;&amp;) noexcept`</title>
      <link>https://ned14.github.io/outcome/reference/policies/base/on_outcome_move_construction/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/policies/base/on_outcome_move_construction/</guid>
      <description>One of the constructor hooks for basic_outcome&amp;lt;T, EC, EP, NoValuePolicy&amp;gt; , generally invoked by the converting move constructors of basic_outcome (NOT the standard move constructor). See each constructor&amp;rsquo;s documentation to see which specific hook it invokes.
Requires: Always available.
Guarantees: Never throws an exception.</description>
    </item>
    
    <item>
      <title>`static void on_outcome_move_construction(T *, U &amp;&amp;, V &amp;&amp;) noexcept`</title>
      <link>https://ned14.github.io/outcome/reference/policies/base/on_outcome_move_construction2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/policies/base/on_outcome_move_construction2/</guid>
      <description>One of the constructor hooks for basic_outcome&amp;lt;T, EC, EP, NoValuePolicy&amp;gt; , generally invoked by the converting move constructors of basic_outcome (NOT the standard move constructor) which consume two arguments. See each constructor&amp;rsquo;s documentation to see which specific hook it invokes.
Requires: Always available.
Guarantees: Never throws an exception.</description>
    </item>
    
    <item>
      <title>`static void on_result_construction(T *, U &amp;&amp;) noexcept`</title>
      <link>https://ned14.github.io/outcome/reference/policies/base/on_result_construction/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/policies/base/on_result_construction/</guid>
      <description>One of the constructor hooks for basic_result&amp;lt;T, E, NoValuePolicy&amp;gt; , generally invoked by the implicit constructors of basic_result. See each constructor&amp;rsquo;s documentation to see which specific hook it invokes.
Requires: Always available.
Guarantees: Never throws an exception.</description>
    </item>
    
    <item>
      <title>`static void on_result_copy_construction(T *, U &amp;&amp;) noexcept`</title>
      <link>https://ned14.github.io/outcome/reference/policies/base/on_result_copy_construction/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/policies/base/on_result_copy_construction/</guid>
      <description>One of the constructor hooks for basic_result&amp;lt;T, E, NoValuePolicy&amp;gt; , generally invoked by the converting copy constructors of basic_result (NOT the standard copy constructor). See each constructor&amp;rsquo;s documentation to see which specific hook it invokes.
Requires: Always available.
Guarantees: Never throws an exception.</description>
    </item>
    
    <item>
      <title>`static void on_result_in_place_construction(T *, in_place_type_t&lt;U&gt;, Args &amp;&amp;...) noexcept`</title>
      <link>https://ned14.github.io/outcome/reference/policies/base/on_result_in_place_construction/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/policies/base/on_result_in_place_construction/</guid>
      <description>One of the constructor hooks for basic_result&amp;lt;T, E, NoValuePolicy&amp;gt; , generally invoked by the in-place constructors of basic_result. See each constructor&amp;rsquo;s documentation to see which specific hook it invokes.
Requires: Always available.
Guarantees: Never throws an exception.</description>
    </item>
    
    <item>
      <title>`static void on_result_move_construction(T *, U &amp;&amp;) noexcept`</title>
      <link>https://ned14.github.io/outcome/reference/policies/base/on_result_move_construction/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/policies/base/on_result_move_construction/</guid>
      <description>One of the constructor hooks for basic_result&amp;lt;T, E, NoValuePolicy&amp;gt; , generally invoked by the converting move constructors of basic_result (NOT the standard move constructor). See each constructor&amp;rsquo;s documentation to see which specific hook it invokes.
Requires: Always available.
Guarantees: Never throws an exception.</description>
    </item>
    
    <item>
      <title>`basic_outcome(const success_type&lt;T&gt; &amp;)`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_outcome/implicit_success_copy_constructor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_outcome/implicit_success_copy_constructor/</guid>
      <description>Implicit value-from-success-type-sugar copy constructor used to disambiguate the construction of the value type. Note that if T = void, value_type will be default constructed. Calls void on_outcome_copy_construction(T *, U &amp;amp;&amp;amp;) noexcept with this and const success_type&amp;lt;T&amp;gt; &amp;amp;.
Requires: predicate::enable_compatible_conversion&amp;lt;T, void, void&amp;gt; is true, or T is void.
Complexity: Same as for the value_type constructor which accepts T, or the value_type default constructor if T is void. Constexpr, triviality and noexcept of underlying operations is propagated.</description>
    </item>
    
    <item>
      <title>`basic_result(const success_type&lt;T&gt; &amp;)`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_result/implicit_success_copy_constructor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_result/implicit_success_copy_constructor/</guid>
      <description>Implicit value-from-success-type-sugar copy constructor used to disambiguate the construction of the value type. Note that if T = void, value_type will be default constructed. Calls void on_result_copy_construction(T *, U &amp;amp;&amp;amp;) noexcept with this and const success_type&amp;lt;T&amp;gt; &amp;amp;.
Requires: predicate::enable_compatible_conversion&amp;lt;T, void, void&amp;gt; is true, or T is void.
Complexity: Same as for the value_type constructor which accepts T, or the value_type default constructor if T is void. Constexpr, triviality and noexcept of underlying operations is propagated.</description>
    </item>
    
    <item>
      <title>`basic_outcome(success_type&lt;T&gt; &amp;&amp;)`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_outcome/implicit_success_move_constructor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_outcome/implicit_success_move_constructor/</guid>
      <description>Implicit value-from-success-type-sugar move constructor used to disambiguate the construction of the value type. Note that if T = void, value_type will be default constructed. Calls void on_outcome_move_construction(T *, U &amp;amp;&amp;amp;) noexcept with this and success_type&amp;lt;T&amp;gt; &amp;amp;&amp;amp;.
Requires: predicate::enable_compatible_conversion&amp;lt;T, void, void&amp;gt; is true, or T is void.
Complexity: Same as for the value_type constructor which accepts T, or the value_type default constructor if T is void. Constexpr, triviality and noexcept of underlying operations is propagated.</description>
    </item>
    
    <item>
      <title>`basic_result(success_type&lt;T&gt; &amp;&amp;)`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_result/implicit_success_move_constructor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_result/implicit_success_move_constructor/</guid>
      <description>Implicit value-from-success-type-sugar move constructor used to disambiguate the construction of the value type. Note that if T = void, value_type will be default constructed. Calls void on_result_move_construction(T *, U &amp;amp;&amp;amp;) noexcept with this and success_type&amp;lt;T&amp;gt; &amp;amp;&amp;amp;.
Requires: predicate::enable_compatible_conversion&amp;lt;T, void, void&amp;gt; is true, or T is void.
Complexity: Same as for the value_type constructor which accepts T, or the value_type default constructor if T is void. Constexpr, triviality and noexcept of underlying operations is propagated.</description>
    </item>
    
    <item>
      <title>`basic_outcome(const failure_type&lt;EC&gt; &amp;)`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_outcome/implicit_failure_error_copy_constructor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_outcome/implicit_failure_error_copy_constructor/</guid>
      <description>Implicit error-from-failure-type-sugar copy constructor used to disambiguate the construction of the error type. Calls void on_outcome_copy_construction(T *, U &amp;amp;&amp;amp;) noexcept with this and const failure_type&amp;lt;EC&amp;gt; &amp;amp;.
Requires: predicate::enable_compatible_conversion&amp;lt;void, EC, void, void&amp;gt; is true.
Complexity: Same as for the error_type constructor which accepts EC. Constexpr, triviality and noexcept of underlying operations is propagated.</description>
    </item>
    
    <item>
      <title>`basic_result(const failure_type&lt;T&gt; &amp;)`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_result/implicit_failure_copy_constructor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_result/implicit_failure_copy_constructor/</guid>
      <description>Implicit error-from-failure-type-sugar copy constructor used to disambiguate the construction of the error type. Note that if T = void, error_type will be default constructed. Calls void on_result_copy_construction(T *, U &amp;amp;&amp;amp;) noexcept with this and const failure_type&amp;lt;T&amp;gt; &amp;amp;.
Requires: predicate::enable_compatible_conversion&amp;lt;void, T, void&amp;gt; is true, or T is void.
Complexity: Same as for the error_type constructor which accepts T, or the error_type default constructor if T is void. Constexpr, triviality and noexcept of underlying operations is propagated.</description>
    </item>
    
    <item>
      <title>`basic_outcome(failure_type&lt;EC&gt; &amp;&amp;)`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_outcome/implicit_failure_error_move_constructor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_outcome/implicit_failure_error_move_constructor/</guid>
      <description>Implicit error-from-failure-type-sugar move constructor used to disambiguate the construction of the error type. Calls void on_outcome_move_construction(T *, U &amp;amp;&amp;amp;) noexcept with this and failure_type&amp;lt;EC&amp;gt; &amp;amp;&amp;amp;.
Requires: predicate::enable_compatible_conversion&amp;lt;void, EC, void, void&amp;gt; is true.
Complexity: Same as for the error_type constructor which accepts EC. Constexpr, triviality and noexcept of underlying operations is propagated.</description>
    </item>
    
    <item>
      <title>`basic_result(failure_type&lt;T&gt; &amp;&amp;)`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_result/implicit_failure_move_constructor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_result/implicit_failure_move_constructor/</guid>
      <description>Implicit error-from-failure-type-sugar move constructor used to disambiguate the construction of the error type. Note that if T = void, error_type will be default constructed. Calls void on_result_move_construction(T *, U &amp;amp;&amp;amp;) noexcept with this and failure_type&amp;lt;T&amp;gt; &amp;amp;&amp;amp;.
Requires: predicate::enable_compatible_conversion&amp;lt;void, T, void&amp;gt; is true, or T is void.
Complexity: Same as for the error_type constructor which accepts T, or the error_type default constructor if T is void. Constexpr, triviality and noexcept of underlying operations is propagated.</description>
    </item>
    
    <item>
      <title>`basic_outcome(const failure_type&lt;EC&gt; &amp;)`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_outcome/implicit_failure_error_make_error_code_copy_constructor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_outcome/implicit_failure_error_make_error_code_copy_constructor/</guid>
      <description>Implicit error-from-failure-type-sugar copy constructor used to disambiguate the construction of the error type. Calls void on_outcome_copy_construction(T *, U &amp;amp;&amp;amp;) noexcept with this and const failure_type&amp;lt;EC&amp;gt; &amp;amp;.
Requires: predicate::enable_make_error_code_compatible_conversion&amp;lt;void, EC, void, void&amp;gt; is true.
Complexity: Same as for the error_type constructor which accepts EC. Constexpr, triviality and noexcept of underlying operations is propagated.</description>
    </item>
    
    <item>
      <title>`basic_result(const failure_type&lt;T&gt; &amp;)`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_result/implicit_failure_make_error_code_copy_constructor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_result/implicit_failure_make_error_code_copy_constructor/</guid>
      <description>Implicit error-from-failure-type-sugar copy constructor used to disambiguate the construction of the error type. Note that if T = void, error_type will be default constructed. Calls void on_result_copy_construction(T *, U &amp;amp;&amp;amp;) noexcept with this and const failure_type&amp;lt;T&amp;gt; &amp;amp;.
Requires: predicate::enable_make_error_code_compatible_conversion&amp;lt;void, T, void&amp;gt; is true, or T is void.
Complexity: Same as for the error_type constructor which accepts T, or the error_type default constructor if T is void. Constexpr, triviality and noexcept of underlying operations is propagated.</description>
    </item>
    
    <item>
      <title>`basic_outcome(failure_type&lt;EC&gt; &amp;&amp;)`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_outcome/implicit_failure_error_make_error_code_move_constructor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_outcome/implicit_failure_error_make_error_code_move_constructor/</guid>
      <description>Implicit error-from-failure-type-sugar move constructor used to disambiguate the construction of the error type. Calls void on_outcome_move_construction(T *, U &amp;amp;&amp;amp;) noexcept with this and failure_type&amp;lt;EC&amp;gt; &amp;amp;&amp;amp;.
Requires: predicate::enable_make_error_code_compatible_conversion&amp;lt;void, EC, void, void&amp;gt; is true.
Complexity: Same as for the error_type constructor which accepts EC. Constexpr, triviality and noexcept of underlying operations is propagated.</description>
    </item>
    
    <item>
      <title>`basic_result(failure_type&lt;T&gt; &amp;&amp;)`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_result/implicit_failure_make_error_code_move_constructor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_result/implicit_failure_make_error_code_move_constructor/</guid>
      <description>Implicit error-from-failure-type-sugar move constructor used to disambiguate the construction of the error type. Note that if T = void, error_type will be default constructed. Calls void on_result_move_construction(T *, U &amp;amp;&amp;amp;) noexcept with this and failure_type&amp;lt;T&amp;gt; &amp;amp;&amp;amp;.
Requires: predicate::enable_make_error_code_compatible_conversion&amp;lt;void, T, void&amp;gt; is true, or T is void.
Complexity: Same as for the error_type constructor which accepts T, or the error_type default constructor if T is void. Constexpr, triviality and noexcept of underlying operations is propagated.</description>
    </item>
    
    <item>
      <title>`basic_result(const failure_type&lt;T&gt; &amp;)`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_result/implicit_failure_make_exception_ptr_copy_constructor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_result/implicit_failure_make_exception_ptr_copy_constructor/</guid>
      <description>Implicit error-from-failure-type-sugar copy constructor used to disambiguate the construction of the error type. Note that if T = void, error_type will be default constructed. Calls void on_result_copy_construction(T *, U &amp;amp;&amp;amp;) noexcept with this and const failure_type&amp;lt;T&amp;gt; &amp;amp;.
Requires: predicate::enable_make_exception_ptr_compatible_conversion&amp;lt;void, T, void&amp;gt; is true, or T is void.
Complexity: Same as for the error_type constructor which accepts T, or the error_type default constructor if T is void. Constexpr, triviality and noexcept of underlying operations is propagated.</description>
    </item>
    
    <item>
      <title>`basic_outcome(const failure_type&lt;EP&gt; &amp;)`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_outcome/implicit_failure_exception_copy_constructor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_outcome/implicit_failure_exception_copy_constructor/</guid>
      <description>Implicit exception-from-failure-type-sugar copy constructor used to disambiguate the construction of the exception type. Calls void on_outcome_copy_construction(T *, U &amp;amp;&amp;amp;) noexcept with this and const failure_type&amp;lt;EP&amp;gt; &amp;amp;.
Requires: predicate::enable_compatible_conversion&amp;lt;void, void, EP, void&amp;gt; is true.
Complexity: Same as for the exception_type constructor which accepts EP. Constexpr, triviality and noexcept of underlying operations is propagated.</description>
    </item>
    
    <item>
      <title>`basic_result(failure_type&lt;T&gt; &amp;&amp;)`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_result/implicit_failure_make_exception_ptr_move_constructor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_result/implicit_failure_make_exception_ptr_move_constructor/</guid>
      <description>Implicit error-from-failure-type-sugar move constructor used to disambiguate the construction of the error type. Note that if T = void, error_type will be default constructed. Calls void on_result_move_construction(T *, U &amp;amp;&amp;amp;) noexcept with this and failure_type&amp;lt;T&amp;gt; &amp;amp;&amp;amp;.
Requires: predicate::enable_make_exception_ptr_compatible_conversion&amp;lt;void, T, void&amp;gt; is true, or T is void.
Complexity: Same as for the error_type constructor which accepts T, or the error_type default constructor if T is void. Constexpr, triviality and noexcept of underlying operations is propagated.</description>
    </item>
    
    <item>
      <title>`basic_outcome(failure_type&lt;EP&gt; &amp;&amp;)`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_outcome/implicit_failure_exception_move_constructor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_outcome/implicit_failure_exception_move_constructor/</guid>
      <description>Implicit exception-from-failure-type-sugar move constructor used to disambiguate the construction of the exception type. Calls void on_outcome_move_construction(T *, U &amp;amp;&amp;amp;) noexcept with this and failure_type&amp;lt;EP&amp;gt; &amp;amp;&amp;amp;.
Requires: predicate::enable_compatible_conversion&amp;lt;void, void, EP, void&amp;gt; is true.
Complexity: Same as for the exception_type constructor which accepts EP. Constexpr, triviality and noexcept of underlying operations is propagated.</description>
    </item>
    
    <item>
      <title>`basic_outcome(const failure_type&lt;EC, EP&gt; &amp;)`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_outcome/implicit_failure_error_exception_copy_constructor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_outcome/implicit_failure_error_exception_copy_constructor/</guid>
      <description>Implicit error-and-exception-from-failure-type-sugar copy constructor used to disambiguate the construction of the error + exception types. Calls void on_outcome_copy_construction(T *, U &amp;amp;&amp;amp;, V &amp;amp;&amp;amp;) noexcept with this, const failure_type&amp;lt;EC&amp;gt; &amp;amp; and const failure_type&amp;lt;EP&amp;gt; &amp;amp;.
Requires: predicate::enable_compatible_conversion&amp;lt;void, EC, EP, void&amp;gt; is true.
Complexity: Same as for the error_type and exception_type constructors which accept EC and EP. Constexpr, triviality and noexcept of underlying operations is propagated.</description>
    </item>
    
    <item>
      <title>`basic_outcome(failure_type&lt;EC, EP&gt; &amp;&amp;)`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_outcome/implicit_failure_error_exception_move_constructor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_outcome/implicit_failure_error_exception_move_constructor/</guid>
      <description>Implicit error-and-exception-from-failure-type-sugar move constructor used to disambiguate the construction of the error + exception types. Calls void on_outcome_move_construction(T *, U &amp;amp;&amp;amp;, V &amp;amp;&amp;amp;) noexcept with this, failure_type&amp;lt;EC&amp;gt; &amp;amp;&amp;amp; and failure_type&amp;lt;EP&amp;gt; &amp;amp;&amp;amp;.
Requires: predicate::enable_compatible_conversion&amp;lt;void, EC, EP, void&amp;gt; is true.
Complexity: Same as for the error_type and exception_type constructors which accept EC and EP. Constexpr, triviality and noexcept of underlying operations is propagated.</description>
    </item>
    
    <item>
      <title>`explicit operator bool() const noexcept`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_outcome/operator_bool/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_outcome/operator_bool/</guid>
      <description>Returns true if a value is present. Constexpr where possible. Alias for bool has_value() const noexcept .
Requires: Always available.
Complexity: Constant time.
Guarantees: Never throws an exception.</description>
    </item>
    
    <item>
      <title>`explicit operator bool() const noexcept`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_result/operator_bool/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_result/operator_bool/</guid>
      <description>Returns true if a value is present. Constexpr where possible. Alias for bool has_value() const noexcept .
Requires: Always available.
Complexity: Constant time.
Guarantees: Never throws an exception.</description>
    </item>
    
    <item>
      <title>`bool has_value() const noexcept`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_outcome/has_value/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_outcome/has_value/</guid>
      <description>Returns true if a value is present. Constexpr where possible. Alias for explicit operator bool() const noexcept .
Requires: Always available.
Complexity: Constant time.
Guarantees: Never throws an exception.</description>
    </item>
    
    <item>
      <title>`bool has_value() const noexcept`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_result/has_value/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_result/has_value/</guid>
      <description>Returns true if a value is present. Constexpr where possible. Alias for explicit operator bool() const noexcept .
Requires: Always available.
Complexity: Constant time.
Guarantees: Never throws an exception.</description>
    </item>
    
    <item>
      <title>`bool has_error() const noexcept`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_outcome/has_error/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_outcome/has_error/</guid>
      <description>Returns true if an error is present. Constexpr where possible.
Requires: Always available.
Complexity: Constant time.
Guarantees: Never throws an exception.</description>
    </item>
    
    <item>
      <title>`bool has_error() const noexcept`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_result/has_error/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_result/has_error/</guid>
      <description>Returns true if an error is present. Constexpr where possible.
Requires: Always available.
Complexity: Constant time.
Guarantees: Never throws an exception.</description>
    </item>
    
    <item>
      <title>`bool has_exception() const noexcept`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_outcome/has_exception/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_outcome/has_exception/</guid>
      <description>Returns true if an exception is present. Constexpr where possible.
Requires: Always available.
Complexity: Constant time.
Guarantees: Never throws an exception.</description>
    </item>
    
    <item>
      <title>`bool has_exception() const noexcept`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_result/has_exception/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_result/has_exception/</guid>
      <description>Always returns false for basic_result. Constexpr where possible.
Requires: Always available.
Complexity: Constant time.
Guarantees: Never throws an exception.</description>
    </item>
    
    <item>
      <title>`bool has_failure() const noexcept`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_outcome/has_failure/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_outcome/has_failure/</guid>
      <description>Returns true if there is either an error or an exception. Constexpr where possible.
Requires: Always available.
Complexity: Constant time.
Guarantees: Never throws an exception.</description>
    </item>
    
    <item>
      <title>`bool has_failure() const noexcept`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_result/has_failure/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_result/has_failure/</guid>
      <description>Returns true if there is either an error or an exception. Constexpr where possible.
Requires: Always available.
Complexity: Constant time.
Guarantees: Never throws an exception.</description>
    </item>
    
    <item>
      <title>`bool has_lost_consistency() const noexcept`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_result/has_lost_consistency/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_result/has_lost_consistency/</guid>
      <description>Returns true if a preceding swap involving this object failed to preserve the strong guarantee. Constexpr where possible.
Requires: Always available.
Complexity: Constant time.
Guarantees: Never throws an exception.</description>
    </item>
    
    <item>
      <title>`value_type &amp;assume_value() &amp; noexcept`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_outcome/assume_value_lvalue/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_outcome/assume_value_lvalue/</guid>
      <description>Narrow contract lvalue reference observer of any value present. NoValuePolicy::narrow_value_check() is first invoked, then the reference to the value is returned. The convention is that hard undefined behaviour occurs if no value is actually present, however NoValuePolicy::narrow_value_check() can do something to avoid that.
Note that if value_type is void, only a const overload returning void is present.
Requires: Always available.
Complexity: Depends on NoValuePolicy::narrow_value_check().
Guarantees: An exception is never thrown.</description>
    </item>
    
    <item>
      <title>`value_type &amp;assume_value() &amp; noexcept`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_result/assume_value_lvalue/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_result/assume_value_lvalue/</guid>
      <description>Narrow contract lvalue reference observer of any value present. NoValuePolicy::narrow_value_check() is first invoked, then the reference to the value is returned. The convention is that hard undefined behaviour occurs if no value is actually present, however NoValuePolicy::narrow_value_check() can do something to avoid that.
Note that if value_type is void, only a const overload returning void is present.
Requires: Always available.
Complexity: Depends on NoValuePolicy::narrow_value_check().
Guarantees: An exception is never thrown.</description>
    </item>
    
    <item>
      <title>`const value_type &amp;assume_value() const &amp; noexcept`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_outcome/assume_value_lvalue_const/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_outcome/assume_value_lvalue_const/</guid>
      <description>Narrow contract const lvalue reference observer of any value present. NoValuePolicy::narrow_value_check() is first invoked, then the reference to the value is returned. The convention is that hard undefined behaviour occurs if no value is actually present, however NoValuePolicy::narrow_value_check() can do something to avoid that.
Note that if value_type is void, only a const overload returning void is present.
Requires: Always available.
Complexity: Depends on NoValuePolicy::narrow_value_check().
Guarantees: An exception is never thrown.</description>
    </item>
    
    <item>
      <title>`const value_type &amp;assume_value() const &amp; noexcept`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_result/assume_value_lvalue_const/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_result/assume_value_lvalue_const/</guid>
      <description>Narrow contract const lvalue reference observer of any value present. NoValuePolicy::narrow_value_check() is first invoked, then the reference to the value is returned. The convention is that hard undefined behaviour occurs if no value is actually present, however NoValuePolicy::narrow_value_check() can do something to avoid that.
Note that if value_type is void, only a const overload returning void is present.
Requires: Always available.
Complexity: Depends on NoValuePolicy::narrow_value_check().
Guarantees: An exception is never thrown.</description>
    </item>
    
    <item>
      <title>`value_type &amp;&amp;assume_value() &amp;&amp; noexcept`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_outcome/assume_value_rvalue/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_outcome/assume_value_rvalue/</guid>
      <description>Narrow contract rvalue reference observer of any value present. NoValuePolicy::narrow_value_check() is first invoked, then the reference to the value is returned. The convention is that hard undefined behaviour occurs if no value is actually present, however NoValuePolicy::narrow_value_check() can do something to avoid that.
Note that if value_type is void, only a const overload returning void is present.
Requires: Always available.
Complexity: Depends on NoValuePolicy::narrow_value_check().
Guarantees: An exception is never thrown.</description>
    </item>
    
    <item>
      <title>`value_type &amp;&amp;assume_value() &amp;&amp; noexcept`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_result/assume_value_rvalue/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_result/assume_value_rvalue/</guid>
      <description>Narrow contract rvalue reference observer of any value present. NoValuePolicy::narrow_value_check() is first invoked, then the reference to the value is returned. The convention is that hard undefined behaviour occurs if no value is actually present, however NoValuePolicy::narrow_value_check() can do something to avoid that.
Note that if value_type is void, only a const overload returning void is present.
Requires: Always available.
Complexity: Depends on NoValuePolicy::narrow_value_check().
Guarantees: An exception is never thrown.</description>
    </item>
    
    <item>
      <title>`const value_type &amp;&amp;assume_value() const &amp;&amp; noexcept`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_outcome/assume_value_rvalue_const/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_outcome/assume_value_rvalue_const/</guid>
      <description>Narrow contract const rvalue reference observer of any value present. NoValuePolicy::narrow_value_check() is first invoked, then the reference to the value is returned. The convention is that hard undefined behaviour occurs if no value is actually present, however NoValuePolicy::narrow_value_check() can do something to avoid that.
Note that if value_type is void, only a const overload returning void is present.
Requires: Always available.
Complexity: Depends on NoValuePolicy::narrow_value_check().
Guarantees: An exception is never thrown.</description>
    </item>
    
    <item>
      <title>`const value_type &amp;&amp;assume_value() const &amp;&amp; noexcept`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_result/assume_value_rvalue_const/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_result/assume_value_rvalue_const/</guid>
      <description>Narrow contract const rvalue reference observer of any value present. NoValuePolicy::narrow_value_check() is first invoked, then the reference to the value is returned. The convention is that hard undefined behaviour occurs if no value is actually present, however NoValuePolicy::narrow_value_check() can do something to avoid that.
Note that if value_type is void, only a const overload returning void is present.
Requires: Always available.
Complexity: Depends on NoValuePolicy::narrow_value_check().
Guarantees: An exception is never thrown.</description>
    </item>
    
    <item>
      <title>`value_type &amp;value() &amp;`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_outcome/value_lvalue/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_outcome/value_lvalue/</guid>
      <description>Wide contract lvalue reference observer of any value present. NoValuePolicy::wide_value_check() is first invoked, then the reference to the value is returned.
Note that if value_type is void, only a const overload returning void is present.
Requires: Always available.
Complexity: Depends on NoValuePolicy::wide_value_check().
Guarantees: None.</description>
    </item>
    
    <item>
      <title>`value_type &amp;value() &amp;`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_result/value_lvalue/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_result/value_lvalue/</guid>
      <description>Wide contract lvalue reference observer of any value present. NoValuePolicy::wide_value_check() is first invoked, then the reference to the value is returned.
Note that if value_type is void, only a const overload returning void is present.
Requires: Always available.
Complexity: Depends on NoValuePolicy::wide_value_check().
Guarantees: None.</description>
    </item>
    
    <item>
      <title>`const value_type &amp;value() const &amp;`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_outcome/value_lvalue_const/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_outcome/value_lvalue_const/</guid>
      <description>Wide contract const lvalue reference observer of any value present. NoValuePolicy::wide_value_check() is first invoked, then the reference to the value is returned.
Note that if value_type is void, only a const overload returning void is present.
Requires: Always available.
Complexity: Depends on NoValuePolicy::wide_value_check().
Guarantees: None.</description>
    </item>
    
    <item>
      <title>`const value_type &amp;value() const &amp;`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_result/value_lvalue_const/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_result/value_lvalue_const/</guid>
      <description>Wide contract const lvalue reference observer of any value present. NoValuePolicy::wide_value_check() is first invoked, then the reference to the value is returned.
Note that if value_type is void, only a const overload returning void is present.
Requires: Always available.
Complexity: Depends on NoValuePolicy::wide_value_check().
Guarantees: None.</description>
    </item>
    
    <item>
      <title>`value_type &amp;&amp;value() &amp;&amp;`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_outcome/value_rvalue/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_outcome/value_rvalue/</guid>
      <description>Wide contract rvalue reference observer of any value present. NoValuePolicy::wide_value_check() is first invoked, then the reference to the value is returned.
Note that if value_type is void, only a const overload returning void is present.
Requires: Always available.
Complexity: Depends on NoValuePolicy::wide_value_check().
Guarantees: None.</description>
    </item>
    
    <item>
      <title>`value_type &amp;&amp;value() &amp;&amp;`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_result/value_rvalue/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_result/value_rvalue/</guid>
      <description>Wide contract rvalue reference observer of any value present. NoValuePolicy::wide_value_check() is first invoked, then the reference to the value is returned.
Note that if value_type is void, only a const overload returning void is present.
Requires: Always available.
Complexity: Depends on NoValuePolicy::wide_value_check().
Guarantees: None.</description>
    </item>
    
    <item>
      <title>`const value_type &amp;&amp;value() const &amp;&amp;`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_outcome/value_rvalue_const/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_outcome/value_rvalue_const/</guid>
      <description>Wide contract const rvalue reference observer of any value present. NoValuePolicy::wide_value_check() is first invoked, then the reference to the value is returned.
Note that if value_type is void, only a const overload returning void is present.
Requires: Always available.
Complexity: Depends on NoValuePolicy::wide_value_check().
Guarantees: None.</description>
    </item>
    
    <item>
      <title>`const value_type &amp;&amp;value() const &amp;&amp;`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_result/value_rvalue_const/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_result/value_rvalue_const/</guid>
      <description>Wide contract const rvalue reference observer of any value present. NoValuePolicy::wide_value_check() is first invoked, then the reference to the value is returned.
Note that if value_type is void, only a const overload returning void is present.
Requires: Always available.
Complexity: Depends on NoValuePolicy::wide_value_check().
Guarantees: None.</description>
    </item>
    
    <item>
      <title>`error_type &amp;assume_error() &amp; noexcept`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_outcome/assume_error_lvalue/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_outcome/assume_error_lvalue/</guid>
      <description>Narrow contract lvalue reference observer of the stored error. NoValuePolicy::narrow_error_check() is first invoked, then the reference to the error is returned. As a valid default constructed error is always present, no undefined behaviour occurs unless NoValuePolicy::narrow_error_check() does that.
Note that if error_type is void, only a const overload returning void is present.
Requires: Always available.
Complexity: Depends on NoValuePolicy::narrow_error_check().
Guarantees: An exception is never thrown.</description>
    </item>
    
    <item>
      <title>`error_type &amp;assume_error() &amp; noexcept`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_result/assume_error_lvalue/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_result/assume_error_lvalue/</guid>
      <description>Narrow contract lvalue reference observer of the stored error. NoValuePolicy::narrow_error_check() is first invoked, then the reference to the error is returned. As a valid default constructed error is always present, no undefined behaviour occurs unless NoValuePolicy::narrow_error_check() does that.
Note that if error_type is void, only a const overload returning void is present.
Requires: Always available.
Complexity: Depends on NoValuePolicy::narrow_error_check().
Guarantees: An exception is never thrown.</description>
    </item>
    
    <item>
      <title>`const error_type &amp;assume_error() const &amp; noexcept`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_outcome/assume_error_lvalue_const/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_outcome/assume_error_lvalue_const/</guid>
      <description>Narrow contract const lvalue reference observer of the stored error. NoValuePolicy::narrow_error_check() is first invoked, then the reference to the error is returned. As a valid default constructed error is always present, no undefined behaviour occurs unless NoValuePolicy::narrow_error_check() does that.
Note that if error_type is void, only a const overload returning void is present.
Requires: Always available.
Complexity: Depends on NoValuePolicy::narrow_error_check().
Guarantees: An exception is never thrown.</description>
    </item>
    
    <item>
      <title>`const error_type &amp;assume_error() const &amp; noexcept`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_result/assume_error_lvalue_const/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_result/assume_error_lvalue_const/</guid>
      <description>Narrow contract const lvalue reference observer of the stored error. NoValuePolicy::narrow_error_check() is first invoked, then the reference to the error is returned. As a valid default constructed error is always present, no undefined behaviour occurs unless NoValuePolicy::narrow_error_check() does that.
Note that if error_type is void, only a const overload returning void is present.
Requires: Always available.
Complexity: Depends on NoValuePolicy::narrow_error_check().
Guarantees: An exception is never thrown.</description>
    </item>
    
    <item>
      <title>`error_type &amp;&amp;assume_error() &amp;&amp; noexcept`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_outcome/assume_error_rvalue/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_outcome/assume_error_rvalue/</guid>
      <description>Narrow contract rvalue reference observer of the stored error. NoValuePolicy::narrow_error_check() is first invoked, then the reference to the error is returned. As a valid default constructed error is always present, no undefined behaviour occurs unless NoValuePolicy::narrow_error_check() does that.
Note that if error_type is void, only a const overload returning void is present.
Requires: Always available.
Complexity: Depends on NoValuePolicy::narrow_error_check().
Guarantees: An exception is never thrown.</description>
    </item>
    
    <item>
      <title>`error_type &amp;&amp;assume_error() &amp;&amp; noexcept`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_result/assume_error_rvalue/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_result/assume_error_rvalue/</guid>
      <description>Narrow contract rvalue reference observer of the stored error. NoValuePolicy::narrow_error_check() is first invoked, then the reference to the error is returned. As a valid default constructed error is always present, no undefined behaviour occurs unless NoValuePolicy::narrow_error_check() does that.
Note that if error_type is void, only a const overload returning void is present.
Requires: Always available.
Complexity: Depends on NoValuePolicy::narrow_error_check().
Guarantees: An exception is never thrown.</description>
    </item>
    
    <item>
      <title>`const error_type &amp;&amp;assume_error() const &amp;&amp; noexcept`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_outcome/assume_error_rvalue_const/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_outcome/assume_error_rvalue_const/</guid>
      <description>Narrow contract const rvalue reference observer of the stored error. NoValuePolicy::narrow_error_check() is first invoked, then the reference to the error is returned. As a valid default constructed error is always present, no undefined behaviour occurs unless NoValuePolicy::narrow_error_check() does that.
Note that if error_type is void, only a const overload returning void is present.
Requires: Always available.
Complexity: Depends on NoValuePolicy::narrow_error_check().
Guarantees: An exception is never thrown.</description>
    </item>
    
    <item>
      <title>`const error_type &amp;&amp;assume_error() const &amp;&amp; noexcept`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_result/assume_error_rvalue_const/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_result/assume_error_rvalue_const/</guid>
      <description>Narrow contract const rvalue reference observer of the stored error. NoValuePolicy::narrow_error_check() is first invoked, then the reference to the error is returned. As a valid default constructed error is always present, no undefined behaviour occurs unless NoValuePolicy::narrow_error_check() does that.
Note that if error_type is void, only a const overload returning void is present.
Requires: Always available.
Complexity: Depends on NoValuePolicy::narrow_error_check().
Guarantees: An exception is never thrown.</description>
    </item>
    
    <item>
      <title>`error_type &amp;error() &amp;`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_outcome/error_lvalue/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_outcome/error_lvalue/</guid>
      <description>Wide contract lvalue reference observer of the stored error. NoValuePolicy::wide_error_check() is first invoked, then the reference to the error is returned. As a valid default constructed error is always present, no undefined behaviour occurs if NoValuePolicy::wide_error_check() returns.
Note that if error_type is void, only a const overload returning void is present.
Requires: Always available.
Complexity: Depends on NoValuePolicy::wide_error_check().
Guarantees: None.</description>
    </item>
    
    <item>
      <title>`error_type &amp;error() &amp;`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_result/error_lvalue/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_result/error_lvalue/</guid>
      <description>Wide contract lvalue reference observer of the stored error. NoValuePolicy::wide_error_check() is first invoked, then the reference to the error is returned. As a valid default constructed error is always present, no undefined behaviour occurs if NoValuePolicy::wide_error_check() returns.
Note that if error_type is void, only a const overload returning void is present.
Requires: Always available.
Complexity: Depends on NoValuePolicy::wide_error_check().
Guarantees: None.</description>
    </item>
    
    <item>
      <title>`const error_type &amp;error() const &amp;`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_outcome/error_lvalue_const/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_outcome/error_lvalue_const/</guid>
      <description>Wide contract const lvalue reference observer of the stored error. NoValuePolicy::wide_error_check() is first invoked, then the reference to the error is returned. As a valid default constructed error is always present, no undefined behaviour occurs if NoValuePolicy::wide_error_check() returns.
Note that if error_type is void, only a const overload returning void is present.
Requires: Always available.
Complexity: Depends on NoValuePolicy::wide_error_check().
Guarantees: None.</description>
    </item>
    
    <item>
      <title>`const error_type &amp;error() const &amp;`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_result/error_lvalue_const/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_result/error_lvalue_const/</guid>
      <description>Wide contract const lvalue reference observer of the stored error. NoValuePolicy::wide_error_check() is first invoked, then the reference to the error is returned. As a valid default constructed error is always present, no undefined behaviour occurs if NoValuePolicy::wide_error_check() returns.
Note that if error_type is void, only a const overload returning void is present.
Requires: Always available.
Complexity: Depends on NoValuePolicy::wide_error_check().
Guarantees: None.</description>
    </item>
    
    <item>
      <title>`error_type &amp;&amp;error() &amp;&amp;`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_outcome/error_rvalue/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_outcome/error_rvalue/</guid>
      <description>Wide contract rvalue reference observer of the stored error. NoValuePolicy::wide_error_check() is first invoked, then the reference to the error is returned. As a valid default constructed error is always present, no undefined behaviour occurs if NoValuePolicy::wide_error_check() returns.
Note that if error_type is void, only a const overload returning void is present.
Requires: Always available.
Complexity: Depends on NoValuePolicy::wide_error_check().
Guarantees: None.</description>
    </item>
    
    <item>
      <title>`error_type &amp;&amp;error() &amp;&amp;`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_result/error_rvalue/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_result/error_rvalue/</guid>
      <description>Wide contract rvalue reference observer of the stored error. NoValuePolicy::wide_error_check() is first invoked, then the reference to the error is returned. As a valid default constructed error is always present, no undefined behaviour occurs if NoValuePolicy::wide_error_check() returns.
Note that if error_type is void, only a const overload returning void is present.
Requires: Always available.
Complexity: Depends on NoValuePolicy::wide_error_check().
Guarantees: None.</description>
    </item>
    
    <item>
      <title>`const error_type &amp;&amp;error() const &amp;&amp;`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_outcome/error_rvalue_const/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_outcome/error_rvalue_const/</guid>
      <description>Wide contract const rvalue reference observer of the stored error. NoValuePolicy::wide_error_check() is first invoked, then the reference to the error is returned. As a valid default constructed error is always present, no undefined behaviour occurs if NoValuePolicy::wide_error_check() returns.
Note that if error_type is void, only a const overload returning void is present.
Requires: Always available.
Complexity: Depends on NoValuePolicy::wide_error_check().
Guarantees: None.</description>
    </item>
    
    <item>
      <title>`const error_type &amp;&amp;error() const &amp;&amp;`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_result/error_rvalue_const/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_result/error_rvalue_const/</guid>
      <description>Wide contract const rvalue reference observer of the stored error. NoValuePolicy::wide_error_check() is first invoked, then the reference to the error is returned. As a valid default constructed error is always present, no undefined behaviour occurs if NoValuePolicy::wide_error_check() returns.
Note that if error_type is void, only a const overload returning void is present.
Requires: Always available.
Complexity: Depends on NoValuePolicy::wide_error_check().
Guarantees: None.</description>
    </item>
    
    <item>
      <title>`exception_type &amp;assume_exception() &amp; noexcept`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_outcome/assume_exception_lvalue/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_outcome/assume_exception_lvalue/</guid>
      <description>Narrow contract lvalue reference observer of the stored exception. NoValuePolicy::narrow_exception_check() is first invoked, then the reference to the exception is returned. As a valid default constructed exception is always present, no undefined behaviour occurs unless NoValuePolicy::narrow_exception_check() does that.
Note that if exception_type is void, only a const overload returning void is present.
Requires: Always available.
Complexity: Depends on NoValuePolicy::narrow_exception_check().
Guarantees: An exception is never thrown.</description>
    </item>
    
    <item>
      <title>`const exception_type &amp;assume_exception() const &amp; noexcept`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_outcome/assume_exception_lvalue_const/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_outcome/assume_exception_lvalue_const/</guid>
      <description>Narrow contract const lvalue reference observer of the stored exception. NoValuePolicy::narrow_exception_check() is first invoked, then the reference to the exception is returned. As a valid default constructed exception is always present, no undefined behaviour occurs unless NoValuePolicy::narrow_exception_check() does that.
Note that if exception_type is void, only a const overload returning void is present.
Requires: Always available.
Complexity: Depends on NoValuePolicy::narrow_exception_check().
Guarantees: An exception is never thrown.</description>
    </item>
    
    <item>
      <title>`const exception_type &amp;&amp;assume_exception() const &amp;&amp; noexcept`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_outcome/assume_exception_rvalue_const/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_outcome/assume_exception_rvalue_const/</guid>
      <description>Narrow contract const rvalue reference observer of the stored exception. NoValuePolicy::narrow_exception_check() is first invoked, then the reference to the exception is returned. As a valid default constructed exception is always present, no undefined behaviour occurs unless NoValuePolicy::narrow_exception_check() does that.
Note that if exception_type is void, only a const overload returning void is present.
Requires: Always available.
Complexity: Depends on NoValuePolicy::narrow_exception_check().
Guarantees: An exception is never thrown.</description>
    </item>
    
    <item>
      <title>`exception_type &amp;&amp;assume_exception() &amp;&amp; noexcept`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_outcome/assume_exception_rvalue/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_outcome/assume_exception_rvalue/</guid>
      <description>Narrow contract rvalue reference observer of the stored exception. NoValuePolicy::narrow_exception_check() is first invoked, then the reference to the exception is returned. As a valid default constructed exception is always present, no undefined behaviour occurs unless NoValuePolicy::narrow_exception_check() does that.
Note that if exception_type is void, only a const overload returning void is present.
Requires: Always available.
Complexity: Depends on NoValuePolicy::narrow_exception_check().
Guarantees: An exception is never thrown.</description>
    </item>
    
    <item>
      <title>`exception_type &amp;exception() &amp;`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_outcome/exception_lvalue/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_outcome/exception_lvalue/</guid>
      <description>Wide contract lvalue reference observer of the stored exception. NoValuePolicy::wide_exception_check() is first invoked, then the reference to the exception is returned. As a valid default constructed exception is always present, no undefined behaviour occurs if NoValuePolicy::wide_exception_check() returns.
Note that if exception_type is void, only a const overload returning void is present.
Requires: Always available.
Complexity: Depends on NoValuePolicy::wide_exception_check().
Guarantees: None.</description>
    </item>
    
    <item>
      <title>`const exception_type &amp;exception() const &amp;`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_outcome/exception_lvalue_const/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_outcome/exception_lvalue_const/</guid>
      <description>Wide contract const lvalue reference observer of the stored exception. NoValuePolicy::wide_exception_check() is first invoked, then the reference to the exception is returned. As a valid default constructed exception is always present, no undefined behaviour occurs if NoValuePolicy::wide_exception_check() returns.
Note that if exception_type is void, only a const overload returning void is present.
Requires: Always available.
Complexity: Depends on NoValuePolicy::wide_exception_check().
Guarantees: None.</description>
    </item>
    
    <item>
      <title>`exception_type &amp;&amp;exception() &amp;&amp;`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_outcome/exception_rvalue/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_outcome/exception_rvalue/</guid>
      <description>Wide contract rvalue reference observer of the stored exception. NoValuePolicy::wide_exception_check() is first invoked, then the reference to the exception is returned. As a valid default constructed exception is always present, no undefined behaviour occurs if NoValuePolicy::wide_exception_check() returns.
Note that if exception_type is void, only a const overload returning void is present.
Requires: Always available.
Complexity: Depends on NoValuePolicy::wide_exception_check().
Guarantees: None.</description>
    </item>
    
    <item>
      <title>`const exception_type &amp;&amp;exception() const &amp;&amp;`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_outcome/exception_rvalue_const/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_outcome/exception_rvalue_const/</guid>
      <description>Wide contract const rvalue reference observer of the stored exception. NoValuePolicy::wide_exception_check() is first invoked, then the reference to the exception is returned. As a valid default constructed exception is always present, no undefined behaviour occurs if NoValuePolicy::wide_exception_check() returns.
Note that if exception_type is void, only a const overload returning void is present.
Requires: Always available.
Complexity: Depends on NoValuePolicy::wide_exception_check().
Guarantees: None.</description>
    </item>
    
    <item>
      <title>`exception_type failure() const noexcept`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_outcome/failure/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_outcome/failure/</guid>
      <description>Synthesising observer of the stored exception or error. If an exception is available, returns a copy of that directly. If an error is available, and not an exception, an ADL discovered free function auto basic_outcome_failure_exception_from_error(const EC &amp;amp;) is invoked. Default overloads for this function are defined in Outcome for  std::error_code and boost::system::error_code, these return std::make_exception_ptr(std::system_error(ec)) and boost::copy_exception(boost::system::system_error(ec)) respectively.
Requires: Both the traits is_error_code_available&amp;lt;T&amp;gt; and is_exception_ptr_available&amp;lt;T&amp;gt; are true.
Complexity: Depends on basic_outcome_failure_exception_from_error(const EC &amp;amp;).</description>
    </item>
    
    <item>
      <title>`bool operator==(const basic_result&lt;A, B, C&gt; &amp;) const`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_outcome/equality_basic_result/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_outcome/equality_basic_result/</guid>
      <description>Returns true if this outcome compares equal to the other result. Comparison is done using operator== on value_type or error_type if the currently chosen state is the same for both outcome and result, otherwise false is returned. Note that if the outcome is excepted, it will never compare equal to a result.
Requires: operator== must be a valid expression between value_type and A, and between error_type and B. If value_type is void, then so must be A; similarly for error_type and B.</description>
    </item>
    
    <item>
      <title>`bool operator==(const basic_result&lt;A, B, C&gt; &amp;) const`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_result/equality_basic_result/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_result/equality_basic_result/</guid>
      <description>Returns true if this result compares equal to the other result. Comparison is done using operator== on either value_type or error_type if the currently chosen state is the same for both results, otherwise false is returned.
Requires: operator== must be a valid expression between value_type and A, and between error_type and B. If value_type is void, then so must be A; similarly for error_type and B.
Complexity: Whatever the underlying operator== have.</description>
    </item>
    
    <item>
      <title>`bool operator==(const basic_outcome&lt;A, B, C, D&gt; &amp;) const`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_outcome/equality_basic_outcome/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_outcome/equality_basic_outcome/</guid>
      <description>Returns true if this outcome compares equal to the other outcome. Comparison is done using operator== on value_type or error_type and/or exception_type if the currently chosen state is the same for both outcomes, otherwise false is returned.
Requires: operator== must be a valid expression between value_type and A, and between error_type and B, and between exception_type and C. If value_type is void, then so must be A; similarly for error_type and B; similarly for exception_type and C.</description>
    </item>
    
    <item>
      <title>`bool operator==(const success_type&lt;A&gt; &amp;) const`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_outcome/inequality_success_type/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_outcome/inequality_success_type/</guid>
      <description>Returns true if this result is successful and its value compares equal to the value in the success type sugar. Comparison is done using operator== on value_type and A. If A is void, this call aliases bool has_value() const noexcept .
Requires: operator== must be a valid expression between value_type and A, or A is void. If value_type is void, then so must be A.
Complexity: Whatever the underlying operator== has.</description>
    </item>
    
    <item>
      <title>`bool operator==(const success_type&lt;A&gt; &amp;) const`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_result/inequality_success_type/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_result/inequality_success_type/</guid>
      <description>Returns true if this result is successful and its value compares equal to the value in the success type sugar. Comparison is done using operator== on value_type and A. If A is void, this call aliases bool has_value() const noexcept .
Requires: operator== must be a valid expression between value_type and A, or A is void. If value_type is void, then so must be A.
Complexity: Whatever the underlying operator== has.</description>
    </item>
    
    <item>
      <title>`bool operator==(const failure_type&lt;A, B&gt; &amp;) const`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_outcome/equality_failure_type/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_outcome/equality_failure_type/</guid>
      <description>Returns true if this outcome is unsuccessful and its error compares equal to the error in the failure type sugar. Comparison is done using operator== on error_type and A and on exception_type and B.
Requires: operator== must be a valid expression between error_type and A, or A is void; operator== must be a valid expression between exception_type and B, or B is void. If error_type is void, then so must be A; if exception_type is void, then so must be B.</description>
    </item>
    
    <item>
      <title>`bool operator==(const failure_type&lt;A, void&gt; &amp;) const`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_result/equality_failure_type/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_result/equality_failure_type/</guid>
      <description>Returns true if this result is unsuccessful and its error compares equal to the error in the failure type sugar. Comparison is done using operator== on error_type and A. If A is void, this call aliases bool has_error() const noexcept .
Requires: operator== must be a valid expression between error_type and A, or A is void. If error_type is void, then so must be A.
Complexity: Whatever the underlying operator== has.</description>
    </item>
    
    <item>
      <title>`bool operator!=(const basic_result&lt;A, B, C&gt; &amp;) const`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_result/inequality_basic_result/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_result/inequality_basic_result/</guid>
      <description>Returns true if this result does not compare equal to the other result. Comparison is done using operator!= on either value_type or error_type if the currently chosen state is the same for both results, otherwise true is returned.
Requires: operator!= must be a valid expression between value_type and A, and between error_type and B. If value_type is void, then so must be A; similarly for error_type and B.
Complexity: Whatever the underlying operator!</description>
    </item>
    
    <item>
      <title>`bool operator!=(const basic_result&lt;A, B, C&gt; &amp;) const`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_outcome/inequality_basic_result/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_outcome/inequality_basic_result/</guid>
      <description>Returns true if this outcome does not compare equal to the other result. Comparison is done using operator!= on value_type or error_type if the currently chosen state is the same for both outcome and result, otherwise true is returned. Note that an excepted outcome is always unequal to a result.
Requires: operator!= must be a valid expression between value_type and A, and between error_type and B. If value_type is void, then so must be A; similarly for error_type and B.</description>
    </item>
    
    <item>
      <title>`bool operator!=(const basic_outcome&lt;A, B, C, D&gt; &amp;) const`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_outcome/inequality_basic_outcome/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_outcome/inequality_basic_outcome/</guid>
      <description>Returns true if this outcome does not compare equal to the other outcome. Comparison is done using operator!= on value_type, error_type and/or exception_type if the currently chosen state is the same for both outcomes, otherwise true is returned.
Requires: operator!= must be a valid expression between value_type and A, and between error_type and B, and between exception_type and C. If value_type is void, then so must be A; similarly for error_type and B; similarly for exception_type and C.</description>
    </item>
    
    <item>
      <title>`bool operator!=(const success_type&lt;A&gt; &amp;) const`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_outcome/equality_success_type/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_outcome/equality_success_type/</guid>
      <description>Returns true if this outcome is not successful or its value does not compares equal to the value in the success type sugar. Comparison is done using operator!= on value_type and A. If A is void, this call aliases bool has_error() const noexcept .
Requires: operator!= must be a valid expression between value_type and A, or A is void. If value_type is void, then so must be A.
Complexity: Whatever the underlying operator!</description>
    </item>
    
    <item>
      <title>`bool operator!=(const success_type&lt;A&gt; &amp;) const`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_result/equality_success_type/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_result/equality_success_type/</guid>
      <description>Returns true if this result is not successful or its value does not compares equal to the value in the success type sugar. Comparison is done using operator!= on value_type and A. If A is void, this call aliases bool has_error() const noexcept .
Requires: operator!= must be a valid expression between value_type and A, or A is void. If value_type is void, then so must be A.
Complexity: Whatever the underlying operator!</description>
    </item>
    
    <item>
      <title>`bool operator!=(const failure_type&lt;A, B&gt; &amp;) const`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_outcome/inequality_failure_type/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_outcome/inequality_failure_type/</guid>
      <description>Returns true if this outcome is successful or its error or exception does not compare equal to the error in the failure type sugar. Comparison is done using operator!= on error_type and A and on exception_type and B.
Requires: operator!= must be a valid expression between error_type and A, or A is void; operator!= must be a valid expression between exception_type and B, or B is void. If error_type is void, then so must be A; if exception_type is void, then so must be B.</description>
    </item>
    
    <item>
      <title>`bool operator!=(const failure_type&lt;A, void&gt; &amp;) const`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_result/inequality_failure_type/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_result/inequality_failure_type/</guid>
      <description>Returns true if this result is successful or its error does not compare equal to the error in the failure type sugar. Comparison is done using operator!= on error_type and A. If A is void, this call aliases bool has_value() const noexcept .
Requires: operator!= must be a valid expression between error_type and A, or A is void. If error_type is void, then so must be A.
Complexity: Whatever the underlying operator!</description>
    </item>
    
    <item>
      <title>`void swap(basic_outcome &amp;)`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_outcome/swap/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_outcome/swap/</guid>
      <description>Swap one basic_outcome with another, with the strong guarantee. Constexpr if move constructors and move assignments of value_type, error_type and exception_type are noexcept.
Requires: Always available.
Complexity: If the move constructor and move assignment for value_type, error_type and exception_type are noexcept, the complexity is the same as for the swap() implementations of the value_type, error_type and exception_type. Otherwise, complexity is not preserved, as strong_swap(bool &amp;amp;all_good, T &amp;amp;a, T &amp;amp;b) is used instead of swap().</description>
    </item>
    
    <item>
      <title>`void swap(basic_result &amp;)`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_result/swap/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_result/swap/</guid>
      <description>Swap one basic_result with another, with the strong guarantee. Constexpr if move constructors and move assignments of value_type and error_type are noexcept.
Requires: Always available.
Complexity: If the move constructor and move assignment for value_type and error_type are noexcept, the complexity is the same as for the swap() implementations of the value_type and error_type. Otherwise, complexity is not preserved, as strong_swap(bool &amp;amp;all_good, T &amp;amp;a, T &amp;amp;b) is used instead of swap().</description>
    </item>
    
    <item>
      <title>`auto as_failure() const &amp;`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_result/as_failure_lvalue/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_result/as_failure_lvalue/</guid>
      <description>Return the output from free function auto failure(T &amp;amp;&amp;amp;, ...) containing a copy of any errored state. The error state is accessed using const error_type &amp;amp;assume_error() const &amp;amp; noexcept .
Requires: Always available.
Complexity: Whatever that of error_type&amp;rsquo;s copy constructor is.
Guarantees: None.</description>
    </item>
    
    <item>
      <title>`failure_type&lt;error_type, exception_type&gt; as_failure() const &amp;`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_outcome/as_failure_lvalue/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_outcome/as_failure_lvalue/</guid>
      <description>Return the output from free function auto failure(T &amp;amp;&amp;amp;, ...) containing a copy of any errored and/or excepted state. The error and/or exception state is accessed using const error_type &amp;amp;assume_error() const &amp;amp; noexcept and const exception_type &amp;amp;assume_exception() const &amp;amp; noexcept .
Requires: Always available.
Complexity: Whatever that of error_type&amp;rsquo;s and/or exception_type&amp;rsquo;s copy constructor is.
Guarantees: None.</description>
    </item>
    
    <item>
      <title>`auto as_failure() &amp;&amp;`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_result/as_failure_rvalue/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_result/as_failure_rvalue/</guid>
      <description>Return the output from free function auto failure(T &amp;amp;&amp;amp;, ...) containing a move from any errored state, thus leaving the result&amp;rsquo;s error value in a moved-from state. Depending on the choice of error_type, this function may therefore be destructive. The error state is accessed using error_type &amp;amp;&amp;amp;assume_error() &amp;amp;&amp;amp; noexcept .
Requires: Always available.
Complexity: Whatever that of error_type&amp;rsquo;s move constructor is.
Guarantees: None.</description>
    </item>
    
    <item>
      <title>`failure_type&lt;error_type, exception_type&gt; as_failure() &amp;&amp;`</title>
      <link>https://ned14.github.io/outcome/reference/types/basic_outcome/as_failure_rvalue/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/basic_outcome/as_failure_rvalue/</guid>
      <description>Return the output from free function auto failure(T &amp;amp;&amp;amp;, ...) containing a move from any errored and/or excepted state, thus leaving the outcome&amp;rsquo;s error and exception values in a moved-from state. Depending on the choice of error_type and/or exception_type, this function may therefore be destructive. The error and exception states are accessed using error_type &amp;amp;&amp;amp;assume_error() &amp;amp;&amp;amp; noexcept and exception_type &amp;amp;&amp;amp;assume_exception() &amp;amp;&amp;amp; noexcept .
Requires: Always available.
Complexity: Whatever that of error_type&amp;rsquo;s and/or exception_type&amp;rsquo;s move constructor is.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://ned14.github.io/outcome/_footer/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/_footer/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://ned14.github.io/outcome/_header/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/_header/</guid>
      <description>Outcome 2.2 library documentation</description>
    </item>
    
    <item>
      <title>ASIO/Networking TS : Boost &lt; 1.70</title>
      <link>https://ned14.github.io/outcome/recipes/asio-integration/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/recipes/asio-integration/</guid>
      <description>Thanks to Christos Stratopoulos for this Outcome recipe.
Compatibility note This recipe targets Boost versions before 1.70, where coroutine support is based around the asio::experimental::this_coro::token completion token. For integration with Boost versions 1.70 and onward, see this recipe.
Use case Boost.ASIO and standalone ASIO provide the async_result customisation point for adapting arbitrary third party libraries, such as Outcome, into ASIO.
Historically in ASIO you need to pass completion handler instances to the ASIO asynchronous i/o initiation functions.</description>
    </item>
    
    <item>
      <title>ASIO/Networking TS: Boost &gt;= 1.70</title>
      <link>https://ned14.github.io/outcome/recipes/asio-integration-1-70/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/recipes/asio-integration-1-70/</guid>
      <description>Thanks to Christos Stratopoulos for this Outcome recipe.
Compatibility note This recipe targets Boost versions including and after 1.70, where coroutine support is based around the asio::use_awaitable completion token. For integration with Boost versions before 1.70, see this recipe.
Use case Boost.ASIO and standalone ASIO provide the async_result customisation point for adapting arbitrary third party libraries, such as Outcome, into ASIO.
Historically in ASIO you need to pass completion handler instances to the ASIO asynchronous i/o initiation functions.</description>
    </item>
    
    <item>
      <title>Acknowledgements</title>
      <link>https://ned14.github.io/outcome/credits/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/credits/</guid>
      <description>github contributors .ghContributors{ display:flex; flex-flow: wrap; align-content: flex-start } .ghContributors  div{ width: 50% ; display: inline-flex; margin-bottom: 5px; } .ghContributors  div label{ padding-left: 4px ; } .ghContributors  div span{ font-size: x-small; padding-left: 4px ; }   @ned14 1531 commits   @akrzemi1 45 commits   @cstratopoulos 9 commits   @hazelnusse 7 commits   @BurningEnlightenment 7 commits   @libbooze 2 commits   @johnthagen 2 commits   @menuet 2 commits   @amerry 1 commits   @ecatmur 1 commits   @gix 1 commits   @norbertwenzel 1 commits   @vinipsmaker 1 commits   @alandefreitas 1 commits   @andoks 1 commits   @catskul 1 commits   @hyeongyukim 1 commits   @jenkins-nedprod 1 commits   @sdarwin 1 commits   This pretty, modern C++ documentation  Hugo - static website generator of this documentation.</description>
    </item>
    
    <item>
      <title>Constrained template macros</title>
      <link>https://ned14.github.io/outcome/reference/macros/template/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/macros/template/</guid>
      <description>Overridable: All of the following macros are overridable, define before inclusion.
Header: &amp;lt;outcome/config.hpp&amp;gt;
These macros expand into either the syntax for directly specifying constrained templates in C++ 20, or into a SFINAE based emulation for earlier C++ versions. Form of usage looks as follows:
OUTCOME_TEMPLATE(classErrorCondEnum) OUTCOME_TREQUIRES( // If this is a valid expression  OUTCOME_TEXPR(error_type(make_error_code(ErrorCondEnum()))), // If this predicate is true  OUTCOME_TPRED(predicate::template enable_error_condition_converting_constructor&amp;lt;ErrorCondEnum&amp;gt;) // Any additional requirements follow here .</description>
    </item>
    
    <item>
      <title>Extending `OUTCOME_TRY`</title>
      <link>https://ned14.github.io/outcome/recipes/foreign-try/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/recipes/foreign-try/</guid>
      <description>Outcome&amp;rsquo;s OUTCOME_TRY(var, expr) operation is fully extensible to accept as input any foreign types. It already recognises types matching the concepts::value_or_error&amp;lt;T, E&amp;gt; concept, which is to say all types which have:
 A public .has_value() member function which returns a bool. In order of preference, a public .assume_value()/.value() member function. In order of preference, a public .as_failure()/.assume_error()/.error() member function.  This should automatically handle inputs of std::expected&amp;lt;T, E&amp;gt;, and many others, including intermixing Boost.</description>
    </item>
    
    <item>
      <title>Rust FFI</title>
      <link>https://ned14.github.io/outcome/recipes/rust/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/recipes/rust/</guid>
      <description>A nice side effect of Outcome.Experimental&amp;rsquo;s excellent C support is that teaching Rust about Outcome&amp;rsquo;s result&amp;lt;T&amp;gt; becomes trivially easy. C and C++ results propagate losslessly into Rust Results, and the full power of the Outcome C API is available to Rust code for semantic equivalence comparison et al.
Here&amp;rsquo;s a quick snippet to get you started. This assumes that you have declared your C result using CXX_DECLARE_RESULT_SYSTEM(outcome, intptr_t) in order to produce a C result named &amp;ldquo;outcome&amp;rdquo; compatible with an erased system code C++ result:</description>
    </item>
    
    <item>
      <title>Version macros</title>
      <link>https://ned14.github.io/outcome/reference/macros/version/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/macros/version/</guid>
      <description>Overridable: None of the following macros are overridable.
Header: &amp;lt;outcome/config.hpp&amp;gt;
 OUTCOME_VERSION_MAJOR &amp;lt;number&amp;gt;
Major version for cmake and DLL version stamping.
 OUTCOME_VERSION_MINOR &amp;lt;number&amp;gt;
Minor version for cmake and DLL version stamping.
 OUTCOME_VERSION_PATCH &amp;lt;number&amp;gt;
Patch version for cmake and DLL version stamping.
 OUTCOME_VERSION_REVISION &amp;lt;number&amp;gt;
Revision version for cmake and DLL version stamping.
 OUTCOME_UNSTABLE_VERSION &amp;lt;number&amp;gt;
Defined between stable releases of Outcome. It means the inline namespace will be permuted per-commit to ensure ABI uniqueness such that multiple versions of Outcome in a single process space cannot collide.</description>
    </item>
    
    <item>
      <title>`OUTCOME_CO_TRY(var, expr)`</title>
      <link>https://ned14.github.io/outcome/reference/macros/co_try/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/macros/co_try/</guid>
      <description>Evaluate within a coroutine an expression which results in a type matching the following customisation points, assigning T to a decl called var if successful, immediately returning try_operation_return_as(X) from the calling function if unsuccessful:
 OUTCOME_V2_NAMESPACE::try_operation_has_value(X)  OUTCOME_V2_NAMESPACE::try_operation_return_as(X)  OUTCOME_V2_NAMESPACE::try_operation_extract_value(X)   Default overloads for these customisation points are provided. See the recipe for supporting foreign input to OUTCOME_TRY.
Hints are given to the compiler that the expression will be successful.</description>
    </item>
    
    <item>
      <title>`OUTCOME_CO_TRYV(expr)/OUTCOME_CO_TRY(expr)`</title>
      <link>https://ned14.github.io/outcome/reference/macros/co_tryv/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/macros/co_tryv/</guid>
      <description>Evaluate from within a coroutine an expression which results in a type matching the following customisation points, continuing execution if successful, immediately returning try_operation_return_as(X) from the calling function if unsuccessful:
 OUTCOME_V2_NAMESPACE::try_operation_has_value(X)  OUTCOME_V2_NAMESPACE::try_operation_return_as(X)  OUTCOME_V2_NAMESPACE::try_operation_extract_value(X)   Default overloads for these customisation points are provided. See the recipe for supporting foreign input to OUTCOME_TRY.
The difference between the OUTCOME_CO_TRYV(expr) and OUTCOME_CO_TRY(expr) editions is that the latter will set a variable if two or more macro arguments are present (see OUTCOME_CO_TRY(var, expr) ).</description>
    </item>
    
    <item>
      <title>`OUTCOME_CO_TRYV2(spec, expr)`</title>
      <link>https://ned14.github.io/outcome/reference/macros/co_tryv2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/macros/co_tryv2/</guid>
      <description>Evaluate an expression which results in a type matching the following customisation points, continuing execution if successful, immediately returning try_operation_return_as(X) from the calling function if unsuccessful:
 OUTCOME_V2_NAMESPACE::try_operation_has_value(X)  OUTCOME_V2_NAMESPACE::try_operation_return_as(X)  OUTCOME_V2_NAMESPACE::try_operation_extract_value(X)   Default overloads for these customisation points are provided. See the recipe for supporting foreign input to OUTCOME_TRY.
Hints are given to the compiler that the expression will be successful. If you expect failure, you should use OUTCOME_TRYV2_FAILURE_LIKELY(spec, expr) instead.</description>
    </item>
    
    <item>
      <title>`OUTCOME_CO_TRYV2_FAILURE_LIKELY(spec, expr)`</title>
      <link>https://ned14.github.io/outcome/reference/macros/co_tryv2_failure_likely/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/macros/co_tryv2_failure_likely/</guid>
      <description>Evaluate an expression which results in a type matching the following customisation points, continuing execution if successful, immediately returning try_operation_return_as(X) from the calling function if unsuccessful:
 OUTCOME_V2_NAMESPACE::try_operation_has_value(X)  OUTCOME_V2_NAMESPACE::try_operation_return_as(X)  OUTCOME_V2_NAMESPACE::try_operation_extract_value(X)   Default overloads for these customisation points are provided. See the recipe for supporting foreign input to OUTCOME_TRY.
Hints are given to the compiler that the expression will be unsuccessful. If you expect success, you should use OUTCOME_TRYV(expr) instead.</description>
    </item>
    
    <item>
      <title>`OUTCOME_CO_TRYV_FAILURE_LIKELY(expr)/OUTCOME_CO_TRY_FAILURE_LIKELY(expr)`</title>
      <link>https://ned14.github.io/outcome/reference/macros/co_tryv_failure_likely/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/macros/co_tryv_failure_likely/</guid>
      <description>Evaluate from within a coroutine an expression which results in a type matching the following customisation points, continuing execution if successful, immediately returning try_operation_return_as(X) from the calling function if unsuccessful:
 OUTCOME_V2_NAMESPACE::try_operation_has_value(X)  OUTCOME_V2_NAMESPACE::try_operation_return_as(X)  OUTCOME_V2_NAMESPACE::try_operation_extract_value(X)   Default overloads for these customisation points are provided. See the recipe for supporting foreign input to OUTCOME_TRY.
The difference between the OUTCOME_CO_TRYV(expr) and OUTCOME_CO_TRY(expr) editions is that the latter will set a variable if two or more macro arguments are present (see OUTCOME_CO_TRY(var, expr) ).</description>
    </item>
    
    <item>
      <title>`OUTCOME_CO_TRYX(expr)`</title>
      <link>https://ned14.github.io/outcome/reference/macros/co_tryx/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/macros/co_tryx/</guid>
      <description>Evaluate within a coroutine an expression which results in a type matching the following customisation points, emitting the T if successful, immediately returning try_operation_return_as(X) from the calling function if unsuccessful:
 OUTCOME_V2_NAMESPACE::try_operation_has_value(X)  OUTCOME_V2_NAMESPACE::try_operation_return_as(X)  OUTCOME_V2_NAMESPACE::try_operation_extract_value(X)   Default overloads for these customisation points are provided. See the recipe for supporting foreign input to OUTCOME_TRY.
Hints are given to the compiler that the expression will be successful. If you expect failure, you should use OUTCOME_CO_TRYX_FAILURE_LIKELY(expr) instead.</description>
    </item>
    
    <item>
      <title>`OUTCOME_CO_TRYX_FAILURE_LIKELY(expr)`</title>
      <link>https://ned14.github.io/outcome/reference/macros/co_tryx_failure_likely/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/macros/co_tryx_failure_likely/</guid>
      <description>Evaluate within a coroutine an expression which results in a type matching the following customisation points, emitting the T if successful, immediately returning try_operation_return_as(X) from the calling function if unsuccessful:
 OUTCOME_V2_NAMESPACE::try_operation_has_value(X)  OUTCOME_V2_NAMESPACE::try_operation_return_as(X)  OUTCOME_V2_NAMESPACE::try_operation_extract_value(X)   Default overloads for these customisation points are provided. See the recipe for supporting foreign input to OUTCOME_TRY.
Hints are given to the compiler that the expression will be unsuccessful. If you expect success, you should use OUTCOME_CO_TRYX(expr) instead.</description>
    </item>
    
    <item>
      <title>`OUTCOME_CO_TRY_FAILURE_LIKELY(var, expr)`</title>
      <link>https://ned14.github.io/outcome/reference/macros/co_try_failure_likely/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/macros/co_try_failure_likely/</guid>
      <description>Evaluate within a coroutine an expression which results in a type matching the following customisation points, assigning T to a decl called var if successful, immediately returning try_operation_return_as(X) from the calling function if unsuccessful:
 OUTCOME_V2_NAMESPACE::try_operation_has_value(X)  OUTCOME_V2_NAMESPACE::try_operation_return_as(X)  OUTCOME_V2_NAMESPACE::try_operation_extract_value(X)   Default overloads for these customisation points are provided. See the recipe for supporting foreign input to OUTCOME_TRY.
Hints are given to the compiler that the expression will be unsuccessful.</description>
    </item>
    
    <item>
      <title>`OUTCOME_DISABLE_EXECINFO`</title>
      <link>https://ned14.github.io/outcome/reference/macros/disable_execinfo/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/macros/disable_execinfo/</guid>
      <description>If defined, disables the use of the &amp;lt;execinfo.h&amp;gt; header (or the win32 emulation).
Some embedded Linux toolchains do not define &amp;lt;execinfo.h&amp;gt;, thus disabling C++ exceptions on those toolchains produces a failure to find this file. Avoid that problem by defining this macro to disable stack backtrace support entirely.
Overridable: Define before inclusion.
Default: Defined if __ANDROID__ is defined, else undefined.
Header: &amp;lt;outcome/config.hpp&amp;gt;</description>
    </item>
    
    <item>
      <title>`OUTCOME_ENABLE_LEGACY_SUPPORT_FOR`</title>
      <link>https://ned14.github.io/outcome/reference/macros/enable_legacy_support_for/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/macros/enable_legacy_support_for/</guid>
      <description>As Outcome has evolved, some features and especially naming were retired in newer versions. Define this macro to enable backwards compatibility aliasing from old features and naming to new features and naming.
Overridable: Define before inclusion.
Default: The current version of Outcome, expressed in hundreds e.g. Outcome v2.10 is 210.
Header: &amp;lt;outcome/config.hpp&amp;gt;</description>
    </item>
    
    <item>
      <title>`OUTCOME_NODISCARD`</title>
      <link>https://ned14.github.io/outcome/reference/macros/nodiscard/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/macros/nodiscard/</guid>
      <description>Compiler-specific markup used to tell the compiler than the return value of a function should not be discarded without examining it.
Overridable: Define before inclusion.
Default: To [[nodiscard]] if on C++ 17 or higher, __attribute__((warn_unused_result)) if on clang, SAL _Must_inspect_result_ if on MSVC, otherwise nothing.
Header: &amp;lt;outcome/config.hpp&amp;gt;</description>
    </item>
    
    <item>
      <title>`OUTCOME_REQUIRES(...)`</title>
      <link>https://ned14.github.io/outcome/reference/macros/requires/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/macros/requires/</guid>
      <description>A C++ 20 requires(...), if available.
Overridable: Define before inclusion.
Default: To requires(...) if on C++ 20 or later, else to nothing.
Header: &amp;lt;outcome/config.hpp&amp;gt;</description>
    </item>
    
    <item>
      <title>`OUTCOME_SYMBOL_VISIBLE`</title>
      <link>https://ned14.github.io/outcome/reference/macros/symbol_visible/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/macros/symbol_visible/</guid>
      <description>Compiler-specific markup used to mark throwable types as always having default ELF symbol visibility, without which it will be impossible to catch throws of such types across shared library boundaries on ELF only.
Overridable: Define before inclusion.
Default: Standalone Outcome: To __attribute__((visibility(&amp;quot;default&amp;quot;)) on GCC and clang when targeting ELF, otherwise nothing. Boost.Outcome: To BOOST_SYMBOL_VISIBLE. 
Header: &amp;lt;outcome/config.hpp&amp;gt;</description>
    </item>
    
    <item>
      <title>`OUTCOME_THREAD_LOCAL`</title>
      <link>https://ned14.github.io/outcome/reference/macros/thread_local/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/macros/thread_local/</guid>
      <description>Compiler-specific markup used to mark variables as having thread local storage duration.
This isn&amp;rsquo;t used inside Outcome, but is used by its unit test suite.
 Overridable: Define before inclusion.
Default: To thread_local if the compiler implements C++ 11 thread_local, else __thread for the one supported compiler (older Mac OS XCode) which does not.
Header: &amp;lt;outcome/config.hpp&amp;gt;</description>
    </item>
    
    <item>
      <title>`OUTCOME_THROW_EXCEPTION(expr)`</title>
      <link>https://ned14.github.io/outcome/reference/macros/throw_exception/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/macros/throw_exception/</guid>
      <description>Throws a C++ exception, or equivalent thereof.
Overridable: Define before inclusion.
Default: Standalone Outcome (C++ exceptions enabled): To throw expr Standalone Outcome (C++ exceptions disabled): To OUTCOME_V2_NAMESPACE::detail::do_fatal_exit(#expr) which is a function which prints a useful error message including a stack backtrace (where available) to stderr before calling abort(). Boost.Outcome: To BOOST_THROW_EXCEPTION(expr). 
Header: &amp;lt;outcome/config.hpp&amp;gt;</description>
    </item>
    
    <item>
      <title>`OUTCOME_TRY(var, expr)`</title>
      <link>https://ned14.github.io/outcome/reference/macros/try/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/macros/try/</guid>
      <description>Evaluate an expression which results in a type matching the following customisation points, assigning T to a decl called var if successful, immediately returning try_operation_return_as(X) from the calling function if unsuccessful:
 OUTCOME_V2_NAMESPACE::try_operation_has_value(X)  OUTCOME_V2_NAMESPACE::try_operation_return_as(X)  OUTCOME_V2_NAMESPACE::try_operation_extract_value(X)   Default overloads for these customisation points are provided. See the recipe for supporting foreign input to OUTCOME_TRY.
Hints are given to the compiler that the expression will be successful. If you expect failure, you should use OUTCOME_TRY_FAILURE_LIKELY(var, expr) instead.</description>
    </item>
    
    <item>
      <title>`OUTCOME_TRYV(expr)/OUTCOME_TRY(expr)`</title>
      <link>https://ned14.github.io/outcome/reference/macros/tryv/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/macros/tryv/</guid>
      <description>Evaluate an expression which results in a type matching the following customisation points, continuing execution if successful, immediately returning try_operation_return_as(X) from the calling function if unsuccessful:
 OUTCOME_V2_NAMESPACE::try_operation_has_value(X)  OUTCOME_V2_NAMESPACE::try_operation_return_as(X)  OUTCOME_V2_NAMESPACE::try_operation_extract_value(X)   Default overloads for these customisation points are provided. See the recipe for supporting foreign input to OUTCOME_TRY.
The difference between the OUTCOME_TRYV(expr) and OUTCOME_TRY(expr) editions is that the latter will set a variable if two or more macro arguments are present (see OUTCOME_TRY(var, expr) ).</description>
    </item>
    
    <item>
      <title>`OUTCOME_TRYV2(spec, expr)`</title>
      <link>https://ned14.github.io/outcome/reference/macros/tryv2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/macros/tryv2/</guid>
      <description>Evaluate an expression which results in a type matching the following customisation points, continuing execution if successful, immediately returning try_operation_return_as(X) from the calling function if unsuccessful:
 OUTCOME_V2_NAMESPACE::try_operation_has_value(X)  OUTCOME_V2_NAMESPACE::try_operation_return_as(X)  OUTCOME_V2_NAMESPACE::try_operation_extract_value(X)   Default overloads for these customisation points are provided. See the recipe for supporting foreign input to OUTCOME_TRY.
Hints are given to the compiler that the expression will be successful. If you expect failure, you should use OUTCOME_TRYV2_FAILURE_LIKELY(spec, expr) instead.</description>
    </item>
    
    <item>
      <title>`OUTCOME_TRYV2_FAILURE_LIKELY(spec, expr)`</title>
      <link>https://ned14.github.io/outcome/reference/macros/tryv2_failure_likely/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/macros/tryv2_failure_likely/</guid>
      <description>Evaluate an expression which results in a type matching the following customisation points, continuing execution if successful, immediately returning try_operation_return_as(X) from the calling function if unsuccessful:
 OUTCOME_V2_NAMESPACE::try_operation_has_value(X)  OUTCOME_V2_NAMESPACE::try_operation_return_as(X)  OUTCOME_V2_NAMESPACE::try_operation_extract_value(X)   Default overloads for these customisation points are provided. See the recipe for supporting foreign input to OUTCOME_TRY.
Hints are given to the compiler that the expression will be unsuccessful. If you expect success, you should use OUTCOME_TRYV(expr) instead.</description>
    </item>
    
    <item>
      <title>`OUTCOME_TRYV_FAILURE_LIKELY(expr)/OUTCOME_TRY_FAILURE_LIKELY(expr)`</title>
      <link>https://ned14.github.io/outcome/reference/macros/tryv_failure_likely/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/macros/tryv_failure_likely/</guid>
      <description>Evaluate an expression which results in a type matching the following customisation points, continuing execution if successful, immediately returning try_operation_return_as(X) from the calling function if unsuccessful:
 OUTCOME_V2_NAMESPACE::try_operation_has_value(X)  OUTCOME_V2_NAMESPACE::try_operation_return_as(X)  OUTCOME_V2_NAMESPACE::try_operation_extract_value(X)   Default overloads for these customisation points are provided. See the recipe for supporting foreign input to OUTCOME_TRY.
The difference between the OUTCOME_TRYV(expr) and OUTCOME_TRY(expr) editions is that the latter will set a variable if two or more macro arguments are present (see OUTCOME_TRY(var, expr) ).</description>
    </item>
    
    <item>
      <title>`OUTCOME_TRYX(expr)`</title>
      <link>https://ned14.github.io/outcome/reference/macros/tryx/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/macros/tryx/</guid>
      <description>Evaluate an expression which results in a type matching the following customisation points, emitting the T if successful, immediately returning try_operation_return_as(X) from the calling function if unsuccessful:
 OUTCOME_V2_NAMESPACE::try_operation_has_value(X)  OUTCOME_V2_NAMESPACE::try_operation_return_as(X)  OUTCOME_V2_NAMESPACE::try_operation_extract_value(X)   Default overloads for these customisation points are provided. See the recipe for supporting foreign input to OUTCOME_TRY.
Hints are given to the compiler that the expression will be successful. If you expect failure, you should use OUTCOME_TRYX_FAILURE_LIKELY(expr) instead.</description>
    </item>
    
    <item>
      <title>`OUTCOME_TRYX_FAILURE_LIKELY(expr)`</title>
      <link>https://ned14.github.io/outcome/reference/macros/tryx_failure_likely/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/macros/tryx_failure_likely/</guid>
      <description>Evaluate an expression which results in a type matching the following customisation points, emitting the T if successful, immediately returning try_operation_return_as(X) from the calling function if unsuccessful:
 OUTCOME_V2_NAMESPACE::try_operation_has_value(X)  OUTCOME_V2_NAMESPACE::try_operation_return_as(X)  OUTCOME_V2_NAMESPACE::try_operation_extract_value(X)   Default overloads for these customisation points are provided. See the recipe for supporting foreign input to OUTCOME_TRY.
Hints are given to the compiler that the expression will be unsuccessful. If you expect success, you should use OUTCOME_TRYX(expr) instead.</description>
    </item>
    
    <item>
      <title>`OUTCOME_TRY_FAILURE_LIKELY(var, expr)`</title>
      <link>https://ned14.github.io/outcome/reference/macros/try_failure_likely/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/macros/try_failure_likely/</guid>
      <description>Evaluate an expression which results in a type matching the following customisation points, assigning T to a decl called var if successful, immediately returning try_operation_return_as(X) from the calling function if unsuccessful:
 OUTCOME_V2_NAMESPACE::try_operation_has_value(X)  OUTCOME_V2_NAMESPACE::try_operation_return_as(X)  OUTCOME_V2_NAMESPACE::try_operation_extract_value(X)   Default overloads for these customisation points are provided. See the recipe for supporting foreign input to OUTCOME_TRY.
Hints are given to the compiler that the expression will be unsuccessful. If you expect success, you should use OUTCOME_TRY(var, expr) instead.</description>
    </item>
    
    <item>
      <title>`OUTCOME_USE_STD_IN_PLACE_TYPE`</title>
      <link>https://ned14.github.io/outcome/reference/macros/in_place_type/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/macros/in_place_type/</guid>
      <description>How to implement in_place_type_t&amp;lt;T&amp;gt; and in_place_type&amp;lt;T&amp;gt;.
If set to 1, the &amp;lt;utility&amp;gt; header is included, and std::in_place_type_t&amp;lt;T&amp;gt; is aliased into OUTCOME_V2_NAMESPACE::in_place_type_t&amp;lt;T&amp;gt; along with std::in_place_type&amp;lt;T&amp;gt;.
If set to 0, a local emulation is used.
Overridable: Define before inclusion.
Default: If the current compiler implements C++ 17 or later, if unset this macro is defaulted to 1, otherwise it is defaulted to 0.
Header: &amp;lt;outcome/config.hpp&amp;gt;</description>
    </item>
    
    <item>
      <title>`OUTCOME_USE_STD_IS_NOTHROW_SWAPPABLE`</title>
      <link>https://ned14.github.io/outcome/reference/macros/is_nothrow_swappable/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/macros/is_nothrow_swappable/</guid>
      <description>Whether to implement is_nothrow_swappable&amp;lt;T&amp;gt; as std::is_nothrow_swappable&amp;lt;T&amp;gt;, or else use a local emulation.
Overridable: Define before inclusion.
Default: If the current compiler implements C++ 17 or later, if unset this macro is defaulted to 1, otherwise it is defaulted to 0.
Header: &amp;lt;outcome/config.hpp&amp;gt;</description>
    </item>
    
    <item>
      <title>`all_narrow`</title>
      <link>https://ned14.github.io/outcome/reference/policies/all_narrow/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/policies/all_narrow/</guid>
      <description>Policy class defining that hard undefined behaviour should occur on incorrect narrow and wide value, error or exception observation.
Inherits publicly from base , and simply defines its wide value, error and exception observer policies to call their corresponding narrow editions.
Included by &amp;lt;basic_result.hpp&amp;gt;, and so is always available when basic_result is available.
Requires: Nothing.
Namespace: OUTCOME_V2_NAMESPACE::policy
Header: &amp;lt;outcome/policy/all_narrow.hpp&amp;gt;</description>
    </item>
    
    <item>
      <title>`auto basic_outcome_failure_exception_from_error(const EC &amp;)`</title>
      <link>https://ned14.github.io/outcome/reference/functions/policy/basic_outcome_failure_exception_from_error/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/functions/policy/basic_outcome_failure_exception_from_error/</guid>
      <description>Synthesises an exception type from an error type, used by the exception_type failure() const noexcept observers. ADL discovered. Default overloads for this function are defined in Outcome for  std::error_code and boost::system::error_code, these return std::make_exception_ptr(std::system_error(ec)) and boost::copy_exception(boost::system::system_error(ec)) respectively.
Overridable: Argument dependent lookup.
Requires: Nothing.
Namespace: Namespace of EC type.
Header: &amp;lt;outcome/std_outcome.hpp&amp;gt;, &amp;lt;outcome/boost_outcome.hpp&amp;gt;</description>
    </item>
    
    <item>
      <title>`auto failure(T &amp;&amp;, ...)`</title>
      <link>https://ned14.github.io/outcome/reference/functions/failure/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/functions/failure/</guid>
      <description>Returns appropriate type sugar for constructing an unsuccessful result or outcome, usually failure_type&amp;lt;EC, EP = void&amp;gt; with a decayed T.
Two default overloads are provided, one taking a single required parameter with optional spare storage value parameter returning failure_type&amp;lt;std::decay_t&amp;lt;T&amp;gt;&amp;gt;, the other taking two required parameters with optional spare storage value parameter returning failure_type&amp;lt;std::decay_t&amp;lt;T&amp;gt;, std::decay_t&amp;lt;U&amp;gt;&amp;gt;. Both overloads perfectly forward their inputs.
Note that failure() overloads are permitted by Outcome to return something other than failure_type.</description>
    </item>
    
    <item>
      <title>`auto success(T &amp;&amp;, ...)`</title>
      <link>https://ned14.github.io/outcome/reference/functions/success/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/functions/success/</guid>
      <description>Returns appropriate type sugar for constructing a successful result or outcome, usually success_type&amp;lt;T&amp;gt; with a decayed T.
Two default overloads are provided, one taking a single required parameter with optional spare storage value parameter returning success_type&amp;lt;std::decay_t&amp;lt;T&amp;gt;&amp;gt; and perfectly forwarding the input. The other overload takes no parameters, and returns success_type&amp;lt;void&amp;gt;, which usually causes the construction of the receiving basic_result or basic_outcome&amp;rsquo;s with a default construction of their value type.
Overridable: By Argument Dependent Lookup (ADL).</description>
    </item>
    
    <item>
      <title>`bad_outcome_access`</title>
      <link>https://ned14.github.io/outcome/reference/types/bad_outcome_access/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/bad_outcome_access/</guid>
      <description>Exception type publicly inheriting from  std::logic_error indicating an incorrect observation of value or error or exception occurred by basic_outcome&amp;lt;T, EC, EP, NoValuePolicy&amp;gt; .
No member functions are added in addition to std::logic_error. Typical .what() strings are:
 &amp;quot;no value&amp;quot; &amp;quot;no error&amp;quot; &amp;quot;no exception&amp;quot;  Requires: Nothing.
Namespace: OUTCOME_V2_NAMESPACE
Header: &amp;lt;outcome/bad_access.hpp&amp;gt;</description>
    </item>
    
    <item>
      <title>`bad_result_access_with&lt;EC&gt;`</title>
      <link>https://ned14.github.io/outcome/reference/types/bad_result_access_with/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/bad_result_access_with/</guid>
      <description>Exception type publicly inheriting from bad_result_access , and thus also  std::logic_error , indicating an incorrect observation of value occurred. The error value at the time of the exception throw is moved or copied into this type, and is available using the .error() observer which comes in lvalue ref, const lvalue ref, rvalue ref, and const rvalue ref overloads.
The primary purpose of this exception type is to enable standing in for  P0323 std::expected&amp;lt;T, E&amp;gt; &amp;rsquo;s bad_expected_access&amp;lt;E&amp;gt; which is thrown on incorrect wide value observation.</description>
    </item>
    
    <item>
      <title>`bad_result_access`</title>
      <link>https://ned14.github.io/outcome/reference/types/bad_result_access/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/bad_result_access/</guid>
      <description>Exception type publicly inheriting from  std::logic_error indicating an incorrect observation of value or error occurred by basic_result&amp;lt;T, E, NoValuePolicy&amp;gt; .
No member functions are added in addition to std::logic_error. Typical .what() strings are:
 &amp;quot;no value&amp;quot; &amp;quot;no error&amp;quot;  Requires: Nothing.
Namespace: OUTCOME_V2_NAMESPACE
Header: &amp;lt;outcome/bad_access.hpp&amp;gt;</description>
    </item>
    
    <item>
      <title>`basic_outcome&lt;T&gt;`</title>
      <link>https://ned14.github.io/outcome/reference/concepts/basic_outcome/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/concepts/basic_outcome/</guid>
      <description>If on C++ 20 or the Concepts TS is enabled, a boolean concept matching types which have value_type, error_type and no_value_policy_type member typedefs; that the type is convertible to basic_result&amp;lt;value_type, error_type, no_value_policy_type&amp;gt;; that basic_result&amp;lt;value_type, error_type, no_value_policy_type&amp;gt; is a base of the type.
If without Concepts, a static constexpr bool which is true for types matching the same requirements, using a SFINAE based emulation.
This concept matches any type which provides the same typedefs as a basic_result&amp;lt;T, E, NoValuePolicy&amp;gt; , has that basic_result as a base class, and is implicitly convertible to basic_result.</description>
    </item>
    
    <item>
      <title>`basic_result&lt;T&gt;`</title>
      <link>https://ned14.github.io/outcome/reference/concepts/basic_result/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/concepts/basic_result/</guid>
      <description>If on C++ 20 or the Concepts TS is enabled, a boolean concept matching types which have value_type, error_type and no_value_policy_type member typedefs; that the type is convertible to basic_result&amp;lt;value_type, error_type, no_value_policy_type&amp;gt;; that basic_result&amp;lt;value_type, error_type, no_value_policy_type&amp;gt; is a base of the type.
If without Concepts, a static constexpr bool which is true for types matching the same requirements, using a SFINAE based emulation.
This concept matches any type which provides the same typedefs as a basic_result&amp;lt;T, E, NoValuePolicy&amp;gt; , has that basic_result as a base class, and is implicitly convertible to basic_result.</description>
    </item>
    
    <item>
      <title>`bool try_operation_has_value(X)`</title>
      <link>https://ned14.github.io/outcome/reference/functions/try_operation_has_value/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/functions/try_operation_has_value/</guid>
      <description>This default implementation returns whatever the .has_value() member function returns.
Requires: That the expression std::declval&amp;lt;T&amp;gt;().has_value() is a valid expression.
Namespace: OUTCOME_V2_NAMESPACE
Header: &amp;lt;outcome/try.hpp&amp;gt;</description>
    </item>
    
    <item>
      <title>`boost_checked&lt;T, E = boost::system::error_code&gt;`</title>
      <link>https://ned14.github.io/outcome/reference/aliases/boost_checked/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/aliases/boost_checked/</guid>
      <description>A type alias to a basic_result&amp;lt;T, E, NoValuePolicy&amp;gt; configured with boost::system::error_code and policy::throw_bad_result_access&amp;lt;EC&amp;gt; .
This type alias always references the boost edition of things, unlike checked&amp;lt;T, E = varies&amp;gt; which references either this alias or std_checked&amp;lt;T, E = std::error_code&amp;gt; .
Namespace: OUTCOME_V2_NAMESPACE
Header: &amp;lt;outcome/boost_result.hpp&amp;gt;</description>
    </item>
    
    <item>
      <title>`boost_outcome&lt;T, EC = boost::system::error_code, EP = boost::exception_ptr, NoValuePolicy = policy::default_policy&lt;T, EC, EP&gt;&gt;`</title>
      <link>https://ned14.github.io/outcome/reference/aliases/boost_outcome/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/aliases/boost_outcome/</guid>
      <description>A type alias to a basic_outcome&amp;lt;T, EC, EP, NoValuePolicy&amp;gt; configured with boost::system::error_code , boost::exception_ptr and policy::default_policy .
This type alias always references the std edition of things, unlike outcome&amp;lt;T, EC = varies, EP = varies, NoValuePolicy = policy::default_policy&amp;lt;T, EC, EP&amp;gt;&amp;gt; which references either this alias or std_outcome&amp;lt;T, EC = std::error_code, EP = std::exception_ptr, NoValuePolicy = policy::default_policy&amp;lt;T, EC, EP&amp;gt;&amp;gt; .
Namespace: OUTCOME_V2_NAMESPACE
Header: &amp;lt;outcome/boost_outcome.hpp&amp;gt;</description>
    </item>
    
    <item>
      <title>`boost_result&lt;T, E = boost::system::error_code, NoValuePolicy = policy::default_policy&lt;T, E, void&gt;&gt;`</title>
      <link>https://ned14.github.io/outcome/reference/aliases/boost_result/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/aliases/boost_result/</guid>
      <description>A type alias to a basic_result&amp;lt;T, E, NoValuePolicy&amp;gt; configured with boost::system::error_code and policy::default_policy .
This type alias always references the boost edition of things, unlike result&amp;lt;T, E = varies, NoValuePolicy = policy::default_policy&amp;lt;T, E, void&amp;gt;&amp;gt; which references either this alias or std_result&amp;lt;T, E = std::error_code, NoValuePolicy = policy::default_policy&amp;lt;T, E, void&amp;gt;&amp;gt; .
Namespace: OUTCOME_V2_NAMESPACE
Header: &amp;lt;outcome/boost_result.hpp&amp;gt;</description>
    </item>
    
    <item>
      <title>`boost_unchecked&lt;T, E = boost::system::error_code&gt;`</title>
      <link>https://ned14.github.io/outcome/reference/aliases/boost_unchecked/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/aliases/boost_unchecked/</guid>
      <description>A type alias to a basic_result&amp;lt;T, E, NoValuePolicy&amp;gt; configured with boost::system::error_code and policy::all_narrow .
This type alias always references the boost edition of things, unlike unchecked&amp;lt;T, E = varies&amp;gt; which references either this alias or std_unchecked&amp;lt;T, E = std::error_code&amp;gt; .
Namespace: OUTCOME_V2_NAMESPACE
Header: &amp;lt;outcome/boost_result.hpp&amp;gt;</description>
    </item>
    
    <item>
      <title>`checked&lt;T, E = varies&gt;`</title>
      <link>https://ned14.github.io/outcome/reference/aliases/checked/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/aliases/checked/</guid>
      <description>A type alias to either std_checked&amp;lt;T, E = std::error_code&amp;gt; (standalone edition) or boost_checked&amp;lt;T, E = boost::system::error_code&amp;gt; (Boost edition). This means that checked&amp;lt;T&amp;gt; uses the appropriate default alias depending on which edition of Outcome is in use.
Namespace: OUTCOME_V2_NAMESPACE
Header: &amp;lt;outcome/result.hpp&amp;gt;</description>
    </item>
    
    <item>
      <title>`decltype(auto) error_code(T &amp;&amp;)`</title>
      <link>https://ned14.github.io/outcome/reference/functions/policy/error_code/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/functions/policy/error_code/</guid>
      <description>Extracts a boost::system::error_code or  std::error_code from the input via ADL discovery of a suitable make_error_code(T) function.
Overridable: Argument dependent lookup.
Requires: Always available.
Namespace: OUTCOME_V2_NAMESPACE::policy
Header: &amp;lt;outcome/std_result.hpp&amp;gt;</description>
    </item>
    
    <item>
      <title>`decltype(auto) exception_ptr(T &amp;&amp;)`</title>
      <link>https://ned14.github.io/outcome/reference/functions/policy/exception_ptr/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/functions/policy/exception_ptr/</guid>
      <description>Extracts a boost::exception_ptr or  std::exception_ptr from the input via ADL discovery of a suitable make_exception_ptr(T) function.
Overridable: Argument dependent lookup.
Requires: Always available.
Namespace: OUTCOME_V2_NAMESPACE::policy
Header: &amp;lt;outcome/std_result.hpp&amp;gt;</description>
    </item>
    
    <item>
      <title>`decltype(auto) try_operation_extract_value(X)`</title>
      <link>https://ned14.github.io/outcome/reference/functions/try_operation_extract_value/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/functions/try_operation_extract_value/</guid>
      <description>This default implementation returns whatever the .assume_value() or .value() member functions return, preferentially choosing the former where both are available.
Requires: That the expression std::declval&amp;lt;T&amp;gt;().assume_value() and/or std::declval&amp;lt;T&amp;gt;().value() is a valid expression.
Namespace: OUTCOME_V2_NAMESPACE
Header: &amp;lt;outcome/try.hpp&amp;gt;</description>
    </item>
    
    <item>
      <title>`decltype(auto) try_operation_return_as(X)`</title>
      <link>https://ned14.github.io/outcome/reference/functions/try_operation_return_as/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/functions/try_operation_return_as/</guid>
      <description>This default implementation preferentially returns whatever the input type&amp;rsquo;s .as_failure() member function returns. basic_result and basic_outcome provide such a member function, see auto as_failure() const &amp;amp; .
If .as_failure() is not available, it will also match any .error() member function, which it wraps into a failure type sugar using failure(T &amp;amp;&amp;amp;, ...) .
Requires: That the expression std::declval&amp;lt;T&amp;gt;().as_failure() and/or std::declval&amp;lt;T&amp;gt;().error() is a valid expression.
Namespace: OUTCOME_V2_NAMESPACE
Header: &amp;lt;outcome/try.hpp&amp;gt;</description>
    </item>
    
    <item>
      <title>`default_policy&lt;T, EC, EP&gt;`</title>
      <link>https://ned14.github.io/outcome/reference/aliases/default_policy/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/aliases/default_policy/</guid>
      <description>A type alias to a no-value policy selected based on traits matching of T, EC and EP. It is defined as follows:
 If EC and EP is void, choose terminate .
 If is_error_code_available&amp;lt;T&amp;gt; true for EC, choose error_code_throw_as_system_error&amp;lt;T, EC, EP&amp;gt; for basic_outcome or error_code_throw_as_system_error&amp;lt;T, EC, void&amp;gt; for basic_result.
 If is_exception_ptr_available&amp;lt;T&amp;gt; true for EC or EP, choose exception_ptr_rethrow&amp;lt;T, EC, EP&amp;gt; for basic_outcome or exception_ptr_rethrow&amp;lt;T, EC, void&amp;gt; for basic_result.</description>
    </item>
    
    <item>
      <title>`eager&lt;T, Executor = void&gt;/atomic_eager&lt;T, Executor = void&gt;`</title>
      <link>https://ned14.github.io/outcome/reference/types/awaitables/eager/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/awaitables/eager/</guid>
      <description>This is very similar to lazy&amp;lt;T, Executor = void&amp;gt; , except that execution of the eager&amp;lt;T&amp;gt; returning function begins immediately, and if the function never suspends during the course of its execution, no suspend-resume cycle occurs. Functions which return eager&amp;lt;T&amp;gt; are therefore suitable for tasks which may require suspension, but will often complete immediately.
atomic_eager&amp;lt;T&amp;gt; is like eager&amp;lt;T&amp;gt;, except that the setting of the coroutine result performs an atomic release, whilst the checking of whether the coroutine has finished is an atomic acquire.</description>
    </item>
    
    <item>
      <title>`error_code_throw_as_system_error&lt;T, EC, EP&gt;`</title>
      <link>https://ned14.github.io/outcome/reference/policies/error_code_throw_as_system_error_outcome/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/policies/error_code_throw_as_system_error_outcome/</guid>
      <description>Note: This policy class specialisation can only be used with basic_outcome, not basic_result. Use error_code_throw_as_system_error&amp;lt;T, EC, void&amp;gt; with basic_result.
Policy class defining that on incorrect wide value observation, EP ought to be rethrown if possible, then the ADL discovered free function outcome_throw_as_system_error_with_payload(impl.assume_error()) should be called. Some precanned overloads of that function are listed here.
Incorrect wide error observation performs:
OUTCOME_THROW_EXCEPTION(bad_outcome_access(&amp;#34;no error&amp;#34;));  Incorrect wide exception observation performs:
OUTCOME_THROW_EXCEPTION(bad_outcome_access(&amp;#34;no exception&amp;#34;));  Inherits publicly from base , and its narrow value, error and exception observer policies are inherited from there.</description>
    </item>
    
    <item>
      <title>`error_code_throw_as_system_error&lt;T, EC, void&gt;`</title>
      <link>https://ned14.github.io/outcome/reference/policies/error_code_throw_as_system_error_result/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/policies/error_code_throw_as_system_error_result/</guid>
      <description>Note: This policy class specialisation can only be used with basic_result, not basic_outcome. Use error_code_throw_as_system_error&amp;lt;T, EC, EP&amp;gt; with basic_outcome.
Policy class defining that the ADL discovered free function outcome_throw_as_system_error_with_payload(impl.assume_error()) should be called on incorrect wide value observation. Some precanned overloads of that function are listed here.
Incorrect wide error observation performs:
OUTCOME_THROW_EXCEPTION(bad_result_access(&amp;#34;no error&amp;#34;));  Inherits publicly from base , and its narrow value, error and exception observer policies are inherited from there.</description>
    </item>
    
    <item>
      <title>`exception_ptr_rethrow&lt;T, EC, EP&gt;`</title>
      <link>https://ned14.github.io/outcome/reference/policies/exception_ptr_rethrow_outcome/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/policies/exception_ptr_rethrow_outcome/</guid>
      <description>Note: This policy class specialisation can only be used with basic_outcome, not basic_result. Use exception_ptr_rethrow&amp;lt;T, EC, void&amp;gt; with basic_result.
Policy class defining that the ADL discovered free function rethrow_exception(impl.assume_exception()) if possible, followed by rethrow_exception(impl.assume_error()) should be called on incorrect wide value observation. Generally this will ADL discover  std::rethrow_exception() or boost::rethrow_exception() depending on the EC type.
Incorrect wide error observation performs:
OUTCOME_THROW_EXCEPTION(bad_outcome_access(&amp;#34;no error&amp;#34;));  Incorrect wide exception observation performs:
OUTCOME_THROW_EXCEPTION(bad_outcome_access(&amp;#34;no exception&amp;#34;));  Inherits publicly from base , and its narrow value, error and exception observer policies are inherited from there.</description>
    </item>
    
    <item>
      <title>`exception_ptr_rethrow&lt;T, EC, void&gt;`</title>
      <link>https://ned14.github.io/outcome/reference/policies/exception_ptr_rethrow_result/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/policies/exception_ptr_rethrow_result/</guid>
      <description>Note: This policy class specialisation can only be used with basic_result, not basic_outcome. Use exception_ptr_rethrow&amp;lt;T, EC, EP&amp;gt; with basic_outcome.
Policy class defining that the ADL discovered free function rethrow_exception(impl.assume_error()) should be called on incorrect wide value observation. Generally this will ADL discover  std::rethrow_exception() or boost::rethrow_exception() depending on the EC type.
Incorrect wide error observation performs:
OUTCOME_THROW_EXCEPTION(bad_result_access(&amp;#34;no error&amp;#34;));  Inherits publicly from base , and its narrow value, error and exception observer policies are inherited from there.</description>
    </item>
    
    <item>
      <title>`fail_to_compile_observers`</title>
      <link>https://ned14.github.io/outcome/reference/policies/fail_to_compile_observers/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/policies/fail_to_compile_observers/</guid>
      <description>Upon attempting to compile the wide observer policy functions, the following static assertion occurs which fails the build:
 Attempt to wide observe value, error or exception for a result/outcome given an EC or E type which is not void, and for whom trait::has_error_code_v, trait::has_exception_ptr_v, and trait::has_exception_ptr_v are all false. Please specify a NoValuePolicy to tell result/outcome what to do, or else use a more specific convenience type alias such as uncheckedto indicate you want the wide observers to be narrow, or checkedto indicate you always want an exception throw etc.</description>
    </item>
    
    <item>
      <title>`failure_type&lt;EC, EP = void&gt;`</title>
      <link>https://ned14.github.io/outcome/reference/types/failure_type/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/failure_type/</guid>
      <description>Type sugar for constructing an unsuccessful result or outcome. Generally not constructed directly, but via the free function failure(T &amp;amp;&amp;amp;, ...) . Detectable using is_failure_type&amp;lt;T&amp;gt; .
This is a regular wrapper type, with defaulted default, copy and move constructor, defaulted assignment, and defaulted destructor.
Member type aliases error_type and exception_type indicate EC and E.
There is an explicit initialising constructor taking any types U and V which will forward construct the contained error_type and exception_type respectively.</description>
    </item>
    
    <item>
      <title>`generator&lt;T, Executor = void&gt;`</title>
      <link>https://ned14.github.io/outcome/reference/types/awaitables/generator/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/awaitables/generator/</guid>
      <description>This is a classic coroutine generator whereby the coroutine is resumed to calculate the next value, and is suspended upon yielding that value. If the value being yielded is an Outcome type, special semantics are used if the coroutine throws an exception (see below).
The Executor template parameter is purely for compatibility with third party software such as ASIO, and this awaitable can be directly used by ASIO.
Example of use:</description>
    </item>
    
    <item>
      <title>`in_place_type_t&lt;T&gt;`</title>
      <link>https://ned14.github.io/outcome/reference/types/in_place_type_t/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/in_place_type_t/</guid>
      <description>Either std::in_place_type_t&amp;lt;T&amp;gt; or a local emulation, depending on the OUTCOME_USE_STD_IN_PLACE_TYPE macro.
Note that the templated variable in_place_type is also aliased or emulated locally.
Requires: Nothing.
Namespace: OUTCOME_V2_NAMESPACE
Header: &amp;lt;outcome/config.hpp&amp;gt;</description>
    </item>
    
    <item>
      <title>`is_basic_outcome&lt;T&gt;`</title>
      <link>https://ned14.github.io/outcome/reference/traits/is_basic_outcome/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/traits/is_basic_outcome/</guid>
      <description>An integral constant type true for basic_outcome&amp;lt;T, EC, EP, NoValuePolicy&amp;gt; types. This does not match anything not exactly a basic_outcome. If you want to match types like basic_outcome but not equal to it, consider basic_outcome&amp;lt;T&amp;gt; ..
Overridable: Not overridable.
Namespace: OUTCOME_V2_NAMESPACE
Header: &amp;lt;outcome/basic_outcome.hpp&amp;gt;
Variable alias: is_basic_outcome_v&amp;lt;T&amp;gt;</description>
    </item>
    
    <item>
      <title>`is_basic_result&lt;T&gt;`</title>
      <link>https://ned14.github.io/outcome/reference/traits/is_basic_result/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/traits/is_basic_result/</guid>
      <description>An integral constant type true for basic_result&amp;lt;T, E, NoValuePolicy&amp;gt; types. This does not match anything not exactly a basic_result. If you want to match types like basic_result but not equal to it, consider basic_result&amp;lt;T&amp;gt; or value_or_error&amp;lt;T&amp;gt; .
Overridable: Not overridable.
Namespace: OUTCOME_V2_NAMESPACE
Header: &amp;lt;outcome/basic_result.hpp&amp;gt;
Variable alias: is_basic_result_v&amp;lt;T&amp;gt;</description>
    </item>
    
    <item>
      <title>`is_error_code_available&lt;T&gt;`</title>
      <link>https://ned14.github.io/outcome/reference/traits/is_error_code_available/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/traits/is_error_code_available/</guid>
      <description>::value is true if an error code can be constructed from a T e.g. if there exists an ADL discovered free function make_error_code(T). ::type is the type that would result if ::value is true, else void.
Overridable: By template specialisation into the trait namespace.
Default: True if T is an error code, else to metaprogramming which performs the ADL discovery of make_error_code(T). Note that the STL defines multiple overloads of an ADL discovered free function  std::make_error_code(T) for its error enumerations, as does Boost.</description>
    </item>
    
    <item>
      <title>`is_error_type&lt;E&gt;`</title>
      <link>https://ned14.github.io/outcome/reference/traits/is_error_type/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/traits/is_error_type/</guid>
      <description>A customisable integral constant type true for E types which are to receive error throwing no-value policies. Special weakened implicit construction enable is available for integral T types when combined with E types in this whitelist &amp;ndash; this permits boost_result&amp;lt;int, boost::system::errc::errc_t to retain its implicit constructors, despite the fact that errc_t as a C enum has an implicit conversion to int.
Overridable: By template specialisation into the trait namespace.
Default: False.</description>
    </item>
    
    <item>
      <title>`is_error_type_enum&lt;E, Enum&gt;`</title>
      <link>https://ned14.github.io/outcome/reference/traits/is_error_type_enum/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/traits/is_error_type_enum/</guid>
      <description>A customisable integral constant type true for E types constructible from Enum types which are to receive error throwing no-value policies
Overridable: By template specialisation into the trait namespace.
Default: False. Specialisations exist for:
 &amp;lt;outcome/boost_result.hpp&amp;gt;
 boost::system::error_code to boost::system::is_error_condition_enum&amp;lt;Enum&amp;gt;::value.  &amp;lt;outcome/std_result.hpp&amp;gt;
 std::error_code to std::is_error_condition_enum&amp;lt;Enum&amp;gt;::value.   Namespace: OUTCOME_V2_NAMESPACE::trait
Header: &amp;lt;outcome/trait.hpp&amp;gt;</description>
    </item>
    
    <item>
      <title>`is_exception_ptr_available&lt;T&gt;`</title>
      <link>https://ned14.github.io/outcome/reference/traits/is_exception_ptr_available/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/traits/is_exception_ptr_available/</guid>
      <description>::value is true if an exception ptr can be constructed from a T e.g. if there exists an ADL discovered free function make_exception_ptr(T). ::type is the type that would result if ::value is true, else void.
Overridable: By template specialisation into the trait namespace.
Default: True if T is an exception ptr, else to metaprogramming which performs the ADL discovery of make_exception_ptr(T). Note that the STL defines an ADL discovered free function  std::make_exception_ptr(T) .</description>
    </item>
    
    <item>
      <title>`is_failure_type&lt;T&gt;`</title>
      <link>https://ned14.github.io/outcome/reference/traits/is_failure_type/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/traits/is_failure_type/</guid>
      <description>An integral constant boolean variable true for failure_type&amp;lt;EC, EP = void&amp;gt; types.
Overridable: Not overridable.
Namespace: OUTCOME_V2_NAMESPACE
Header: &amp;lt;outcome/success_failure.hpp&amp;gt;</description>
    </item>
    
    <item>
      <title>`is_move_bitcopying&lt;T&gt;`</title>
      <link>https://ned14.github.io/outcome/reference/traits/is_move_bitcopying/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/traits/is_move_bitcopying/</guid>
      <description>A customisable integral constant type true for T types which are move bitcopying safe. As per P1029 move bitcopying, these are types for which:
 There is an inline, constexpr-available, default constructor. The move constructor has side effects equivalent to memcpy of source to destination, followed by a memcpy of a default constructed instance to source. That the destruction of a default constructed instance has no visible side effects.  This implies that if you move from a bit copying type, you need not call its destructor, even if that is a virtual destructor.</description>
    </item>
    
    <item>
      <title>`is_success_type&lt;T&gt;`</title>
      <link>https://ned14.github.io/outcome/reference/traits/is_success_type/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/traits/is_success_type/</guid>
      <description>An integral constant boolean variable true for success_type&amp;lt;T&amp;gt; types.
Overridable: Not overridable.
Namespace: OUTCOME_V2_NAMESPACE
Header: &amp;lt;outcome/success_failure.hpp&amp;gt;</description>
    </item>
    
    <item>
      <title>`lazy&lt;T, Executor = void&gt;/atomic_lazy&lt;T, Executor = void&gt;`</title>
      <link>https://ned14.github.io/outcome/reference/types/awaitables/lazy/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/awaitables/lazy/</guid>
      <description>This is very similar to eager&amp;lt;T, Executor = void&amp;gt; , except that execution of the lazy&amp;lt;T&amp;gt; returning function suspends immediately. Functions which return lazy&amp;lt;T&amp;gt; are therefore suitable for tasks which you need to instantiate right now, but whose execution will occur elsewhere e.g. in a separate kernel thread. Because of the very common use case of using worker threads to execute the body of lazily executed coroutines, most people will want to use atomic_lazy&amp;lt;T&amp;gt; instead of lazy&amp;lt;T&amp;gt;.</description>
    </item>
    
    <item>
      <title>`outcome&lt;T, EC = varies, EP = varies, NoValuePolicy = policy::default_policy&lt;T, EC, EP&gt;&gt;`</title>
      <link>https://ned14.github.io/outcome/reference/aliases/outcome/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/aliases/outcome/</guid>
      <description>A type alias to either std_outcome&amp;lt;T, EC = std::error_code, EP = std::exception_ptr, NoValuePolicy = policy::default_policy&amp;lt;T, EC, EP&amp;gt;&amp;gt; (standalone edition) or boost_outcome&amp;lt;T, EC = boost::system::error_code, EP = boost::exception_ptr, NoValuePolicy = policy::default_policy&amp;lt;T, EC, EP&amp;gt;&amp;gt; (Boost edition), and policy::default_policy . This means that outcome&amp;lt;T&amp;gt; uses the appropriate default alias depending on which edition of Outcome is in use.
Namespace: OUTCOME_V2_NAMESPACE
Header: &amp;lt;outcome/outcome.hpp&amp;gt;</description>
    </item>
    
    <item>
      <title>`result&lt;T, E = varies, NoValuePolicy = policy::default_policy&lt;T, E, void&gt;&gt;`</title>
      <link>https://ned14.github.io/outcome/reference/aliases/result/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/aliases/result/</guid>
      <description>A type alias to either std_result&amp;lt;T, E = std::error_code, NoValuePolicy = policy::default_policy&amp;lt;T, E, void&amp;gt;&amp;gt; (standalone edition) or boost_result&amp;lt;T, E = boost::system::error_code, NoValuePolicy = policy::default_policy&amp;lt;T, E, void&amp;gt;&amp;gt; (Boost edition), and policy::default_policy . This means that result&amp;lt;T&amp;gt; uses the appropriate default alias depending on which edition of Outcome is in use.
Namespace: OUTCOME_V2_NAMESPACE
Header: &amp;lt;outcome/result.hpp&amp;gt;</description>
    </item>
    
    <item>
      <title>`std::error_code error_from_exception(std::exception_ptr &amp;&amp;ep = std::current_exception(), std::error_code not_matched = std::make_error_code(std::errc::resource_unavailable_try_again)) noexcept`</title>
      <link>https://ned14.github.io/outcome/reference/functions/error_from_exception/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/functions/error_from_exception/</guid>
      <description>This function saves writing boilerplate by rethrowing ep within a try block, with a long sequence of catch() handlers, one for every standard C++ exception type which has a near or exact equivalent code in  std::errc .
If matched, ep is set to a default constructed  std::exception_ptr , and a  std::error_code is constructed using the ADL discovered free function make_error_code() upon the std::errc enumeration value matching the thrown exception.</description>
    </item>
    
    <item>
      <title>`std::istream &amp;operator&gt;&gt;(std::istream &amp;, basic_outcome&lt;T, EC, EP, NoValuePolicy&gt; &amp;)`</title>
      <link>https://ned14.github.io/outcome/reference/functions/iostream/outcome_operator_in/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/functions/iostream/outcome_operator_in/</guid>
      <description>Deserialises a basic_outcome from a std::istream.
Serialisation format is:
&amp;lt;unsigned int flags&amp;gt;&amp;lt;space&amp;gt;&amp;lt;value_type if set and not void&amp;gt;&amp;lt;error_type if set and not void&amp;gt;&amp;lt;exception_type if set and not void&amp;gt;  Overridable: Not overridable.
Requires: That operator&amp;gt;&amp;gt; is a valid expression for std::istream and T, EC and EP.
Namespace: OUTCOME_V2_NAMESPACE
Header: &amp;lt;outcome/iostream_support.hpp&amp;gt; (must be explicitly included manually).</description>
    </item>
    
    <item>
      <title>`std::istream &amp;operator&gt;&gt;(std::istream &amp;, basic_result&lt;T, E, NoValuePolicy&gt; &amp;)`</title>
      <link>https://ned14.github.io/outcome/reference/functions/iostream/result_operator_in/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/functions/iostream/result_operator_in/</guid>
      <description>Deserialises a basic_result from a std::istream.
Serialisation format is:
&amp;lt;unsigned int flags&amp;gt;&amp;lt;space&amp;gt;&amp;lt;value_type if set and not void&amp;gt;&amp;lt;error_type if set and not void&amp;gt;  Overridable: Not overridable.
Requires: That operator&amp;gt;&amp;gt; is a valid expression for std::istream and T and E.
Namespace: OUTCOME_V2_NAMESPACE
Header: &amp;lt;outcome/iostream_support.hpp&amp;gt; (must be explicitly included manually).</description>
    </item>
    
    <item>
      <title>`std::ostream &amp;operator&lt;&lt;(std::ostream &amp;, const basic_outcome&lt;T, EC, EP, NoValuePolicy&gt; &amp;)`</title>
      <link>https://ned14.github.io/outcome/reference/functions/iostream/outcome_operator_out/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/functions/iostream/outcome_operator_out/</guid>
      <description>Serialises a basic_outcome to a std::ostream.
Serialisation format is:
&amp;lt;unsigned int flags&amp;gt;&amp;lt;space&amp;gt;&amp;lt;value_type if set and not void&amp;gt;&amp;lt;error_type if set and not void&amp;gt;&amp;lt;exception_type if set and not void&amp;gt;  This is the wrong function to use if you wish to print human readable output. Use std::string print(const basic_outcome&amp;lt;T, EC, EP, NoValuePolicy&amp;gt; &amp;amp;) instead.
Overridable: Not overridable.
Requires: That operator&amp;lt;&amp;lt; is a valid expression for std::ostream and T, EC and EP.
Namespace: OUTCOME_V2_NAMESPACE</description>
    </item>
    
    <item>
      <title>`std::ostream &amp;operator&lt;&lt;(std::ostream &amp;, const basic_result&lt;T, E, NoValuePolicy&gt; &amp;)`</title>
      <link>https://ned14.github.io/outcome/reference/functions/iostream/result_operator_out/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/functions/iostream/result_operator_out/</guid>
      <description>Serialises a basic_result to a std::ostream.
Serialisation format is:
&amp;lt;unsigned int flags&amp;gt;&amp;lt;space&amp;gt;&amp;lt;value_type if set and not void&amp;gt;&amp;lt;error_type if set and not void&amp;gt;  This is the wrong function to use if you wish to print human readable output. Use std::string print(const basic_result&amp;lt;T, E, NoValuePolicy&amp;gt; &amp;amp;) instead.
Overridable: Not overridable.
Requires: That operator&amp;lt;&amp;lt; is a valid expression for std::ostream and T and E.
Namespace: OUTCOME_V2_NAMESPACE
Header: &amp;lt;outcome/iostream_support.hpp&amp;gt; (must be explicitly included manually).</description>
    </item>
    
    <item>
      <title>`std::string print(const basic_outcome&lt;T, EC, EP, NoValuePolicy&gt; &amp;)`</title>
      <link>https://ned14.github.io/outcome/reference/functions/iostream/outcome_print/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/functions/iostream/outcome_print/</guid>
      <description>Returns a string containing a human readable rendition of the basic_outcome.
Overridable: Not overridable.
Requires: Always available.
Namespace: OUTCOME_V2_NAMESPACE
Header: &amp;lt;outcome/iostream_support.hpp&amp;gt; (must be explicitly included manually).</description>
    </item>
    
    <item>
      <title>`std::string print(const basic_result&lt;T, E, NoValuePolicy&gt; &amp;)`</title>
      <link>https://ned14.github.io/outcome/reference/functions/iostream/result_print/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/functions/iostream/result_print/</guid>
      <description>Returns a string containing a human readable rendition of the basic_result.
Overridable: Not overridable.
Requires: Always available.
Namespace: OUTCOME_V2_NAMESPACE
Header: &amp;lt;outcome/iostream_support.hpp&amp;gt; (must be explicitly included manually).</description>
    </item>
    
    <item>
      <title>`std_checked&lt;T, E = std::error_code&gt;`</title>
      <link>https://ned14.github.io/outcome/reference/aliases/std_checked/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/aliases/std_checked/</guid>
      <description>A type alias to a basic_result&amp;lt;T, E, NoValuePolicy&amp;gt; configured with  std::error_code and policy::throw_bad_result_access&amp;lt;EC&amp;gt; .
This type alias always references the std edition of things, unlike checked&amp;lt;T, E = varies&amp;gt; which references either this alias or boost_checked&amp;lt;T, E = boost::system::error_code&amp;gt; .
Namespace: OUTCOME_V2_NAMESPACE
Header: &amp;lt;outcome/std_result.hpp&amp;gt;</description>
    </item>
    
    <item>
      <title>`std_outcome&lt;T, EC = std::error_code, EP = std::exception_ptr, NoValuePolicy = policy::default_policy&lt;T, EC, EP&gt;&gt;`</title>
      <link>https://ned14.github.io/outcome/reference/aliases/std_outcome/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/aliases/std_outcome/</guid>
      <description>A type alias to a basic_outcome&amp;lt;T, EC, EP, NoValuePolicy&amp;gt; configured with  std::error_code ,  std::exception_ptr and policy::default_policy .
This type alias always references the std edition of things, unlike outcome&amp;lt;T, EC = varies, EP = varies, NoValuePolicy = policy::default_policy&amp;lt;T, EC, EP&amp;gt;&amp;gt; which references either this alias or boost_outcome&amp;lt;T, EC = boost::system::error_code, EP = boost::exception_ptr, NoValuePolicy = policy::default_policy&amp;lt;T, EC, EP&amp;gt;&amp;gt; .
Namespace: OUTCOME_V2_NAMESPACE
Header: &amp;lt;outcome/std_outcome.hpp&amp;gt;</description>
    </item>
    
    <item>
      <title>`std_result&lt;T, E = std::error_code, NoValuePolicy = policy::default_policy&lt;T, E, void&gt;&gt;`</title>
      <link>https://ned14.github.io/outcome/reference/aliases/std_result/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/aliases/std_result/</guid>
      <description>A type alias to a basic_result&amp;lt;T, E, NoValuePolicy&amp;gt; configured with  std::error_code and policy::default_policy .
This type alias always references the std edition of things, unlike result&amp;lt;T, E = varies, NoValuePolicy = policy::default_policy&amp;lt;T, E, void&amp;gt;&amp;gt; which references either this alias or boost_result&amp;lt;T, E = boost::system::error_code, NoValuePolicy = policy::default_policy&amp;lt;T, E, void&amp;gt;&amp;gt; .
Namespace: OUTCOME_V2_NAMESPACE
Header: &amp;lt;outcome/std_result.hpp&amp;gt;</description>
    </item>
    
    <item>
      <title>`std_unchecked&lt;T, E = std::error_code&gt;`</title>
      <link>https://ned14.github.io/outcome/reference/aliases/std_unchecked/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/aliases/std_unchecked/</guid>
      <description>A type alias to a basic_result&amp;lt;T, E, NoValuePolicy&amp;gt; configured with  std::error_code and policy::all_narrow .
This type alias always references the std edition of things, unlike unchecked&amp;lt;T, E = varies&amp;gt; which references either this alias or boost_unchecked&amp;lt;T, E = boost::system::error_code&amp;gt; .
Namespace: OUTCOME_V2_NAMESPACE
Header: &amp;lt;outcome/std_result.hpp&amp;gt;</description>
    </item>
    
    <item>
      <title>`success_type&lt;T&gt;`</title>
      <link>https://ned14.github.io/outcome/reference/types/success_type/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/types/success_type/</guid>
      <description>Type sugar for constructing a successful result or outcome. Generally not constructed directly, but via the free function success(T &amp;amp;&amp;amp;, ...) . Detectable using is_success_type&amp;lt;T&amp;gt; .
This is a regular wrapper type, with defaulted default, copy and move constructor, defaulted assignment, and defaulted destructor.
A member type alias value_type indicates T.
There is an explicit initialising constructor taking any type U which is not a success_type&amp;lt;T&amp;gt;, and which will forward construct the contained T from that U.</description>
    </item>
    
    <item>
      <title>`terminate`</title>
      <link>https://ned14.github.io/outcome/reference/policies/terminate/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/policies/terminate/</guid>
      <description>Policy class defining that  std::terminate() should be called on incorrect wide value, error or exception observation.
Inherits publicly from base , and its narrow value, error and exception observer policies are inherited from there.
Included by &amp;lt;basic_result.hpp&amp;gt;, and so is always available when basic_result is available.
Requires: Nothing.
Namespace: OUTCOME_V2_NAMESPACE::policy
Header: &amp;lt;outcome/policy/terminate.hpp&amp;gt;</description>
    </item>
    
    <item>
      <title>`throw_bad_result_access&lt;EC&gt;`</title>
      <link>https://ned14.github.io/outcome/reference/policies/throw_bad_result_access/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/policies/throw_bad_result_access/</guid>
      <description>Policy class defining that bad_result_access_with&amp;lt;EC&amp;gt; should be thrown on incorrect wide value observation. The primary purpose of this policy is to enable standing in for  P0323 std::expected&amp;lt;T, E&amp;gt; which throws a bad_expected_access&amp;lt;E&amp;gt; on incorrect wide value observation. This is why it is only ever EC which is thrown with bad_result_access_with&amp;lt;EC&amp;gt; on value observation only, and only when there is an error available.
If used in basic_outcome, and the outcome is exceptioned and so no error is available, incorrect wide value observation performs instead:</description>
    </item>
    
    <item>
      <title>`type_can_be_used_in_basic_result&lt;R&gt;`</title>
      <link>https://ned14.github.io/outcome/reference/traits/type_can_be_used_in_basic_result/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/traits/type_can_be_used_in_basic_result/</guid>
      <description>A constexpr boolean true for types permissible in basic_result&amp;lt;T, E, NoValuePolicy&amp;gt;.
Overridable: Not overridable.
Definition: True for a type which:
 Is not a reference. Is not an in_place_type_t&amp;lt;T&amp;gt; . Is not a success_type&amp;lt;T&amp;gt; . Is not a failure_type&amp;lt;EC, EP = void&amp;gt; . Is not an array. Is either void, or else is an Object and is Destructible.  Namespace: OUTCOME_V2_NAMESPACE::trait
Header: &amp;lt;outcome/trait.hpp&amp;gt;</description>
    </item>
    
    <item>
      <title>`uint16_t spare_storage(const basic_result|basic_outcome *) noexcept`</title>
      <link>https://ned14.github.io/outcome/reference/functions/hooks/spare_storage/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/functions/hooks/spare_storage/</guid>
      <description>Returns the sixteen bits of spare storage in the specified result or outcome. You can set these bits using void set_spare_storage(basic_result|basic_outcome *, uint16_t) noexcept .
Overridable: Not overridable.
Requires: Nothing.
Namespace: OUTCOME_V2_NAMESPACE::hooks
Header: &amp;lt;outcome/basic_result.hpp&amp;gt;</description>
    </item>
    
    <item>
      <title>`unchecked&lt;T, E = varies&gt;`</title>
      <link>https://ned14.github.io/outcome/reference/aliases/unchecked/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/aliases/unchecked/</guid>
      <description>A type alias to either std_unchecked&amp;lt;T, E = std::error_code&amp;gt; (standalone edition) or boost_unchecked&amp;lt;T, E = boost::system::error_code&amp;gt; (Boost edition). This means that unchecked&amp;lt;T&amp;gt; uses the appropriate default alias depending on which edition of Outcome is in use.
Namespace: OUTCOME_V2_NAMESPACE
Header: &amp;lt;outcome/result.hpp&amp;gt;</description>
    </item>
    
    <item>
      <title>`value_or_error&lt;T, U&gt;`</title>
      <link>https://ned14.github.io/outcome/reference/converters/value_or_error/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/converters/value_or_error/</guid>
      <description>A customisable converter of concepts::value_or_error&amp;lt;T, E&amp;gt; concept matching types. It must have the following form:
// `T` will be the destination basic_result or basic_outcome. // `U` will be the decayed form of the `value_or_error&amp;lt;T, E&amp;gt;` concept matching input type. template &amp;lt;classT&amp;gt; struct value_or_error&amp;lt;T, U&amp;gt; { // False to indicate that this converter wants `basic_result`/`basic_outcome` to reject all other `basic_result`  static constexpr bool enable_result_inputs = false; // False to indicate that this converter wants `basic_outcome` to reject all other `basic_outcome`  static constexpr bool enable_outcome_inputs = false; // `X` will be the raw input form of `U`.</description>
    </item>
    
    <item>
      <title>`value_or_error&lt;T&gt;`</title>
      <link>https://ned14.github.io/outcome/reference/concepts/value_or_error/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/concepts/value_or_error/</guid>
      <description>If on C++ 20 or the Concepts TS is enabled, a boolean concept matching types with a public .has_value() observer which returns bool, a public .value() observer function, and a public .error() observer function.
If without Concepts, a static constexpr bool which is true for types matching the same requirements, using a SFINAE based emulation.
This concept matches expected-like types such as  P0323 std::expected&amp;lt;T, E&amp;gt; , one of which is basic_result&amp;lt;T, E, NoValuePolicy&amp;gt; .</description>
    </item>
    
    <item>
      <title>`value_or_none&lt;T&gt;`</title>
      <link>https://ned14.github.io/outcome/reference/concepts/value_or_none/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/concepts/value_or_none/</guid>
      <description>If on C++ 20 or the Concepts TS is enabled, a boolean concept matching types with a public .has_value() observer which returns bool, and a public .value() observer function.
If without Concepts, a static constexpr bool which is true for types matching the same requirements, using a SFINAE based emulation.
This concept matches optional-like types such as  std::optional&amp;lt;T&amp;gt; . Note it also matches  P0323 std::expected&amp;lt;T, E&amp;gt; , which also has an optional-like interface.</description>
    </item>
    
    <item>
      <title>`void hook_outcome_construction(T *, U &amp;&amp;) noexcept`</title>
      <link>https://ned14.github.io/outcome/reference/functions/hooks/hook_outcome_construction/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/functions/hooks/hook_outcome_construction/</guid>
      <description>Removed in Outcome v2.2.0, unless OUTCOME_ENABLE_LEGACY_SUPPORT_FOR is set to less than 220 to enable emulation. Use on_outcome_construction(T *, U &amp;amp;&amp;amp;) noexcept instead in new code.
One of the constructor hooks for basic_outcome&amp;lt;T, EC, EP, NoValuePolicy&amp;gt; , generally invoked by the implicit constructors of basic_outcome. See each constructor&amp;rsquo;s documentation to see which specific hook it invokes.
Overridable: By Argument Dependent Lookup.
Requires: Nothing.
Namespace: OUTCOME_V2_NAMESPACE::hooks
Header: &amp;lt;outcome/basic_outcome.hpp&amp;gt;</description>
    </item>
    
    <item>
      <title>`void hook_outcome_construction(T *, U &amp;&amp;, V &amp;&amp;) noexcept`</title>
      <link>https://ned14.github.io/outcome/reference/functions/hooks/hook_outcome_construction2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/functions/hooks/hook_outcome_construction2/</guid>
      <description>Removed in Outcome v2.2.0, unless OUTCOME_ENABLE_LEGACY_SUPPORT_FOR is set to less than 220 to enable emulation. Use on_outcome_construction(T *, U &amp;amp;&amp;amp;, V &amp;amp;&amp;amp;) noexcept instead in new code.
One of the constructor hooks for basic_outcome&amp;lt;T, EC, EP, NoValuePolicy&amp;gt; , generally invoked by the implicit constructors of basic_outcome which consume two arguments. See each constructor&amp;rsquo;s documentation to see which specific hook it invokes.
Overridable: By Argument Dependent Lookup.
Requires: Nothing.
Namespace: OUTCOME_V2_NAMESPACE::hooks</description>
    </item>
    
    <item>
      <title>`void hook_outcome_copy_construction(T *, U &amp;&amp;) noexcept`</title>
      <link>https://ned14.github.io/outcome/reference/functions/hooks/hook_outcome_copy_construction/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/functions/hooks/hook_outcome_copy_construction/</guid>
      <description>Removed in Outcome v2.2.0, unless OUTCOME_ENABLE_LEGACY_SUPPORT_FOR is set to less than 220 to enable emulation. Use on_outcome_copy_construction(T *, U &amp;amp;&amp;amp;) noexcept instead in new code.
One of the constructor hooks for basic_outcome&amp;lt;T, EC, EP, NoValuePolicy&amp;gt; , generally invoked by the converting copy constructors of basic_outcome (NOT the standard copy constructor). See each constructor&amp;rsquo;s documentation to see which specific hook it invokes.
Overridable: By Argument Dependent Lookup.
Requires: Nothing.
Namespace: OUTCOME_V2_NAMESPACE::hooks</description>
    </item>
    
    <item>
      <title>`void hook_outcome_copy_construction(T *, U &amp;&amp;, V &amp;&amp;) noexcept`</title>
      <link>https://ned14.github.io/outcome/reference/functions/hooks/hook_outcome_copy_construction2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/functions/hooks/hook_outcome_copy_construction2/</guid>
      <description>Removed in Outcome v2.2.0, unless OUTCOME_ENABLE_LEGACY_SUPPORT_FOR is set to less than 220 to enable emulation. Use on_outcome_copy_construction(T *, U &amp;amp;&amp;amp;, V &amp;amp;&amp;amp;) noexcept instead in new code.
One of the constructor hooks for basic_outcome&amp;lt;T, EC, EP, NoValuePolicy&amp;gt; , generally invoked by the converting copy constructors of basic_outcome (NOT the standard copy constructor) which consume two arguments. See each constructor&amp;rsquo;s documentation to see which specific hook it invokes.
Overridable: By Argument Dependent Lookup.</description>
    </item>
    
    <item>
      <title>`void hook_outcome_in_place_construction(T *, in_place_type_t&lt;U&gt;, Args &amp;&amp;...) noexcept`</title>
      <link>https://ned14.github.io/outcome/reference/functions/hooks/hook_outcome_in_place_construction/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/functions/hooks/hook_outcome_in_place_construction/</guid>
      <description>Removed in Outcome v2.2.0, unless OUTCOME_ENABLE_LEGACY_SUPPORT_FOR is set to less than 220 to enable emulation. Use on_outcome_in_place_construction(T *, in_place_type_t&amp;lt;U&amp;gt;, Args &amp;amp;&amp;amp;...) noexcept instead in new code.
One of the constructor hooks for basic_outcome&amp;lt;T, EC, EP, NoValuePolicy&amp;gt; , generally invoked by the in-place constructors of basic_outcome. See each constructor&amp;rsquo;s documentation to see which specific hook it invokes.
Overridable: By Argument Dependent Lookup.
Requires: Nothing.
Namespace: OUTCOME_V2_NAMESPACE::hooks
Header: &amp;lt;outcome/basic_outcome.hpp&amp;gt;</description>
    </item>
    
    <item>
      <title>`void hook_outcome_move_construction(T *, U &amp;&amp;) noexcept`</title>
      <link>https://ned14.github.io/outcome/reference/functions/hooks/hook_outcome_move_construction/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/functions/hooks/hook_outcome_move_construction/</guid>
      <description>Removed in Outcome v2.2.0, unless OUTCOME_ENABLE_LEGACY_SUPPORT_FOR is set to less than 220 to enable emulation. Use on_outcome_move_construction(T *, U &amp;amp;&amp;amp;) noexcept instead in new code.
One of the constructor hooks for basic_outcome&amp;lt;T, EC, EP, NoValuePolicy&amp;gt; , generally invoked by the converting move constructors of basic_outcome (NOT the standard move constructor). See each constructor&amp;rsquo;s documentation to see which specific hook it invokes.
Overridable: By Argument Dependent Lookup.
Requires: Nothing.
Namespace: OUTCOME_V2_NAMESPACE::hooks</description>
    </item>
    
    <item>
      <title>`void hook_outcome_move_construction(T *, U &amp;&amp;, V &amp;&amp;) noexcept`</title>
      <link>https://ned14.github.io/outcome/reference/functions/hooks/hook_outcome_move_construction2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/functions/hooks/hook_outcome_move_construction2/</guid>
      <description>Removed in Outcome v2.2.0, unless OUTCOME_ENABLE_LEGACY_SUPPORT_FOR is set to less than 220 to enable emulation. Use on_outcome_move_construction(T *, U &amp;amp;&amp;amp;, V &amp;amp;&amp;amp;) noexcept instead in new code.
One of the constructor hooks for basic_outcome&amp;lt;T, EC, EP, NoValuePolicy&amp;gt; , generally invoked by the converting move constructors of basic_outcome (NOT the standard move constructor) which consume two arguments. See each constructor&amp;rsquo;s documentation to see which specific hook it invokes.
Overridable: By Argument Dependent Lookup.</description>
    </item>
    
    <item>
      <title>`void hook_result_construction(T *, U &amp;&amp;) noexcept`</title>
      <link>https://ned14.github.io/outcome/reference/functions/hooks/hook_result_construction/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/functions/hooks/hook_result_construction/</guid>
      <description>Removed in Outcome v2.2.0, unless OUTCOME_ENABLE_LEGACY_SUPPORT_FOR is set to less than 220 to enable emulation. Use on_result_construction(T *, U &amp;amp;&amp;amp;) noexcept instead in new code.
One of the constructor hooks for basic_result&amp;lt;T, E, NoValuePolicy&amp;gt; , generally invoked by the implicit constructors of basic_result. See each constructor&amp;rsquo;s documentation to see which specific hook it invokes.
Overridable: By Argument Dependent Lookup.
Requires: Nothing.
Namespace: OUTCOME_V2_NAMESPACE::hooks
Header: &amp;lt;outcome/basic_result.hpp&amp;gt;</description>
    </item>
    
    <item>
      <title>`void hook_result_copy_construction(T *, U &amp;&amp;) noexcept`</title>
      <link>https://ned14.github.io/outcome/reference/functions/hooks/hook_result_copy_construction/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/functions/hooks/hook_result_copy_construction/</guid>
      <description>Removed in Outcome v2.2.0, unless OUTCOME_ENABLE_LEGACY_SUPPORT_FOR is set to less than 220 to enable emulation. Use on_result_copy_construction(T *, U &amp;amp;&amp;amp;) noexcept instead in new code.
One of the constructor hooks for basic_result&amp;lt;T, E, NoValuePolicy&amp;gt; , generally invoked by the converting copy constructors of basic_result (NOT the standard copy constructor). See each constructor&amp;rsquo;s documentation to see which specific hook it invokes.
Overridable: By Argument Dependent Lookup.
Requires: Nothing.
Namespace: OUTCOME_V2_NAMESPACE::hooks
Header: &amp;lt;outcome/basic_result.</description>
    </item>
    
    <item>
      <title>`void hook_result_in_place_construction(T *, in_place_type_t&lt;U&gt;, Args &amp;&amp;...) noexcept`</title>
      <link>https://ned14.github.io/outcome/reference/functions/hooks/hook_result_in_place_construction/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/functions/hooks/hook_result_in_place_construction/</guid>
      <description>Removed in Outcome v2.2.0, unless OUTCOME_ENABLE_LEGACY_SUPPORT_FOR is set to less than 220 to enable emulation. Use on_result_in_place_construction(T *, in_place_type_t&amp;lt;U&amp;gt;, Args &amp;amp;&amp;amp;...) noexcept instead in new code.
One of the constructor hooks for basic_result&amp;lt;T, E, NoValuePolicy&amp;gt; , generally invoked by the in-place constructors of basic_result. See each constructor&amp;rsquo;s documentation to see which specific hook it invokes.
Overridable: By Argument Dependent Lookup.
Requires: Nothing.
Namespace: OUTCOME_V2_NAMESPACE::hooks
Header: &amp;lt;outcome/basic_result.hpp&amp;gt;</description>
    </item>
    
    <item>
      <title>`void hook_result_move_construction(T *, U &amp;&amp;) noexcept`</title>
      <link>https://ned14.github.io/outcome/reference/functions/hooks/hook_result_move_construction/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/functions/hooks/hook_result_move_construction/</guid>
      <description>Removed in Outcome v2.2.0, unless OUTCOME_ENABLE_LEGACY_SUPPORT_FOR is set to less than 220 to enable emulation. Use on_result_move_construction(T *, U &amp;amp;&amp;amp;) noexcept instead in new code.
One of the constructor hooks for basic_result&amp;lt;T, E, NoValuePolicy&amp;gt; , generally invoked by the converting move constructors of basic_result (NOT the standard move constructor). See each constructor&amp;rsquo;s documentation to see which specific hook it invokes.
Overridable: By Argument Dependent Lookup.
Requires: Nothing.
Namespace: OUTCOME_V2_NAMESPACE::hooks
Header: &amp;lt;outcome/basic_result.</description>
    </item>
    
    <item>
      <title>`void outcome_throw_as_system_error_with_payload(BoostErrorCodeEnum &amp;&amp;)`</title>
      <link>https://ned14.github.io/outcome/reference/functions/policy/outcome_throw_as_system_error_with_payload_boost_enum/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/functions/policy/outcome_throw_as_system_error_with_payload_boost_enum/</guid>
      <description>A specialisation of outcome_throw_as_system_error_with_payload() for types where boost::system::is_error_code_enum&amp;lt;BoostErrorCodeEnum&amp;gt; or boost::system::is_error_condition_enum&amp;lt;BoostErrorCodeEnum&amp;gt; is true. This executes OUTCOME_THROW_EXCEPTION(expr) with a boost::system::system_error constructed from the result of the ADL discovered free function make_error_code(BoostErrorCodeEnum).
Overridable: Argument dependent lookup.
Requires: Either boost::system::is_error_code_enum&amp;lt;T&amp;gt; or boost::system::is_error_condition_enum&amp;lt;T&amp;gt; to be true for a decayed BoostErrorCodeEnum.
Namespace: boost::system
Header: &amp;lt;outcome/boost_result.hpp&amp;gt;</description>
    </item>
    
    <item>
      <title>`void outcome_throw_as_system_error_with_payload(ErrorCodeEnum &amp;&amp;)`</title>
      <link>https://ned14.github.io/outcome/reference/functions/policy/outcome_throw_as_system_error_with_payload_std_enum/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/functions/policy/outcome_throw_as_system_error_with_payload_std_enum/</guid>
      <description>A specialisation of outcome_throw_as_system_error_with_payload() for types where std::is_error_code_enum&amp;lt;ErrorCodeEnum&amp;gt; or std::is_error_condition_enum&amp;lt;ErrorCodeEnum&amp;gt; is true. This executes OUTCOME_THROW_EXCEPTION(expr) with a  std::system_error constructed from the result of the ADL discovered free function make_error_code(ErrorCodeEnum).
Overridable: Argument dependent lookup.
Requires: Either  std::is_error_code_enum&amp;lt;T&amp;gt; or  std::is_error_condition_enum&amp;lt;T&amp;gt; to be true for a decayed ErrorCodeEnum.
Namespace: std
Header: &amp;lt;outcome/std_result.hpp&amp;gt;</description>
    </item>
    
    <item>
      <title>`void outcome_throw_as_system_error_with_payload(const boost::system::error_code &amp;)`</title>
      <link>https://ned14.github.io/outcome/reference/functions/policy/outcome_throw_as_system_error_with_payload_boost_error_code/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/functions/policy/outcome_throw_as_system_error_with_payload_boost_error_code/</guid>
      <description>A specialisation of outcome_throw_as_system_error_with_payload() for boost::system::error_code. This executes OUTCOME_THROW_EXCEPTION(expr) with a boost::system::system_error constructed from the input.
Overridable: Argument dependent lookup.
Requires: Nothing.
Namespace: boost::system
Header: &amp;lt;outcome/boost_result.hpp&amp;gt;</description>
    </item>
    
    <item>
      <title>`void outcome_throw_as_system_error_with_payload(const std::error_code &amp;)`</title>
      <link>https://ned14.github.io/outcome/reference/functions/policy/outcome_throw_as_system_error_with_payload_std_error_code/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/functions/policy/outcome_throw_as_system_error_with_payload_std_error_code/</guid>
      <description>A specialisation of outcome_throw_as_system_error_with_payload() for std::error_code. This executes OUTCOME_THROW_EXCEPTION(expr) with a  std::system_error constructed from the input.
Overridable: Argument dependent lookup.
Requires: Nothing.
Namespace: std
Header: &amp;lt;outcome/std_result.hpp&amp;gt;</description>
    </item>
    
    <item>
      <title>`void override_outcome_exception(basic_outcome&lt;T, EC, EP, NoValuePolicy&gt; *, U &amp;&amp;) noexcept`</title>
      <link>https://ned14.github.io/outcome/reference/functions/hooks/override_outcome_exception/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/functions/hooks/override_outcome_exception/</guid>
      <description>Overrides the exception to something other than what was constructed. You almost certainly never want to use this function. A much better way of overriding the exception returned is to create a custom no-value policy which lazily synthesises a custom exception object at the point of need.
The only reason that this function exists is because some people have very corner case needs where a custom no-value policy can&amp;rsquo;t be used, and where move-constructing a new outcome from an old outcome with the exception state replaced isn&amp;rsquo;t possible (e.</description>
    </item>
    
    <item>
      <title>`void set_spare_storage(basic_result|basic_outcome *, uint16_t) noexcept`</title>
      <link>https://ned14.github.io/outcome/reference/functions/hooks/set_spare_storage/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/functions/hooks/set_spare_storage/</guid>
      <description>Sets the sixteen bits of spare storage in the specified result or outcome. You can retrieve these bits later using uint16_t spare_storage(const basic_result|basic_outcome *) noexcept .
Overridable: Not overridable.
Requires: Nothing.
Namespace: OUTCOME_V2_NAMESPACE::hooks
Header: &amp;lt;outcome/basic_result.hpp&amp;gt;</description>
    </item>
    
    <item>
      <title>`void strong_swap(bool &amp;all_good, T &amp;a, T &amp;b)`</title>
      <link>https://ned14.github.io/outcome/reference/functions/strong_swap/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/functions/strong_swap/</guid>
      <description>The standard swap() function provides the weak guarantee i.e. that no resources are lost. This ADL discovered function provides the strong guarantee instead: that if any of these operations throw an exception (i) move construct to temporary (ii) move assign b to a (iii) move assign temporary to b, an attempt is made to restore the exact pre-swapped state upon entry, and if that recovery too fails, then the boolean all_good will be false during stack unwind from the exception throw, to indicate that state has been lost.</description>
    </item>
    
    <item>
      <title>`void try_throw_std_exception_from_error(std::error_code ec, const std::string &amp;msg = std::string{})`</title>
      <link>https://ned14.github.io/outcome/reference/functions/try_throw_std_exception_from_error/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/reference/functions/try_throw_std_exception_from_error/</guid>
      <description>This function saves writing boilerplate by throwing a standard library exception type equivalent to the supplied error code, with an optional custom message.
If the function returns, there is no standard library exception type equivalent to the supplied error code. The following codes produce the following exception throws:
 EINVAL std::invalid_argument EDOM std::domain_error E2BIG std::length_error ERANGE std::out_of_range EOVERFLOW std::overflow_error ENOMEM std::bad_alloc  The choice to refer to POSIX errno values above reflects the matching algorithm.</description>
    </item>
    
  </channel>
</rss>