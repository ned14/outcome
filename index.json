[
{
	"uri": "https://ned14.github.io/outcome/requirements/",
	"title": "Prerequisites",
	"tags": [],
	"description": "",
	"content": "Outcome is a header-only C++ 14 library known to work well on the latest point releases of these compiler-platform combinations or better:\n clang 4.0.1 (LLVM) [FreeBSD, Linux, OS X] GCC 6.5 [Linux] Visual Studio 2017.9 [Windows] XCode 9 [MacOS]  For non-Windows non-POSIX platforms (typically embedded systems), Outcome is usable in its Outcome.Experimental form with the macro SYSTEM_ERROR2_NOT_POSIX defined.\nIt is worth turning on C++ 17 or C++ 20 if you can, as there are many usability and performance improvements. Any Concepts TS or Coroutines TS implemented by your compiler is automatically detected and used.\nKnown compiler issues (this was last updated April 2023):\n clang 3.5 - 3.9 can compile varying degrees of the test suite, the problem is lack of complete and unbuggy C++ 14 language support.\n Older point releases of GCCs 7 and 8 have internal compiler error bugs in their constexpr implementation which tend to be triggered by using Outcome in constexpr. If you don\u0026rsquo;t use Outcome in constexpr, you won\u0026rsquo;t see these problems. If you need your GCC to not ICE, upgrade to the very latest point release, the constexpr ICE has been since fixed.\n Early editions of Visual Studio 2017 have many corner case problems. From VS2017.9 onwards there remain a number of usually untroublesome corner case issues, but use should be relatively unsurprising for most use cases. Be aware that only from Visual Studio 2022 onwards are almost all corner case problems fixed.\n Some point releases of GCC 10 with libstdc++ 10 can induce an infinite template instantiation, which fails the build for some rare use cases. Earlier or later GCCs or different point releases of the 10 series do not have this issue.\n  \u0026ldquo;C++ 14\u0026rdquo; compilers which do not work, and will not work until their maintainers fix them:\n GCC 5, due to a bug in nested template variables parsing which was fixed in GCC 6. I appreciate that this upsets a lot of users. Please raise your upset at https://gcc.gnu.org/bugzilla/. In the meantime, you can get fairly far in Outcome with even clang 3.5. Any compiler which uses the libstdc++ version which comes with GCC 5, as it does not implement enough of the C++ 14 standard library for Outcome to compile.  "
},
{
	"uri": "https://ned14.github.io/outcome/build/",
	"title": "Build and install",
	"tags": [],
	"description": "",
	"content": " Usage as a single header file Outcome v2 comes in single header file form. This is regenerated per commit. To fetch on Linux:\nwget https://github.com/ned14/outcome/raw/master/single-header/outcome.hpp  On BSD:\nfetch https://github.com/ned14/outcome/raw/master/single-header/outcome.hpp  If you have curl installed:\ncurl -O -J -L https://github.com/ned14/outcome/raw/master/single-header/outcome.hpp  Otherwise, simply download the raw file from above and place it wherever it suits you. If you might be debugging using Microsoft Visual Studio, you may find the debugger visualisation file at https://github.com/ned14/outcome/raw/master/include/outcome/outcome.natvis useful to include into your build.\nUsage from the vcpkg package manager This is particularly easy, and works on Mac OS, Linux and Microsoft Windows:\nvcpkg install outcome  Outcome appears at \u0026lt;outcome/outcome.hpp\u0026gt;. This is a full copy of Outcome, so Experimental Outcome and all the usual headers are where you would expect.\nUsage from the Conan package manager (thanks to Th√©o Delrieu for contributing this support)\nAt the command line, add the bintray repo for Outcome to conan:\nconan remote add outcome https://api.bintray.com/conan/ned14/Outcome  Now simply add this to your Conan build:\n[requires] Outcome/master@ned14/stable  Outcome will be made available by Conan at \u0026lt;outcome.hpp\u0026gt;.\nUsage from the cmake hunter package manager Outcome has not been submitted to the main cmake hunter package manager repo yet. You can however add it as a git submodule:\ncd yourthirdpartyrepodir git submodule add https://github.com/ned14/quickcpplib git submodule add https://github.com/ned14/outcome cd .. git submodule update --init --recursive  Now tell cmake hunter about a git submoduled cmake hunter package by adding to your project\u0026rsquo;s cmake/Hunter/config.cmake:\nhunter_config(quickcpplib GIT_SUBMODULE \u0026quot;yourthirdpartyrepodir/quickcpplib\u0026quot;) hunter_config(outcome GIT_SUBMODULE \u0026quot;yourthirdpartyrepodir/outcome\u0026quot;)  \u0026hellip; and finally to your CMakeLists.txt, now add outcome as if it were an ordinary cmake hunter package:\nhunter_add_package(quickcpplib) find_package(quickcpplib CONFIG REQUIRED) hunter_add_package(outcome) find_package(outcome CONFIG REQUIRED)  Now you tell cmake to link to outcome as usual (see below for cmake targets):\ntarget_link_libraries(mytarget outcome::hl)  Usage as a git submodule If you are very keen on tracking very latest Outcome, you can add it as a git submodule to your project so you can keep abreast of bug fixes. Here is how:\ngit submodule add https://github.com/ned14/outcome cd outcome git checkout master git submodule update --init --recursive  After this you can bring Outcome into your code using:\n#include \u0026quot;outcome/single-header/outcome.hpp\u0026quot;  That\u0026rsquo;s it, you are ready to go. From time to time, you may wish to update to latest:\ncd outcome git pull git submodule update  Usage as a stable source tarball If you would prefer a single source tarball of the stable and develop branches known to have had all unit tests passing on all platforms, containing all the documentation, tests and sources, this can always be retrieved from:\nhttps://github.com/ned14/outcome/releases\nThis tarball is automatically generated when Outcome fully compiles and passes all unit tests on all platforms tested by the CIs. This currently includes:\n Linux: GCC 7.5, clang 9, clang 11 MacOS: XCode 12 Windows: VS2019.7  All unit tests are executed under the Address and Undefined Behaviour sanitisers.\nIt should be emphasised that newer compilers are not tested, so there is an unlikely chance that the tarball may not work on a newer compiler.\n Running the unit test suite To run the unit test suite you will need cmake 3.3 or later installed.\nmkdir build cd build cmake .. cmake --build . ctest  On some cmake generators (Visual Studio, Xcode) you may need to tell cmake build a configuration like Release or Debug. Similarly, ctest needs to be told the same e.g.\nmkdir build cd build cmake .. cmake --build . --config Release ctest -C Release  Per commit, tests are run by Travis and uploaded to a CDash dashboard here.\n CMake find_package() imported targets support Outcome fully complies with cmake install, so by installing Outcome, it can be found by cmake\u0026rsquo;s find_package().\nmkdir build cd build cmake .. cmake --build . sudo cmake --build . --target install  Modular CMake build support If you are using Outcome in a CMake project, Outcome is a \u0026ldquo;modular cmake\u0026rdquo; project using only modern cmake 3 throughout. This lets you add the Outcome directory as a cmake subdirectory with no unexpected consequence on the rest of your cmake. You will need to be using cmake 3.3 or better.\nadd_subdirectory( \u0026quot;${CMAKE_CURRENT_SOURCE_DIR}/outcome\u0026quot; # path to outcome source \u0026quot;${CMAKE_CURRENT_BINARY_DIR}/outcome\u0026quot; # your choice of where to put binaries EXCLUDE_FROM_ALL # please only lazy build outcome on demand )  Outcome\u0026rsquo;s cmake has the following useful products:\n outcome::hl (target): the Outcome header-only library. Add this to any target_link_libraries() in your cmake to bring in Outcome as a header-only library. This will also add to your link (via PUBLIC) any debugger visualisation support files, any system library dependencies and also force all consuming executables to be configured with a minimum of C++ 14 as Outcome requires a minimum of that. outcome_TEST_TARGETS (list): a list of targets which generate Outcome\u0026rsquo;s test suite. You can append this to your own test suite if you wish to run Outcome\u0026rsquo;s test suite along with your own.  "
},
{
	"uri": "https://ned14.github.io/outcome/tutorial/essential/before/",
	"title": "Before we begin",
	"tags": ["namespace", "playpen"],
	"description": "Essential information before you begin the tutorial.",
	"content": " Outcome v2 namespace It is recommended that you refer to entities from this Outcome v2 via the following namespace alias:\nnamespace outcome = OUTCOME_V2_NAMESPACE; View this code on Github On standalone Outcome only, as patches and modifications are applied to this library, namespaces get permuted in order to not to cause binary incompatibility. At some point namespace outcome_v2 will be defined, and this will be the preferred namespace. Until then OUTCOME_V2_NAMESPACE denotes the most recently updated version, getting closer to outcome_v2.\nOn Boost.Outcome only, as Boost provides no binary compatibility across releases, OUTCOME_V2_NAMESPACE always expands into boost::outcome_v2.\nOnline compilers If you\u0026rsquo;ve never used them before, you will find Godbolt and Wandbox invaluable. These let you play with C++ inside your web browser.\nMost of the source code snippets in Outcome have a link in their top right to the original source code on github. You can copy and paste this source code into Godbolt (if you wish to study the assembler generated) or Wandbox (if you wish to run the program).\nGodbolt Godbolt is invaluable for visualising online the assembler generated for a piece of C++, for all the major compilers and CPU architectures.\nStandalone Outcome is built into Godbolt! In the right hand pane toolbar, click the libraries dropdown (currently third from the right, looks like a book), find Outcome and choose the version you want.\nAfter this is selected, you can #include any of these editions of Outcome:\n \u0026lt;outcome-basic.hpp\u0026gt; An inclusion of basic_outcome.hpp + try.hpp which includes as few system headers as possible in order to give an absolute minimum compile time impact edition of Outcome. See https://github.com/ned14/stl-header-heft.  \u0026lt;outcome-experimental.hpp\u0026gt; An inclusion of experimental/status_outcome.hpp + try.hpp which is the low compile time impact of the basic edition combined with status_code from https://ned14.github.io/status-code/. If you are on an embedded system where binary bloat must be absolutely avoided, and don't mind the potentially unstable status_code, this is definitely the edition for you.  \u0026lt;outcome.hpp\u0026gt; An inclusion of outcome.hpp which brings in all the specialisations for the std STL types, plus iostreams support. If you don't know which edition to use, you should use this one, it ought to \"just work\".  Here is the first tutorial topic\u0026rsquo;s source code loaded into Godbolt: https://godbolt.org/z/4of3c8\nWandbox Wandbox lets you place a third party header into a separate tab. It also comes with a recent Boost libraries. Either technique can be used to explore Outcome.\nHere is the first tutorial topic\u0026rsquo;s source code loaded into Wandbox: https://wandbox.org/permlink/sJoeKHXSyCU5Avft\n"
},
{
	"uri": "https://ned14.github.io/outcome/tutorial/advanced/interop/problem/",
	"title": "Incommensurate E types",
	"tags": [],
	"description": "",
	"content": "Back in the essential tutorial section on result, we studied a likely very common initial choice of E type: a strongly typed enum. We saw how by marking up strongly typed enums to tell the C++ standard library what they are, they gain implicit convertibility into std::error_code, and we then pointed out that you might as well now always set E = std::error_code, as that comes with the enormous advantage that you can use the boilerplate saving OUTCOME_TRY macro when the E type is always the same.\nWe thus strongly recommend to users that for any given piece of code, always using the same E type across the codebase is very wise, except where you explicitly want to prevent implicit propagation of failure up a call stack e.g. local failures in some domain specific piece of code.\nHowever it is unreasonable to expect that any non-trivial codebase can make do with E = std::error_code. This is why Outcome allows you to use custom E types which carry payload in addition to an error code, yet still have that custom type treated as if a std::error_code, including lazy custom exception throw synthesis.\nAll this is good, but if library A uses result\u0026lt;T, libraryA::failure_info\u0026gt;, and library B uses result\u0026lt;T, libraryB::error_info\u0026gt; and so on, there becomes a problem for the application writer who is bringing in these third party dependencies and tying them together into an application. As a general rule, each third party library author will not have built in explicit interoperation support for unknown other third party libraries. The problem therefore lands with the application writer.\nThe application writer has one of three choices:\n In the application, the form of result used is result\u0026lt;T, std::variant\u0026lt;E1, E2, ...\u0026gt;\u0026gt; where E1, E2 \u0026hellip; are the failure types for every third party library in use in the application. This has the advantage of preserving the original information exactly, but comes with a certain amount of use inconvenience and maybe excessive coupling between high level layers and implementation detail.\n One can translate/map the third party\u0026rsquo;s failure type into the application\u0026rsquo;s failure type at the point of the failure exiting the third party library and entering the application. One might do this, say, with a C preprocessor macro wrapping every invocation of the third party API from the application. This approach may lose the original failure detail, or mis-map under certain circumstances if the mapping between the two systems is not one-one.\n One can type erase the third party\u0026rsquo;s failure type into some application failure type, which can later be reconstituted if necessary. This is the cleanest solution with the least coupling issues and no problems with mis-mapping, but it almost certainly requires the use of malloc, which the previous two did not.\n  Things get even more complicated in the presence of callbacks. If in the callback you supply to library A, you call library B, you may need to insert switch statement maps or other mechanisms to convert library B\u0026rsquo;s failures into something library A can understand, and then somehow extract that out \u0026ndash; preferably without loss of original information \u0026ndash; into the application\u0026rsquo;s failure handling mechanism if library A subsequently returns failure as well. This implies transmitting state by which to track these interrelated pieces of failure data.\nLet us see what Outcome can do to help the application writer address some of these issues, next.\n"
},
{
	"uri": "https://ned14.github.io/outcome/experimental/advantages/",
	"title": "The main advantages",
	"tags": [],
	"description": "",
	"content": "The main advantages of choosing \u0026lt;outcome/experimental\u0026gt; over default Outcome:\n Codegen is tighter and less verbose1, sometimes remarkably so.\n Build time impact is markedly lower, barely above the inclusion of naked \u0026lt;basic_result.hpp\u0026gt;, as the STL allocator machinery and std::string et al is not dragged into inclusion by including \u0026lt;system_error\u0026gt;. Note that \u0026lt;outcome/experimental/status_outcome.hpp\u0026gt; bring in \u0026lt;exception\u0026gt;, however \u0026lt;outcome/experimental/status_result.hpp\u0026gt; brings in no extra system headers.\n More discipline is imposed on your use of Outcome, leading to less ambiguous code which is easier to optimise by the compiler, lower cost to maintain, and lower cognitive load to audit code based on experimental Outcome for correctness.\n Code written to \u0026lt;outcome/experimental\u0026gt; can be fairly easily dual targeted, with just a few switching type aliases, to default Outcome. This author has several Outcome-based libraries with identical source code which can target either configuration of Outcome. The experimental Outcome build regularly beats the default Outcome build in benchmarks by 2-3%, and the dual target source code, being written to tighter discipline, is faster and more deterministic in the default target than it was before the (non-trivial) port to \u0026lt;outcome/experimental\u0026gt;.\n If you want \u0026lsquo;official\u0026rsquo; C support, experimental Outcome is able to provide that in a way not possible for default Outcome which cannot make sufficiently strong C compatibility assumptions about std::error_code.\n  If you are building a codebase on top of Outcome expecting long term maintenance, the author\u0026rsquo;s personal recommendation is that you design, write, test and optimise it for \u0026lt;outcome/experimental\u0026gt;. What you ship to your customers ought to be targeted at default Outcome however, so employ type aliases and macros as appropriate to switch the build configuration for production releases. This is what the Outcome author does himself, to date with great success, despite the fundamental architectural differences between \u0026lt;system_error\u0026gt; and proposed \u0026lt;system_error2\u0026gt;.\n Boost.System\u0026rsquo;s error_code has incorporated some of the design improvements of experimental status_code, and produces codegen somewhere in between experimental status_code and std::error_code. [return]   "
},
{
	"uri": "https://ned14.github.io/outcome/tutorial/advanced/interop/value-or-error/",
	"title": "value_or_error Concept",
	"tags": ["value-or-error"],
	"description": "",
	"content": " Something not really mentioned until now is how Outcome interoperates with the proposed  P0323 std::expected\u0026lt;T, E\u0026gt; , whose design lands in between unchecked\u0026lt;T, E = varies\u0026gt; and checked\u0026lt;T, E = varies\u0026gt; (both of which are type aliases hard coding no-value policies as previously covered in this tutorial).\nExpected and Outcome are isomorphic to one another in design intent, but interoperation for code using Expected and Outcome ought to be seamless thanks to the proposed ValueOrError concept framework, a subset of which Outcome implements.\nThe explicit basic_result(concepts::value_or_error\u0026lt;T, E\u0026gt; \u0026amp;\u0026amp;) and explicit basic_outcome(concepts::value_or_error\u0026lt;T, E\u0026gt; \u0026amp;\u0026amp;) constructors will explicitly construct from any type matching the concepts::value_or_error\u0026lt;T, E\u0026gt; concept, which includes std::expected\u0026lt;A, B\u0026gt;, if A is constructible to X, and B is constructible to Y. The value_or_error concept in turn is true if and only if the input type has:\n A .has_value() observer returning a bool. .value() and .error() observers.  Implementation Outcome\u0026rsquo;s machinery for implementing concepts::value_or_error conversion is user extensible by injection of specialisations of the value_or_error\u0026lt;T, U\u0026gt; type into the OUTCOME_V2_NAMESPACE::convert namespace.\nOutcome\u0026rsquo;s default convert::value_or_error\u0026lt;T, U\u0026gt; implementation explicitly excludes Outcome result and outcome types from the default mechanism as there is a major gotcha: the value_or_error matched type\u0026rsquo;s .value() is often not callable in constexpr as it can throw, which makes this conversion mechanism pretty much useless for constexpr code. Besides, outcome has a converting constructor overload for result inputs which is constexpr capable.\nNote that if you do enable outcome inputs, a result will match an input outcome, but silently dropping any exception state. This is probably undesirable.\nExamples of how to implement your own convert::value_or_error\u0026lt;T, U\u0026gt; converter is demonstrated in the worked example, next.\n"
},
{
	"uri": "https://ned14.github.io/outcome/motivation/",
	"title": "Motivation",
	"tags": [],
	"description": "",
	"content": "This section describes techniques currently used to report and handle failures in functions, it also shows why these techniques might be insufficient.\nIf you just want to learn how to use Outcome library go straight to Tutorial section.\nMotivation section of this documentation is not complete yet.\n  Exceptions Exceptions with their good and bad sides.\n errno errno with their good and bad sides.\n Error codes Error codes with their good and bad sides.\n std::error_code Overview of std::error_code\n Plugging a library into std::error_code Illustrates how you can hook into the std::error_code system from the Standard Library in order to work with your own set of error codes.\n Plugging a library into boost::system::error_code Illustrates how you can hook into the boost::system::error_code system from Boost in order to work with your own set of error codes.\n Narrow contracts Describes narrow-contract functions that do not work for all input values, and advantage of using them.\n "
},
{
	"uri": "https://ned14.github.io/outcome/alternatives/",
	"title": "Review of Error Handling Frameworks",
	"tags": [],
	"description": "",
	"content": "Outcome started life in 2014, entered Boost as Boost.Outcome in 2018, and therefore was amongst the very first of the major alternative error handling frameworks to standard exception throws in C++. Since then, and sometimes in reaction to Outcome\u0026rsquo;s choice of design, alternative frameworks have appeared. This page tries to give a fairly even handed summary of those alternatives, and how they compare to Outcome in this author\u0026rsquo;s opinion.\nThese are listed in order of approximate availability to the C++ ecosystem i.e. in order of appearance.\n std exception throws Advantages and disadvantages of C++ exception throws\n std error codes Advantages and disadvantages of std::error_code\n std expected Advantages and disadvantages of std::expected\u0026lt;T, E\u0026gt;\n Outcome (proposed std result) Advantages and disadvantages of Outcome and its proposed std::result\u0026lt;T\u0026gt;\n LEAF Advantages and disadvantages of Lightweight Error Augmentation Framework\n My thanks to Emil Dotchevski for reviewing this summary and providing notes.\n"
},
{
	"uri": "https://ned14.github.io/outcome/abi-stability/",
	"title": "Future ABI stability guarantees",
	"tags": [],
	"description": "",
	"content": " At the end of December 2021, as had been intended and signposted from the beginning of development, standalone Outcome v2.2.3 locked its ABI such that any code built with this Outcome release shall link, without recompilation, with any code built with any future Outcome release. This means that going forth, you are guaranteed that if your library returns an outcome::result\u0026lt;T, E = varies, NoValuePolicy = policy::default_policy\u0026lt;T, E, void\u0026gt;\u0026gt; or outcome::outcome\u0026lt;T, EC = varies, EP = varies, NoValuePolicy = policy::default_policy\u0026lt;T, EC, EP\u0026gt;\u0026gt; from a public API, consumers of your library are guaranteed 100% compatibility with unrecompiled library binaries when using any future version of Outcome in consuming code.\nThis is a critical use case for many large scale production use cases in industry, and to my knowledge, no other Outcome-like alternative implements this guarantee at the time of writing1. Note also that Boost.Outcome comes with no ABI guarantees, as the dependencies within Boost that Boost.Outcome uses do not have a stable ABI guarantee.\nTo ensure this guarantee going forth, a per commit CI step has been added which tests Outcome against the v2.2.3 ABI using these tools:\n The ABI compliance checker (using its abi-dumper mode, not its translation unit parsing mode which is too brittle). Sourceware\u0026rsquo;s libabigail tooling.  Both tools are independent of one another, and whilst they test using the same mechanism (DWARF debug info extracted from an unoptimised shared library object), they have different implementations.\nABI testing implementation notes Outcome is a header only library, so to turn Outcome into a shared library suitable as input for these tools, we compile a dummy shared library which exports APIs which use Outcome. The coverage of that dummy shared library of Outcome is therefore what is actually ABI tested, rather than of Outcome itself. The dummy library locks the ABI for:\n basic_result\u0026lt;trivial type, std::error_code, all policies\u0026gt; (i.e. union storage layout) basic_outcome\u0026lt;trivial type, std::error_code, trivial type, all policies\u0026gt; basic_result\u0026lt;non-trivial type, std::error_code, all policies\u0026gt; (i.e. struct storage layout) basic_outcome\u0026lt;non-trivial type, std::error_code, std::exception_ptr, all policies\u0026gt; bad_result_access_with\u0026lt;std::error_code\u0026gt; bad_outcome_access atomic_eager\u0026lt;int\u0026gt; atomic_eager\u0026lt;basic_result\u0026lt;trivial type, std::error_code, all policies\u0026gt;\u0026gt; atomic_eager\u0026lt;basic_result\u0026lt;non-trivial type, std::error_code, all policies\u0026gt;\u0026gt; atomic_lazy\u0026lt;int\u0026gt; atomic_lazy\u0026lt;basic_result\u0026lt;trivial type, std::error_code, all policies\u0026gt;\u0026gt; atomic_lazy\u0026lt;basic_result\u0026lt;non-trivial type, std::error_code, all policies\u0026gt;\u0026gt; eager\u0026lt;int\u0026gt; eager\u0026lt;basic_result\u0026lt;trivial type, std::error_code, all policies\u0026gt;\u0026gt; eager\u0026lt;basic_result\u0026lt;non-trivial type, std::error_code, all policies\u0026gt;\u0026gt; lazy\u0026lt;int\u0026gt; lazy\u0026lt;basic_result\u0026lt;trivial type, std::error_code, all policies\u0026gt;\u0026gt; lazy\u0026lt;basic_result\u0026lt;non-trivial type, std::error_code, all policies\u0026gt;\u0026gt;  Obviously anything which any of these types touch in their implementation also gets locked in ABI, in so far as the ABI tool can deduce dependent types. If you examine the source code for the dummy shared library, you will see that we go out of our way to encode explicit lists of dependent types in template parameters, to ensure that the ABI tool definitely discovers everything.\nOutcome.Experimental has no ABI guarantees, as WG21 LEWG is actively modifying its design as it approaches the C++ standard.\n The following targets are tested for ABI stability:\n GCC 7.5 with libstdc++ configured with the C++ 14 standard and x64 architecture.\n GCC 9.3 with libstdc++ configured with the C++ 17 standard and x64 architecture.\n  At the time of writing, no POSIX implementation has guaranteed stability on its C++ 20 standard library ABI, so we do not test that.\nThere is currently no CI coverage of MSVC ABI stability. The ABI compliance checker can test MSVC binaries for ABI stability, however raising the ABI compliance checker on a Github Actions Windows test runner is quite a lot of work. Donations of sufficient test scripting would be welcome. Note that because the Windows and POSIX implementation is almost the same, ABI stability on POSIX will have strong impact on MSVC ABI stability i.e. MSVC ABI is unlikely to break, albeit without CI testing there are no guarantees.\n libstdc++ implements a strong ABI stability guarantee and thus any future std::expected\u0026lt;T, E\u0026gt; implementation it provides will be ABI stable. However Expected offers only a small subset of the functionality which outcome::result\u0026lt;T, E\u0026gt; provides. [return]   "
},
{
	"uri": "https://ned14.github.io/outcome/tutorial/essential/no-value/custom/",
	"title": "A custom no-value policy",
	"tags": [],
	"description": "",
	"content": "If you want your basic_outcome\u0026lt;\u0026gt; or basic_result\u0026lt;\u0026gt; instances to call std::abort() whenever .value() is called on an object that does not contain a value, or .error() is called on an object that does not contain an error, you will need to define your own no-value policy as follows:\nstruct abort_policy : outcome::policy::base { template \u0026lt;classImpl\u0026gt; static constexpr void wide_value_check(Impl \u0026amp;\u0026amp;self) { if(!base::_has_value(std::forward\u0026lt;Impl\u0026gt;(self))) std::abort(); } template \u0026lt;classImpl\u0026gt; static constexpr void wide_error_check(Impl \u0026amp;\u0026amp;self) { if(!base::_has_error(std::forward\u0026lt;Impl\u0026gt;(self))) std::abort(); } template \u0026lt;classImpl\u0026gt; static constexpr void wide_exception_check(Impl \u0026amp;\u0026amp;self) { if(!base::_has_exception(std::forward\u0026lt;Impl\u0026gt;(self))) std::abort(); } }; View this code on Github All policies ought to inherit from base in order to provide your policy implementation with the internal policy API for accessing and manipulating result and outcome state.\nOnce the policy is defined, you have to specify it when providing your own basic_outcome specialization:\ntemplate \u0026lt;typename T\u0026gt; using strictOutcome = // outcome::basic_outcome\u0026lt;T, std::error_code, std::exception_ptr, abort_policy\u0026gt;; View this code on Github "
},
{
	"uri": "https://ned14.github.io/outcome/experimental/map/",
	"title": "Approximate map between error code designs",
	"tags": [],
	"description": "",
	"content": "Much of the design of Boost.System (which went on to become \u0026lt;system_error\u0026gt;) has been retained in proposed \u0026lt;system_error2\u0026gt;, so an approximate map between \u0026lt;system_error2\u0026gt; and \u0026lt;system_error\u0026gt; and Boost.System can be given:\n  C++ 17 \u0026lt;system_error\u0026gt;Boost.SystemProposed \u0026lt;system_error2\u0026gt;  std::errc boost::system::errc experimental::errc (almost identical)  std::error_category boost::system::error_category experimental::status_code_domain  std::generic_category boost::system::generic_category experimental::generic_code_domain  std::system_category boost::system::system_category One of: experimental::posix_code_domain (POSIX systems) experimental::win32_code_domain (Microsoft Windows) experimental::nt_code_domain (Microsoft Windows)  Note that there are more precanned code categories though they require additional header inclusions: com_code, getaddrinfo_code.  std::error_condition boost::system::error_condition No equivalent (deliberately removed as hindsight proved it to be a design mistake leading to much confusing and hard to audit for correctness code)  std::error_code boost::system::error_code One of: experimental::status_code\u0026lt;DomainType\u0026gt; const experimental::status_code\u0026lt;void\u0026gt; \u0026amp; experimental::status_code\u0026lt;erased\u0026lt;intptr_t\u0026gt;\u0026gt; (aliased to experimental::system_code) experimental::errored_status_code\u0026lt;DomainType\u0026gt; const experimental::errored_status_code\u0026lt;void\u0026gt; \u0026amp; experimental::errored_status_code\u0026lt;erased\u0026lt;intptr_t\u0026gt;\u0026gt; (aliased to experimental::error)  The difference between status codes and errored status codes is that the latter are guaranteed to refer to a failure, whereas the former may refer to a success (including warnings and informationals).  std::system_error boost::system::system_error One of: const experimental::status_error\u0026lt;void\u0026gt; \u0026amp; experimental::status_error\u0026lt;DomainType\u0026gt;   As is obvious from the above, in \u0026lt;system_error2\u0026gt; one must be much more specific and accurate with respect to intent and specification and desired semantics than with \u0026lt;system_error\u0026gt;. Much ambiguity and incorrectness which flies silently in \u0026lt;system_error\u0026gt; will refuse to compile in \u0026lt;system_error2\u0026gt;.\n"
},
{
	"uri": "https://ned14.github.io/outcome/experimental/c-api/from-c/system_code/",
	"title": "C system error results",
	"tags": [],
	"description": "Status code&#39;s `std::error` in C",
	"content": "In v2.2.11, C Result support went from second tier to first tier status, and now you can create, query and manipulate a subset of Result types entirely from within C by including \u0026lt;outcome/experimental/result.h\u0026gt;.\nThe subset supported are those result\u0026lt;T, E\u0026gt; which are a status_result\u0026lt;T\u0026gt; i.e. the E is hardcoded to experimental::error which is the type erased runtime polymorphic holder for any errored status_code whose payload is not bigger than an intptr_t. This is the most useful subset of Outcome Experimental\u0026rsquo;s possible Result types, allowing arbitrary custom error coding schemes from any unknown source to work seamlessly with all others, including errors from the system or third party libraries.\nThe operations available to C are:\n CXX_DECLARE_RESULT_SYSTEM(ident, T) Declares to C a status_result type uniquely identified by ident. T is available at the member variable .value, and struct cxx_status_code_system is available at the member variable .error. If in C++, implements C extern functions for making successful and failure results of this type. If you call this from within C++, make SURE it is not within a extern \"C\" block! CXX_RESULT_SYSTEM(ident) A reference to a previously declared status_result type with unique ident. CXX_MAKE_RESULT_SYSTEM_SUCCESS(ident, expr) (needs C++ counterpart linked into final binary) This invokes the aforementioned extern function which creates a status_result with a successful value of type T. CXX_MAKE_RESULT_SYSTEM_FAILURE_POSIX(ident, expr) (needs C++ counterpart linked into final binary) This invokes the aforementioned extern function which creates a status_result with a failure of type posix_code representing a POSIX errno. CXX_MAKE_RESULT_SYSTEM_FAILURE_SYSTEM(ident, expr) (needs C++ counterpart linked into final binary) This invokes the aforementioned extern function which creates a status_result with a failure of type posix_code representing a POSIX errno if on POSIX; if on Windows then a failure of type win32_code representing a Win32 error code from a Windows API. CXX_RESULT_HAS_VALUE(r) Evaluates to 1 (true) if the input result has a value. CXX_RESULT_HAS_ERROR(r) Evaluates to 1 (true) if the input result has an error. CXX_RESULT_ERROR_IS_ERRNO(r) Evaluates to 1 (true) if the input result's error value is a code in the POSIX errno domain. CXX_RESULT_SYSTEM_TRY(expr) If the status_result returned by expr is errored, exit the current function returning the result. This obviously requires that the return type of the current function matches that of  expr. CXX_RESULT_SYSTEM_TRY(cleanup, expr) Same as the above, but execute cleanup just before exiting the function if returning failure. CXX_RESULT_SYSTEM_TRY(var, cleanup, expr) Same as the above, but set var equal to the result's .value on success. CXX_RESULT_SYSTEM_TRY(var, ident, cleanup, expr) Same as the above, but use ident as the return type instead. This allows the return type of the calling function to differ from that of expr. CXX_DECLARE_RESULT_SYSTEM_FROM_ENUM(ident, enum_name, uuid, {enum mapping-sequence, ...}) This declares to C an extern function which creates a status_result from a C enum. If in C++, it implements a quick_status_code_from_enum for the C enum and the associated extern function, and you will need to supply uuid and the appropriate enum value mapping sequence as per the quick_status_code_from_enum documentation. CXX_MAKE_RESULT_SYSTEM_FROM_ENUM(ident, enum_name, expr) (needs C++ counterpart linked into final binary) This invokes the aforementioned extern function which creates a status_result from a C enum.  The operations available to C++ are:\n CXX_TO_RESULT_SYSTEM_CODE(ident, status_code\u0026lt;T\u0026gt;) Returns a previously declared C Result from its matching C++ status_code. NOTE that the destructor of the C++ status code is NOT called. If this is important to your status code, it is 100% on you to ensure that your C Result reenters a C++ Result at the end of its lifetime. to_result(any C Result) This is an overloaded C++ free function which returns the C++ status_code\u0026lt;T\u0026gt; matching its input C Result.  Using the above you can write C code using Outcome.Experimental\u0026rsquo;s Result type quite effectively. Let\u0026rsquo;s look at an example of use next.\n"
},
{
	"uri": "https://ned14.github.io/outcome/tutorial/essential/coroutines/try/",
	"title": "Coroutine TRY operation",
	"tags": ["coroutines", "try"],
	"description": "",
	"content": "As one cannot call statement return from within a Coroutine, the very first part of Outcome\u0026rsquo;s support for Coroutines is OUTCOME_CO_TRYV(expr)/OUTCOME_CO_TRY(expr) , which is literally the same as OUTCOME_TRY() except that co_return is called to return early instead of return.\neager\u0026lt;result\u0026lt;std::string\u0026gt;\u0026gt; to_string(int x) { if(x \u0026gt;= 0) { OUTCOME_CO_TRY(convert(x)); } co_return \u0026#34;out of range\u0026#34;; } "
},
{
	"uri": "https://ned14.github.io/outcome/experimental/worked-example-long/preamble/",
	"title": "Define a custom code domain",
	"tags": [],
	"description": "",
	"content": "Firstly let\u0026rsquo;s alias the experimental Outcome namespace into something less tedious to type, declare our custom status code type, and get started on defining the custom status code domain implementation.\nnamespace outcome_e = OUTCOME_V2_NAMESPACE::experimental; // To define a `file_io_error` which participates in the P1028 world // of `std::error`, we must first declare, then define, a custom code // domain which extends `posix_code` (the std error coding for POSIX // failures). The following is fairly standard boilerplate for defining // a custom code domain. It is analogous to defining a custom `std::error_category`.  class_file_io_error_domain; // We define `file_io_error` to be the status code whose domain is `_file_io_error_domain`. using file_io_error = outcome_e::status_code\u0026lt;_file_io_error_domain\u0026gt;; // Now we define `_file_io_error_domain`. class_file_io_error_domain : public outcome_e::posix_code::domain_type { using _base = typename outcome_e::posix_code::domain_type; View this code on Github Note that we inherit from outcome_e::posix_code::domain_type, not from outcome_e::status_code_domain. We thus reuse most of the implementation of outcome_e::posix_code::domain_type rather than implementing required functionality. If you would like to see a fuller treatment of defining a custom status code domain from scratch, see this worked example here.\nYou may find looking at the API reference documentation for status_code_domain useful in the next few pages .\n"
},
{
	"uri": "https://ned14.github.io/outcome/tutorial/essential/",
	"title": "Essential",
	"tags": [],
	"description": "The absolute minimum that you need to know to get started with Outcome immediately.",
	"content": " Before we begin Essential information before you begin the tutorial.\n result\u0026lt;\u0026gt; Gentle introduction to writing code with simple success-or-failure return types.\n Inspecting result TRY operations TRY is greedy TRY avoiding copy/move outcome\u0026lt;\u0026gt; Success-or-failure return types where failure can take two forms, expected/handled failure and unexpected/abort failure.\n Inspecting outcome No-value policies Describes the concept of NoValuePolicy and how to use no-value policies.\n A custom no-value policy Built-in policies Coroutines Using Outcome in C++ Coroutines\n Coroutine TRY operation Coroutine awaitables Returning Outcome types from Coroutines operator co_await as TRY operator Conventions Why you should avoid custom E types in public APIs.\n "
},
{
	"uri": "https://ned14.github.io/outcome/motivation/exceptions/",
	"title": "Exceptions",
	"tags": [],
	"description": "Exceptions with their good and bad sides.",
	"content": " Exceptions are the default mechanism in C++ for reporting, propagating and processing the information about function failures. Their main advantage is the ability to describe the \u0026ldquo;success dependency\u0026rdquo; between functions: if you want to say that calling function g() depends on the successful execution of function f(), you just put g() below f() and that\u0026rsquo;s it:\nint a() { f(); g(); // don\u0026#39;t call g() and further if f() fails  return h(); // don\u0026#39;t call h() if g() fails }  In the C++ Standard terms this means that f() is sequenced before g(). This makes failure handling extremely easy: in a lot of cases you do not have to do anything.\nAlso, while next operations are being canceled, the exception object containing the information about the initial failure is kept on the side. When at some point the cancellation cascade is stopped by an exception handler, the exception object can be inspected. It can contain arbitrarily big amount of data about the failure reason, including the entire call stack.\nDownsides There are two kinds of overheads caused by the exception handling mechanism. The first is connected with storing the exceptions on the side. Stack unwinding works independently in each thread of execution; each thread can be potentially handling a number of exceptions (even though only one exception can be active in one thread). This requires being prepared for storing an arbitrary number of exceptions of arbitrary types per thread. Additional things like jump tables also need to be stored in the program binaries.\nSecond overhead is experienced when throwing an exception and trying to find the handler. Since nearly any function can throw an exception of any time, this is a dynamic memory allocation. The type of an exception is erased and a run-time type identification (RTTI) is required to asses the type of the active exception object. The worst case time required for matching exceptions against handlers cannot be easily predicted and therefore exceptions are not suitable for real-time or low-latency systems.\nAnother problem connected with exceptions is that while they are good for program flows with linear \u0026ldquo;success dependency\u0026rdquo;, they become inconvenient in situations where this success dependency does not occur. One such notable example is releasing acquired resources which needs to be performed even if previous operations have failed. Another example is when some function c() depends on the success of at least one of two functions a() and b() (which try, for instance, to store user data by two different means), another example is when implementing a strong exception safety guarantee we may need to apply some fallback actions when previous operations have failed. When failures are reported by exceptions, the semantics of canceling all subsequent operations is a hindrance rather than help; these situations require special and non-trivial idioms to be employed.\nFor these reasons in some projects using exceptions is forbidden. Compilers offer switches to disable exceptions altogether (they refuse to compile a throw, and turn already compiled throws into calls to std::abort()).\n"
},
{
	"uri": "https://ned14.github.io/outcome/experimental/worked-example/implicit-construction/",
	"title": "Implicit construction",
	"tags": [],
	"description": "",
	"content": "The preceding code had the compiler stamp out a custom status code domain for a user supplied enum. You now get the following types:\n// This is the status code generated for your custom enum type. It will implicitly construct from // values of enum custom_failure. using custom_failure_code = SYSTEM_ERROR2_NAMESPACE::quick_status_code_from_enum_code\u0026lt;custom_failure\u0026gt;; namespace outcome_e = OUTCOME_V2_NAMESPACE::experimental; // You don\u0026#39;t usually need to use the status code type explicitly, because this \u0026#34;just works\u0026#34;: outcome_e::status_result\u0026lt;int\u0026gt; positive_only(int x) { if(x \u0026lt; 0) { // Outcome\u0026#39;s result sees that status_code will implicitly construct from this enum,  // and it returns an errored result  return custom_failure::bad_argument; } return x; } // Semantic comparisons work bool test(int x) { if(auto r = positive_only(x); !r) { if(r.error() == outcome_e::errc::invalid_argument) { std::cerr \u0026lt;\u0026lt; \u0026#34;Positive numbers only!\u0026#34; \u0026lt;\u0026lt; std::endl; return false; } } return true; } View this code on Github As you can see, this is less work than plugging your custom enum into std::error_code. It also has C compatibility, and generates better codegen.\n"
},
{
	"uri": "https://ned14.github.io/outcome/tutorial/advanced/hooks/keeping_state/",
	"title": "Keeping state",
	"tags": ["backtrace"],
	"description": "",
	"content": "The first thing we are going to need is somewhere to store the stack backtrace. We could take the easier route and simply store it into an allocated block and keep the pointer as a custom payload in a result\u0026lt;T, std::pair\u0026lt;error_code, std::unique_ptr\u0026lt;stack_backtrace\u0026gt;\u0026gt;\u0026gt; (see previous section on Custom payloads). But let us assume that we care so deeply about bounded execution times that ever calling malloc is unacceptable.\nWe therefore are going to need some completely static and trivially typed storage perhaps kept per-thread to avoid the need to keep mutexes.\n/* Outcome\u0026#39;s hook mechanism works vis ADL, so we will need a custom namespace to ensure the hooks apply only to the types declared in this namespace only */ namespace error_code_extended { // The extra error information we will keep  struct extended_error_info { std::array\u0026lt;void *, 16\u0026gt; backtrace; // The backtrace  size_t items; // Items in backtrace array which are valid  }; struct mythreadlocaldata_t { // Keep 16 slots of extended error info as a ringbuffer  extended_error_info slots[16]; // The current oldest slot  uint16_t current{0}; // Return the oldest slot  extended_error_info \u0026amp;next() { return slots[(current++) % 16]; } // Retrieve a previously stored slot, detecting if it is stale  extended_error_info *get(uint16_t idx) { // If the idx is stale, return not found  if(idx - current \u0026gt;= 16) { return nullptr; } return slots + (idx % 16); } }; // Meyers\u0026#39; singleton returning a thread local data structure for this thread  inline mythreadlocaldata_t \u0026amp;mythreadlocaldata() { static thread_local mythreadlocaldata_t v; return v; } } View this code on Github The extended error info is kept in a sixteen item long, thread local, ring buffer. We continuously increment the current index pointer which is a 16 bit value which will wrap after 65,535. This lets us detect an attempt to access recycled storage, and thus return item-not-found instead of the wrong extended error info.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/macros/",
	"title": "Macros",
	"tags": [],
	"description": "",
	"content": " Constrained template macros Version macros OUTCOME_CO_TRY(var, expr) Evaluate within a coroutine an expression which results in an understood type, assigning T to a decl called var if successful, immediately returning try_operation_return_as(X) from the calling function if unsuccessful.\n OUTCOME_CO_TRYV(expr)/OUTCOME_CO_TRY(expr) Evaluate from within a coroutine an expression which results in an understood type, continuing execution if successful, immediately returning try_operation_return_as(X) from the calling function if unsuccessful.\n OUTCOME_CO_TRYV2(spec, expr) Evaluate an expression which results in an understood type, continuing execution if successful, immediately returning try_operation_return_as(X) from the calling function if unsuccessful.\n OUTCOME_CO_TRYV2_FAILURE_LIKELY(spec, expr) Evaluate an expression which results in an understood type, continuing execution if successful, immediately returning try_operation_return_as(X) from the calling function if unsuccessful.\n OUTCOME_CO_TRYV_FAILURE_LIKELY(expr)/OUTCOME_CO_TRY_FAILURE_LIKELY(expr) Evaluate from within a coroutine an expression which results in an understood type, continuing execution if successful, immediately returning try_operation_return_as(X) from the calling function if unsuccessful.\n OUTCOME_CO_TRYX(expr) Evaluate from within a coroutine an expression which results in an understood type, emitting the T if successful, immediately returning try_operation_return_as(X) from the calling function if unsuccessful.\n OUTCOME_CO_TRYX_FAILURE_LIKELY(expr) Evaluate from within a coroutine an expression which results in an understood type, emitting the T if successful, immediately returning try_operation_return_as(X) from the calling function if unsuccessful.\n OUTCOME_CO_TRY_FAILURE_LIKELY(var, expr) Evaluate within a coroutine an expression which results in an understood type, assigning T to a decl called var if successful, immediately returning try_operation_return_as(X) from the calling function if unsuccessful.\n OUTCOME_DISABLE_EXECINFO If defined, disables the use of the \u0026lt;execinfo.h\u0026gt; header (or the win32 emulation).\n OUTCOME_ENABLE_LEGACY_SUPPORT_FOR Enables backwards features and naming compatibility for earlier versions of Outcome.\n OUTCOME_NODISCARD How to tell the compiler than the return value of a function should not be discarded without examining it.\n OUTCOME_REQUIRES(...) A C++ 20 requires(...), if available.\n OUTCOME_SYMBOL_VISIBLE How to mark throwable types as always having default ELF symbol visibility.\n OUTCOME_THREAD_LOCAL How to mark variables as having thread local storage duration.\n OUTCOME_THROW_EXCEPTION(expr) How to throw a C++ exception, or equivalent thereof.\n OUTCOME_TRY(var, expr) Evaluate an expression which results in an understood type, assigning T to a decl called var if successful, immediately returning try_operation_return_as(X) from the calling function if unsuccessful.\n OUTCOME_TRYV(expr)/OUTCOME_TRY(expr) Evaluate an expression which results in an understood type, continuing execution if successful, immediately returning try_operation_return_as(X) from the calling function if unsuccessful.\n OUTCOME_TRYV2(spec, expr) Evaluate an expression which results in an understood type, continuing execution if successful, immediately returning try_operation_return_as(X) from the calling function if unsuccessful.\n OUTCOME_TRYV2_FAILURE_LIKELY(spec, expr) Evaluate an expression which results in an understood type, continuing execution if successful, immediately returning try_operation_return_as(X) from the calling function if unsuccessful.\n OUTCOME_TRYV_FAILURE_LIKELY(expr)/OUTCOME_TRY_FAILURE_LIKELY(expr) Evaluate an expression which results in an understood type, continuing execution if successful, immediately returning try_operation_return_as(X) from the calling function if unsuccessful.\n OUTCOME_TRYX(expr) Evaluate an expression which results in an understood type, emitting the T if successful, immediately returning try_operation_return_as(X) from the calling function if unsuccessful.\n OUTCOME_TRYX_FAILURE_LIKELY(expr) Evaluate an expression which results in an understood type, emitting the T if successful, immediately returning try_operation_return_as(X) from the calling function if unsuccessful.\n OUTCOME_TRY_FAILURE_LIKELY(var, expr) Evaluate an expression which results in an understood type, assigning T to a decl called var if successful, immediately returning try_operation_return_as(X) from the calling function if unsuccessful.\n OUTCOME_USE_STD_IN_PLACE_TYPE How to implement in_place_type_t\u0026lt;T\u0026gt; and in_place_type\u0026lt;T\u0026gt;.\n OUTCOME_USE_STD_IS_NOTHROW_SWAPPABLE How to implement is_nothrow_swappable\u0026lt;T\u0026gt;.\n "
},
{
	"uri": "https://ned14.github.io/outcome/tutorial/advanced/payload/copy_file/",
	"title": "The Filesystem TS",
	"tags": ["dual-api"],
	"description": "",
	"content": "Something which has long annoyed the purists in the C++ leadership is the problem of dual overloads in error_code capable standard library APIs.\nConsider the copy_file() API from the Filesystem TS:\nnamespace filesystem { /*! Copies the file at path `from` to path `to`. \\returns True if file was successfully copied. \\throws On failure throws `filesystem_error(ec.message(), from, to, ec)` with `ec` being the error code reported by the operating system. */ bool copy_file(const path \u0026amp;from, const path \u0026amp;to); /*! Copies the file at path `from` to path `to`. \\returns True if file was successfully copied. If false, `ec` is written with the error code reported by the operating system. \\throws May throw an exception if there is some \u0026#34;catastrophic\u0026#34; failure e.g. failure to allocate memory. */ bool copy_file(const path \u0026amp;from, const path \u0026amp;to, std::error_code \u0026amp;ec); } View this code on Github Before Outcome, the common design pattern was to provide throwing and non-throwing overloads of every API. As you can see above, the throwing API throws a filesystem::filesystem_error exception type which carries additional information, specifically two paths. These paths may refer to the files which were the source of any failure. However the non-throwing overload does not provide this additional information, which can make it more annoying to use the non-throwing overload sometimes.\nWhat if we could replace these two overloads of every API in the Filesystem TS with a single API, and additionally have the non-throwing edition return the exact same additional information as the throwing edition?\n"
},
{
	"uri": "https://ned14.github.io/outcome/tutorial/advanced/interop/httplib/",
	"title": "The HTTP library",
	"tags": [],
	"description": "",
	"content": "Let us imagine a simple application: it fetches a HTTP page using a HTTP library, sends it through HTML tidy via the htmltidy library, and then writes it to disc using a filelib library. So three third party libraries, two using Outcome in incompatible ways, and the third being a C library just for kicks.\nLet us imagine that the HTTP library has the following public interface:\n// This is some standalone library implementing high level HTTP namespace httplib { // These are the error code that this HTTP library can return  enum classstatus_code { success = 0, // not the HTTP success code of 200  // A subset of all HTTP status codes for brevity  bad_request = 400, access_denied = 401, logon_failed = 402, forbidden = 403, not_found = 404, internal_error = 500 }; // This is the error type that this HTTP library can return  struct failure { status_code status{status_code::success}; std::string url{}; // The failing URL  }; // Localise a result implementation to this library, holding  // the logic error of incorrect observation to mean program  // termination.  template \u0026lt;classT\u0026gt; using result = //  OUTCOME_V2_NAMESPACE::result\u0026lt;T, failure, OUTCOME_V2_NAMESPACE::policy::terminate\u0026gt;; /* Performs a HTTP GET on the url, returning the body if successful, a failure with status_code if unsuccessful at the HTTP level, or a C++ exception throw if something catastrophic happened e.g. bad_alloc */ result\u0026lt;std::string\u0026gt; get(std::string url); } // namespace httplib View this code on Github The HTTP library is a mixed-failure design. Likely failures (HTTP status codes) are returned via httplib::failure, unlikely failures (e.g. out of memory) are returned via throw of the usual STL exception types.\nThe sole API we bother describing is an implementation of HTTP GET. It fetches a URL, and either returns the contents or the failure reason why not.\n"
},
{
	"uri": "https://ned14.github.io/outcome/tutorial/",
	"title": "Tutorial",
	"tags": [],
	"description": "",
	"content": " Essential The absolute minimum that you need to know to get started with Outcome immediately.\n Before we begin Essential information before you begin the tutorial.\n result\u0026lt;\u0026gt; Gentle introduction to writing code with simple success-or-failure return types.\n outcome\u0026lt;\u0026gt; Success-or-failure return types where failure can take two forms, expected/handled failure and unexpected/abort failure.\n No-value policies Describes the concept of NoValuePolicy and how to use no-value policies.\n Coroutines Using Outcome in C++ Coroutines\n Conventions Why you should avoid custom E types in public APIs.\n Advanced If you have a bit more time, this covers all the time-saving ways you can customise and automate Outcome for various use cases, especially in larger codebases made up of multiple third party libraries.\n Custom payloads Success-or-failure return types where extra information in addition to the error code accompanies failure.\n Result returning constructors How to metaprogram construction of objects which use resultto return failure instead of throwing a C++ exception.\n Hooking events Intercepting useful events such as initial construction, copies and moves so you can capture backtraces, fire debug breakpoints etc.\n Interoperation Interoperating with std::expectedand other ValueOrError concept matching types.\n "
},
{
	"uri": "https://ned14.github.io/outcome/tutorial/advanced/constructors/two-phase-init/",
	"title": "Two phase construction",
	"tags": [],
	"description": "",
	"content": "The first thing to do is to break your object\u0026rsquo;s construction into two phases:\n Place the object into a state where it can be legally destructed without doing any initialisation which could throw an exception (i.e. everything done in phase 1 is constexpr). This phase usually involves initialising member variables to various default values, most often using default member initialisers. Most standard C++ library objects and containers have constexpr constructors, and thus can be initialised during phase 1. If you need to initialise a member variable without a constexpr constructor,  std::optional\u0026lt;T\u0026gt; is the usual workaround.\n Do the remainder of the construction, the parts which could fail. Because phase 1 placed the object into a legally destructible state, it is usually the case that one can bail out during phase 2 and the destructor will clean things up correctly.\n  The phase 1 construction will be placed into a private constexpr constructor so nobody external can call it. The phase 2 construction will be placed into a static member initialisation function which returns a result with either the successfully constructed object, or the cause of any failure to construct the object.\nFinally, as a phase 3, some simple metaprogramming will implement a make\u0026lt;T\u0026gt;{Args...}() free function which will construct any object T by calling its static initialisation function with Args... and returning the result returned. This isn\u0026rsquo;t as nice as calling T(Args...) directly, but it\u0026rsquo;s not too bad in practice. And more importantly, it lets you write generic code which can construct any unknown object which fails via returning result, completely avoiding C++ exception throws.\n"
},
{
	"uri": "https://ned14.github.io/outcome/tutorial/essential/result/",
	"title": "result&lt;&gt;",
	"tags": ["result", "try", "namespace"],
	"description": "Gentle introduction to writing code with simple success-or-failure return types.",
	"content": "We will define a function that converts a std::string to an int. This function can fail for a number of reasons; if it does we want to communicate the failure reason.\noutcome::result\u0026lt;int\u0026gt; convert(const std::string\u0026amp; str) noexcept; View this code on Github Template alias result\u0026lt;T, E = varies, NoValuePolicy = policy::default_policy\u0026lt;T, E, void\u0026gt;\u0026gt; has three template parameters, but the last two have default values. The first (T) represents the type of the object returned from the function upon success. The second (EC) is the type of object containing information about the reason for failure when the function fails. A result object stores either a T or an EC at any given moment, and is therefore conceptually similar to variant\u0026lt;T, EC\u0026gt;. EC is defaulted to std::error_code in standalone Outcome, or to boost::system::error_code in Boost.Outcome1. The third parameter (NoValuePolicy) is called a no-value policy. We will cover it later.\nIf both T and EC are trivially copyable, result\u0026lt;T, EC, NVP\u0026gt; is also trivially copyable. Triviality, complexity and constexpr-ness of each operation (construction, copy construction, assignment, destruction etc) is always the intersection of the corresponding operation in T and EC, so for example if both T and EC are literal types, so will be result\u0026lt;T, EC, NVP\u0026gt;. Additionally, if both T and EC have standard layout, result\u0026lt;T, EC, NVP\u0026gt; has standard layout; thus if both T and EC are C-compatible, so will result\u0026lt;T, EC, NVP\u0026gt; be C-compatible.\nNow, we will define an enumeration describing different failure situations during conversion.\nenum classConversionErrc { Success = 0, // 0 should not represent an error  EmptyString = 1, // (for rationale, see tutorial on error codes)  IllegalChar = 2, TooLong = 3, }; // all boilerplate necessary to plug ConversionErrc // into std::error_code framework View this code on Github Assume we have plugged it into std::error_code framework, as described in this section.\nOne notable effect of such plugging is that ConversionErrc is now convertible to std::error_code. Now we can implement function convert as follows:\noutcome::result\u0026lt;int\u0026gt; convert(const std::string\u0026amp; str) noexcept { if (str.empty()) return ConversionErrc::EmptyString; if (!std::all_of(str.begin(), str.end(), ::isdigit)) return ConversionErrc::IllegalChar; if (str.length() \u0026gt; 9) return ConversionErrc::TooLong; return atoi(str.c_str()); } View this code on Github result\u0026lt;T, EC\u0026gt; is convertible from any T2 convertible to T as well as any EC2 convertible to EC, provided that there is no constructability possible in either direction between T and EC. If there is, all implicit conversion is disabled, and you will need to use one of the tagged constructors:\noutcome::result\u0026lt;int\u0026gt; r {outcome::in_place_type\u0026lt;std::error_code\u0026gt;, ConversionErrc::EmptyString}; outcome::result\u0026lt;int\u0026gt; s {outcome::in_place_type\u0026lt;int\u0026gt;, 1}; View this code on Github Or use helper functions:\noutcome::result\u0026lt;int\u0026gt; r = outcome::failure(ConversionErrc::EmptyString); outcome::result\u0026lt;int\u0026gt; s = outcome::success(1); View this code on Github The functions auto failure(T \u0026amp;\u0026amp;, \u0026hellip;) and auto success(T \u0026amp;\u0026amp;, \u0026hellip;) return special types implicitly convertible to failed or successful result (and outcome).\n  You can mandate a choice using std_result\u0026lt;T\u0026gt; or boost_result\u0026lt;T\u0026gt;. [return]   "
},
{
	"uri": "https://ned14.github.io/outcome/alternatives/exceptions/",
	"title": "std exception throws",
	"tags": [],
	"description": "Advantages and disadvantages of C++ exception throws",
	"content": " (Note that we assume a table-based EH implementation here, a SJLJ EH implementaton would have even happy and sad path runtime overhead. Table-based EH implementations are almost universal on x64, ARM and AArch64 targets).\nC++ exception throws came in the original C++ 98 standard \u0026ndash; at that time, not all the major compilers implemented them yet, and several of those who did did not have efficient implementations, plus in the original days some compiler vendors still patented things like EH implementation techniques to try and maintain a competitive advantage over rival compilers. Unlike other C++ features, enabling C++ exceptions on a code base not written with them in mind is not safe, so this led to the C++ ecosystem becoming bifurcated into exceptions-enabled and exceptions-disabled camps.\nPros:  Zero runtime overhead on the happy path.\n Success-orientated syntax declutters code of failure control flow paths.\n As a built-in language feature, probably has the least impact on optimisation of any failure handling mechanism here.\n Ships with every standard toolchain (though may not work in some, and cannot be safely enabled for many codebases).\n  Cons:  Unpredictable runtime overhead on the sad path.\n Unacceptable runtime overhead on the sad path for real time applications.\n Adds considerable bloat to produced binaries, which can be unacceptable for some use cases (embedded).\n Requires RTTI to be enabled or non-standard behaviour results (which is further binary bloat).\n Not available by tradition or convention in several major parts of the C++ ecosystem (embedded, games, audio, to a lesser extent financial).\n Not available in many niche architectures such as HPC, GPUs, DSPs and microcontrollers.\n Most codebases do not invest in adequate correctness testing of the silent proliferation of failure control flow paths which result in C++ exception throwing code (exception throws silently generate multitudes of slight variations of sad path control flows).\n  "
},
{
	"uri": "https://ned14.github.io/outcome/recipes/",
	"title": "Recipes",
	"tags": [],
	"description": "",
	"content": " ASIO/Networking TS : Boost \u0026lt; 1.70 How to teach ASIO/Networking TS about Outcome.\n ASIO/Networking TS: Boost \u0026gt;= 1.70 How to teach ASIO/Networking TS about Outcome.\n Extending OUTCOME_TRY How to informing OUTCOME_TRY about foreign Result types.\n Rust FFI How to teach Rust about result\u0026lt;T\u0026gt;.\n "
},
{
	"uri": "https://ned14.github.io/outcome/experimental/",
	"title": "Experimental",
	"tags": [],
	"description": "",
	"content": "In \u0026lt;outcome/experimental\u0026gt;, there ships an Outcome-based simulation of the proposed P1095 Zero overhead deterministic failure specific implementation of P0709 Zero overhead exceptions: Throwing values. This library-only implementation lets you use a close simulacrum of potential future C++ lightweight exceptions today in any C++ 14 compiler which Outcome supports.\nThis Experimental Outcome implementation has been in production use for some years now. It has shipped on at least one billion devices, as part of a games suite very popular on Microsoft Windows, Apple iOS and Google Android devices. It powers big iron enterprise applications as well, indeed all trades including futures in the United States are captured live into a database for the SEC by an Experimental Outcome based codebase. Finally, Experimental Outcome is used in the firmware of parts of driver assisting cars where its particularly rich and flexible failure added information combined with compatibility with globally disabled C++ exceptions proved to be a big win.\nThe base for failure handling in future C++ might be std::error from P1028 status_code. This proposal is currently being refined before WG21\u0026rsquo;s Library Evolution Working Group with the expectation that it will be standardised as a large enhancement and backwards compatible superset of std::error_code which is also capable of transporting any move-only type such as std::exception_ptr. Like std::error_code, proposed std::error occupies exactly two CPU registers of layout, and thus is extremely lightweight. It can wrap arbitrary third party error handling systems, and automatically constructs from std::error_code and std::exception_ptr, propagating the original underlying implementations (no matter how customised) exactly (e.g. boost::exception_ptr). Unlike \u0026lt;system_error\u0026gt;, std::error does not have dependencies on expensive standard library headers, so including it into your global build has a very low build time impact. std::error knows how to throw itself as a conventional C++ exception, and knows how to losslessly consume arbitrary C++ exception throws. Finally, std::error is ABI stable, and is a P1029 move bitcopying type whereby moved-from objects do not need to be destroyed.\nExperimental Outcome uses the same proposed std::error object as P1095 would do for its E type by bundling internally a copy of https://ned14.github.io/status-code/, the reference implementation library for proposed std::error. Outcome emulates move bitcopying semantics for types declaring themselves move bitcopying via the trait is_move_bitcopying\u0026lt;T\u0026gt; , and status codes opt into this. This greatly improves codegen to be no worse than with std::error_code (a trivially copyable type), as https://godbolt.org/z/GEdEGc demonstrates, despite that proposed std::error is a move-only type with a non-trivial destructor.\nOutcome binds status_code into basic_result and basic_outcome customisations via the following headers:\n \u0026lt;outcome/experimental/status_result.hpp\u0026gt; \u0026lt;outcome/experimental/status_outcome.hpp\u0026gt;  These headers import the entire contents of the SYSTEM_ERROR2_NAMESPACE namespace into the OUTCOME_V2_NAMESPACE::experimental namespace. You can thus address everything in SYSTEM_ERROR2_NAMESPACE via OUTCOME_V2_NAMESPACE::experimental.\nAs P1095 also proposes C language support for lightweight C++ exceptions, experimental Outcome also has a macro-based C interface that enables C code to work with the C-compatible subset of status_result\u0026lt;T, E\u0026gt;:\n \u0026lt;outcome/experimental/result.h\u0026gt;  For non-Windows non-POSIX platforms such as some embedded systems, standalone Experimental Outcome can be used with the SYSTEM_ERROR2_NOT_POSIX macro defined. This does not include POSIX headers, and makes available a high fidelity, fully deterministic, alternative to C++ exceptions on such platforms.\nFinally, there is a single include edition of Experimental Outcome, which can be found at https://github.com/ned14/outcome/blob/develop/single-header/outcome-experimental.hpp. You can play with this on godbolt by #include \u0026lt;outcome-experimental.hpp\u0026gt;.\nIt is stressed, in the strongest possible terms, that any item inside \u0026lt;outcome/experimental\u0026gt; is subject to unannounced breaking change based on WG21 standards committee feedback. That said, the chances are high that most of those breaking changes will be to naming rather than to fundamental semantics, so you can upgrade with a bit of find and replace.\n "
},
{
	"uri": "https://ned14.github.io/outcome/tutorial/advanced/interop/tidylib/",
	"title": "The HTMLTidy library",
	"tags": [],
	"description": "",
	"content": "// There actually is a library for tidying HTML into XHTML called HTMLTidy // See http://www.html-tidy.org/ // HTMLTidy is actually a great tool for dealing with 1990s-era tag soup // HTML, I highly recommend it.  // This isn\u0026#39;t the API for Tidy, but let\u0026#39;s assume it\u0026#39;s a C library returning // errno domained error codes. out must be freed with free() after use. extern \u0026#34;C\u0026#34; int tidy_html(char **out, size_t *outlen, const char *in, size_t inlen); View this code on Github A C API may not initially appear to be a T|E based API, but if failure returns some domained error code and causes no other effects, and success returns some value, then it is effectively a \u0026ldquo;split\u0026rdquo; T|E API. The above is an example of exactly that form of \u0026ldquo;split\u0026rdquo; T|E API.\n"
},
{
	"uri": "https://ned14.github.io/outcome/tutorial/advanced/constructors/file_handle/",
	"title": "A file handle",
	"tags": [],
	"description": "",
	"content": "Borrowing from llfio::file_handle which uses this design pattern1, here is a simplified file_handle implementation:\nclassfile_handle { int _fd{-1}; // file descriptor  struct stat _stat { 0 }; // stat of the fd at open  // Phase 1 private constexpr constructor  constexpr file_handle() {} public: using path_type = filesystem::path; //! The behaviour of the handle: does it read, read and write, or atomic append?  enum classmode : unsigned char // bit 0 set means writable  { unchanged = 0, none = 2, //!\u0026lt; No ability to read or write anything, but can synchronise (SYNCHRONIZE or 0)  attr_read = 4, //!\u0026lt; Ability to read attributes (FILE_READ_ATTRIBUTES|SYNCHRONIZE or O_RDONLY)  attr_write = 5, //!\u0026lt; Ability to read and write attributes (FILE_READ_ATTRIBUTES|FILE_WRITE_ATTRIBUTES|SYNCHRONIZE or O_RDONLY)  read = 6, //!\u0026lt; Ability to read (READ_CONTROL|FILE_READ_DATA|FILE_READ_ATTRIBUTES|FILE_READ_EA|SYNCHRONISE or O_RDONLY)  write = 7, //!\u0026lt; Ability to read and write (READ_CONTROL|FILE_READ_DATA|FILE_READ_ATTRIBUTES|FILE_READ_EA|FILE_WRITE_DATA|FILE_WRITE_ATTRIBUTES|FILE_WRITE_EA|FILE_APPEND_DATA|SYNCHRONISE or O_RDWR)  append = 9 //!\u0026lt; All mainstream OSs and CIFS guarantee this is atomic with respect to all other appenders (FILE_APPEND_DATA|SYNCHRONISE or O_APPEND)  }; // Moves but not copies permitted  file_handle(const file_handle \u0026amp;) = delete; file_handle(file_handle \u0026amp;\u0026amp;o) noexcept : _fd(o._fd) { o._fd = -1; } file_handle \u0026amp;operator=(const file_handle \u0026amp;) = delete; file_handle \u0026amp;operator=(file_handle \u0026amp;\u0026amp;o) noexcept { this-\u0026gt;~file_handle(); new(this) file_handle(std::move(o)); return *this; } // Destruction closes the handle  ~file_handle() { if(_fd != -1) { if(-1 == ::close(_fd)) { int e = errno; std::cerr \u0026lt;\u0026lt; \u0026#34;FATAL: Closing the fd during destruction failed due to \u0026#34; \u0026lt;\u0026lt; strerror(e) \u0026lt;\u0026lt; std::endl; std::terminate(); } _fd = -1; } } // Phase 2 static member constructor function, which cannot throw  static inline outcome::result\u0026lt;file_handle\u0026gt; file(path_type path, mode mode = mode::read) noexcept; }; View this code on Github Note the default member initialisers, these are particularly convenient for implementing phase 1 of construction. Note also the constexpr constructor, which thanks to the default member initialisers is otherwise empty.\nFile handles are very expensive to copy as they involve a syscall to duplicate the file descriptor, so we enable moves only.\nThe destructor closes the file descriptor if it is not -1, and if the close fails, seeing as there is nothing else we can do without leaking the file descriptor, we fatal exit the process.\nFinally we declare the phase 2 constructor which is a static member function.\n LLFIO uses Outcome \u0026ldquo;in anger\u0026rdquo;, both in Standard and Experimental configurations. If you would like a real world user of Outcome to study the source code of, it can be studied at https://github.com/ned14/llfio/. [return]   "
},
{
	"uri": "https://ned14.github.io/outcome/tutorial/advanced/hooks/adl_bridging/",
	"title": "ADL bridging",
	"tags": ["adl-bridging"],
	"description": "",
	"content": "In Outcome v2.2 the ADL-based event hooks were replaced with policy-based event hooks (next page). The code in this section is still valid in v2.2 onwards, it\u0026rsquo;s just that ADL is no longer used to find the hooks.\n In a previous section, we used the failure_info type to create the ADL bridge into the namespace where the ADL discovered outcome_throw_as_system_error_with_payload() function was to be found.\nHere we do the same, but more directly by creating a thin clone of std::error_code into the local namespace. This ensures that this namespace will be searched by the compiler when discovering the event hooks (Outcome v2.1 and earlier only).\nnamespace error_code_extended { // Use the error_code type as the ADL bridge for the hooks by creating a type here  // It can be any type that your localised result uses, including the value type but  // by localising the error code type here you prevent nasty surprises later when the  // value type you use doesn\u0026#39;t trigger the ADL bridge.  struct error_code : public std::error_code { // literally passthrough  using std::error_code::error_code; error_code() = default; error_code(std::error_code ec) : std::error_code(ec) { } }; // Localise result and outcome to using the local error_code so this namespace gets looked up for the hooks  template \u0026lt;classR\u0026gt; using result = OUTCOME_V2_NAMESPACE::result\u0026lt;R, error_code\u0026gt;; template \u0026lt;classR\u0026gt; using outcome = OUTCOME_V2_NAMESPACE::outcome\u0026lt;R, error_code /*, std::exception_ptr */\u0026gt;; } View this code on Github For convenience, we template alias local copies of result and outcome in this namespace bound to the ADL bridging error_code.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/",
	"title": "API reference",
	"tags": [],
	"description": "",
	"content": " Macros Constrained template macros Version macros OUTCOME_CO_TRY(var, expr) Evaluate within a coroutine an expression which results in an understood type, assigning T to a decl called var if successful, immediately returning try_operation_return_as(X) from the calling function if unsuccessful.\n OUTCOME_CO_TRYV(expr)/OUTCOME_CO_TRY(expr) Evaluate from within a coroutine an expression which results in an understood type, continuing execution if successful, immediately returning try_operation_return_as(X) from the calling function if unsuccessful.\n OUTCOME_CO_TRYV2(spec, expr) Evaluate an expression which results in an understood type, continuing execution if successful, immediately returning try_operation_return_as(X) from the calling function if unsuccessful.\n OUTCOME_CO_TRYV2_FAILURE_LIKELY(spec, expr) Evaluate an expression which results in an understood type, continuing execution if successful, immediately returning try_operation_return_as(X) from the calling function if unsuccessful.\n OUTCOME_CO_TRYV_FAILURE_LIKELY(expr)/OUTCOME_CO_TRY_FAILURE_LIKELY(expr) Evaluate from within a coroutine an expression which results in an understood type, continuing execution if successful, immediately returning try_operation_return_as(X) from the calling function if unsuccessful.\n OUTCOME_CO_TRYX(expr) Evaluate from within a coroutine an expression which results in an understood type, emitting the T if successful, immediately returning try_operation_return_as(X) from the calling function if unsuccessful.\n OUTCOME_CO_TRYX_FAILURE_LIKELY(expr) Evaluate from within a coroutine an expression which results in an understood type, emitting the T if successful, immediately returning try_operation_return_as(X) from the calling function if unsuccessful.\n OUTCOME_CO_TRY_FAILURE_LIKELY(var, expr) Evaluate within a coroutine an expression which results in an understood type, assigning T to a decl called var if successful, immediately returning try_operation_return_as(X) from the calling function if unsuccessful.\n OUTCOME_DISABLE_EXECINFO If defined, disables the use of the \u0026lt;execinfo.h\u0026gt; header (or the win32 emulation).\n OUTCOME_ENABLE_LEGACY_SUPPORT_FOR Enables backwards features and naming compatibility for earlier versions of Outcome.\n OUTCOME_NODISCARD How to tell the compiler than the return value of a function should not be discarded without examining it.\n OUTCOME_REQUIRES(...) A C++ 20 requires(...), if available.\n OUTCOME_SYMBOL_VISIBLE How to mark throwable types as always having default ELF symbol visibility.\n OUTCOME_THREAD_LOCAL How to mark variables as having thread local storage duration.\n OUTCOME_THROW_EXCEPTION(expr) How to throw a C++ exception, or equivalent thereof.\n OUTCOME_TRY(var, expr) Evaluate an expression which results in an understood type, assigning T to a decl called var if successful, immediately returning try_operation_return_as(X) from the calling function if unsuccessful.\n OUTCOME_TRYV(expr)/OUTCOME_TRY(expr) Evaluate an expression which results in an understood type, continuing execution if successful, immediately returning try_operation_return_as(X) from the calling function if unsuccessful.\n OUTCOME_TRYV2(spec, expr) Evaluate an expression which results in an understood type, continuing execution if successful, immediately returning try_operation_return_as(X) from the calling function if unsuccessful.\n OUTCOME_TRYV2_FAILURE_LIKELY(spec, expr) Evaluate an expression which results in an understood type, continuing execution if successful, immediately returning try_operation_return_as(X) from the calling function if unsuccessful.\n OUTCOME_TRYV_FAILURE_LIKELY(expr)/OUTCOME_TRY_FAILURE_LIKELY(expr) Evaluate an expression which results in an understood type, continuing execution if successful, immediately returning try_operation_return_as(X) from the calling function if unsuccessful.\n OUTCOME_TRYX(expr) Evaluate an expression which results in an understood type, emitting the T if successful, immediately returning try_operation_return_as(X) from the calling function if unsuccessful.\n OUTCOME_TRYX_FAILURE_LIKELY(expr) Evaluate an expression which results in an understood type, emitting the T if successful, immediately returning try_operation_return_as(X) from the calling function if unsuccessful.\n OUTCOME_TRY_FAILURE_LIKELY(var, expr) Evaluate an expression which results in an understood type, assigning T to a decl called var if successful, immediately returning try_operation_return_as(X) from the calling function if unsuccessful.\n OUTCOME_USE_STD_IN_PLACE_TYPE How to implement in_place_type_t\u0026lt;T\u0026gt; and in_place_type\u0026lt;T\u0026gt;.\n OUTCOME_USE_STD_IS_NOTHROW_SWAPPABLE How to implement is_nothrow_swappable\u0026lt;T\u0026gt;.\n Concepts basic_outcome\u0026lt;T\u0026gt; A boolean concept matching types which are convertible to a basic_outcome\u0026lt;T, EC, EP, NoValuePolicy\u0026gt;.\n basic_result\u0026lt;T\u0026gt; A boolean concept matching types which are convertible to a basic_result\u0026lt;T, E, NoValuePolicy\u0026gt;.\n value_or_error\u0026lt;T\u0026gt; A boolean concept matching types with either a value or an error.\n value_or_none\u0026lt;T\u0026gt; A boolean concept matching types with an optional value.\n Converters value_or_error\u0026lt;T, U\u0026gt; A customisable converter of value_or_error\u0026lt;T, E\u0026gt; concept matching types.\n Traits is_basic_outcome\u0026lt;T\u0026gt; An integral constant type true for basic_outcome\u0026lt;T, EC, EP, NoValuePolicy\u0026gt; types.\n is_basic_result\u0026lt;T\u0026gt; An integral constant type true for basic_result\u0026lt;T, E, NoValuePolicy\u0026gt; types.\n is_error_code_available\u0026lt;T\u0026gt; True if an error code can be constructed from a T.\n is_error_type\u0026lt;E\u0026gt; A customisable integral constant type true for E types which are to receive error throwing no-value policies.\n is_error_type_enum\u0026lt;E, Enum\u0026gt; A customisable integral constant type true for E types constructible from Enum types which are to receive error throwing no-value policies.\n is_exception_ptr_available\u0026lt;T\u0026gt; True if an exception ptr can be constructed from a T.\n is_failure_type\u0026lt;T\u0026gt; An integral constant boolean variable true for failure_type\u0026lt;EC, E = void\u0026gt; types.\n is_move_bitcopying\u0026lt;T\u0026gt; (\u0026gt;= Outcome v2.2.0) A customisable integral constant type true for T types which are move bitcopying safe.\n is_success_type\u0026lt;T\u0026gt; An integral constant boolean variable true for success_type\u0026lt;T\u0026gt; types.\n type_can_be_used_in_basic_result\u0026lt;R\u0026gt; A constexpr boolean true for types permissible in basic_result\u0026lt;T, E, NoValuePolicy\u0026gt;.\n Policies base Base class of most policy classes defining the narrow observer policies.\n all_narrow Policy class defining that hard undefined behaviour should occur on incorrect narrow and wide value, error or exception observation. Inherits publicly from base.\n error_code_throw_as_system_error\u0026lt;T, EC, EP\u0026gt; Policy class defining that EP ought to be rethrown if possible, then the ADL discovered free function outcome_throw_as_system_error_with_payload() should be called on incorrect wide value observation. Inherits publicly from base. Can only be used with basic_outcome.\n error_code_throw_as_system_error\u0026lt;T, EC, void\u0026gt; Policy class defining that the ADL discovered free function outcome_throw_as_system_error_with_payload() should be called on incorrect wide value observation. Inherits publicly from base. Can only be used with basic_result.\n exception_ptr_rethrow\u0026lt;T, EC, EP\u0026gt; Policy class defining that the ADL discovered free function rethrow_exception() should be called on incorrect wide value observation. Inherits publicly from base. Can only be used with basic_outcome.\n exception_ptr_rethrow\u0026lt;T, EC, void\u0026gt; Policy class defining that the ADL discovered free function rethrow_exception() should be called on incorrect wide value observation. Inherits publicly from base. Can only be used with basic_result.\n fail_to_compile_observers Policy class defining that a static assertion should occur upon compilation of the wide value, error or exception observation. Inherits publicly from base.\n terminate Policy class defining that std::terminate() should be called on incorrect wide value, error or exception observation. Inherits publicly from base.\n throw_bad_result_access\u0026lt;EC\u0026gt; Policy class defining that bad_result_access_with\u0026lt;EC\u0026gt; should be thrown on incorrect wide value observation. Inherits publicly from base.\n Types basic_outcome\u0026lt;T, EC, EP, NoValuePolicy\u0026gt; A type carrying one of (i) a successful T (ii) a disappointment EC (iii) a failure EP (iv) both a disappointment EC and a failure EP, with NoValuePolicy specifying what to do if one tries to read state which isn\u0026rsquo;t there.\n basic_result\u0026lt;T, E, NoValuePolicy\u0026gt; A sum type carrying either a successful T, or a disappointment E, with NoValuePolicy specifying what to do if one tries to read state which isn\u0026rsquo;t there.\n bad_outcome_access Exception type publicly inheriting from std::logic_error indicating an incorrect observation of value or error or exception occurred.\n bad_result_access_with\u0026lt;EC\u0026gt; Exception type publicly inheriting from bad_result_access indicating an incorrect observation of value occurred, supplying the error value.\n bad_result_access Exception type publicly inheriting from std::logic_error indicating an incorrect observation of value or error occurred.\n eager\u0026lt;T, Executor = void\u0026gt;/atomic_eager\u0026lt;T, Executor = void\u0026gt; An eagerly evaluated coroutine awaitable with Outcome customisation.\n failure_type\u0026lt;EC, EP = void\u0026gt; Type sugar for constructing an unsuccessful result or outcome.\n generator\u0026lt;T, Executor = void\u0026gt; A lazily evaluated coroutine generator with Outcome customisation.\n in_place_type_t\u0026lt;T\u0026gt; Either std::in_place_type_t\u0026lt;T\u0026gt; or a local emulation, depending on the OUTCOME_USE_STD_IN_PLACE_TYPE macro.\n lazy\u0026lt;T, Executor = void\u0026gt;/atomic_lazy\u0026lt;T, Executor = void\u0026gt; A lazily evaluated coroutine awaitable with Outcome customisation.\n success_type\u0026lt;T\u0026gt; Type sugar for constructing a successful result or outcome.\n Aliases boost_checked\u0026lt;T, E = boost::system::error_code\u0026gt; A type alias to a basic_result configured with boost::system::error_code and policy::throw_bad_result_access\u0026lt;EC\u0026gt;.\n boost_outcome\u0026lt;T, EC = boost::system::error_code, EP = boost::exception_ptr, NoValuePolicy = policy::default_policy\u0026lt;T, EC, EP\u0026gt;\u0026gt; A type alias to a basic_outcome configured with boost::system::error_code, boost::exception_ptr and policy::default_policy.\n boost_result\u0026lt;T, E = boost::system::error_code, NoValuePolicy = policy::default_policy\u0026lt;T, E, void\u0026gt;\u0026gt; A type alias to a basic_result configured with boost::system::error_code and policy::default_policy.\n boost_unchecked\u0026lt;T, E = boost::system::error_code\u0026gt; A type alias to a basic_result configured with boost::system::error_code and policy::all_narrow.\n checked\u0026lt;T, E = varies\u0026gt; A type alias to a std_checked\u0026lt;T, E\u0026gt; (standalone edition) or boost_checked\u0026lt;T, E\u0026gt; (Boost edition).\n default_policy\u0026lt;T, EC, EP\u0026gt; A type alias to a no-value policy selected based on traits matching of T, EC and EP.\n outcome\u0026lt;T, EC = varies, EP = varies, NoValuePolicy = policy::default_policy\u0026lt;T, EC, EP\u0026gt;\u0026gt; A type alias to a std_outcome\u0026lt;T, EC, EP, NoValuePolicy\u0026gt; (standalone edition) or boost_outcome\u0026lt;T, EC, EP, NoValuePolicy\u0026gt; (Boost edition).\n result\u0026lt;T, E = varies, NoValuePolicy = policy::default_policy\u0026lt;T, E, void\u0026gt;\u0026gt; A type alias to a std_result\u0026lt;T, E, NoValuePolicy\u0026gt; (standalone edition) or boost_result\u0026lt;T, E, NoValuePolicy\u0026gt; (Boost edition).\n std_checked\u0026lt;T, E = std::error_code\u0026gt; A type alias to a basic_result configured with std::error_code and policy::throw_bad_result_access\u0026lt;EC\u0026gt;.\n std_outcome\u0026lt;T, EC = std::error_code, EP = std::exception_ptr, NoValuePolicy = policy::default_policy\u0026lt;T, EC, EP\u0026gt;\u0026gt; A type alias to a basic_outcome configured with std::error_code, std::exception_ptr and policy::default_policy.\n std_result\u0026lt;T, E = std::error_code, NoValuePolicy = policy::default_policy\u0026lt;T, E, void\u0026gt;\u0026gt; A type alias to a basic_result configured with std::error_code and policy::default_policy.\n std_unchecked\u0026lt;T, E = std::error_code\u0026gt; A type alias to a basic_result configured with std::error_code and policy::all_narrow.\n unchecked\u0026lt;T, E = varies\u0026gt; A type alias to a std_unchecked\u0026lt;T, E\u0026gt; (standalone edition) or boost_unchecked\u0026lt;T, E\u0026gt; (Boost edition).\n Functions Hooks Functions used to hook into the functionality of basic_result and basic_outcome.\n Iostream Functions used to print, serialise and deserialise basic_result and basic_outcome.\n Policy Functions used to customise how the policy classes operate.\n auto failure(T \u0026amp;\u0026amp;, ...) Returns appropriate type sugar for constructing an unsuccessful result or outcome.\n auto success(T \u0026amp;\u0026amp;, ...) Returns appropriate type sugar for constructing a successful result or outcome.\n bool try_operation_has_value(X) Default implementation of try_operation_has_value(X) ADL customisation point for OUTCOME_TRY.\n decltype(auto) try_operation_extract_value(X) Default implementation of try_operation_extract_value(X) ADL customisation point for OUTCOME_TRY.\n decltype(auto) try_operation_return_as(X) Default implementation of try_operation_return_as(X) ADL customisation point for OUTCOME_TRY.\n std::error_code error_from_exception(std::exception_ptr \u0026amp;\u0026amp;ep = std::current_exception(), std::error_code not_matched = std::make_error_code(std::errc::resource_unavailable_try_again)) noexcept Returns an error code matching a thrown standard library exception.\n void strong_swap(bool \u0026amp;all_good, T \u0026amp;a, T \u0026amp;b) Tries to perform a strong guarantee swap.\n void try_throw_std_exception_from_error(std::error_code ec, const std::string \u0026amp;msg = std::string{}) Try to throw a standard library exception type matching an error code.\n "
},
{
	"uri": "https://ned14.github.io/outcome/tutorial/advanced/",
	"title": "Advanced",
	"tags": [],
	"description": "If you have a bit more time, this covers all the time-saving ways you can customise and automate Outcome for various use cases, especially in larger codebases made up of multiple third party libraries.",
	"content": " Custom payloads Success-or-failure return types where extra information in addition to the error code accompanies failure.\n The Filesystem TS Upgrading the Filesystem TS Auto-throwing filesystem_error Result returning constructors How to metaprogram construction of objects which use resultto return failure instead of throwing a C++ exception.\n Two phase construction A file handle Phase 2 construction Phase 3 construct Alternatives Hooking events Intercepting useful events such as initial construction, copies and moves so you can capture backtraces, fire debug breakpoints etc.\n Keeping state ADL bridging Hook result Custom exception ptr Hook outcome Interoperation Interoperating with std::expectedand other ValueOrError concept matching types.\n Incommensurate E types value_or_error Concept The HTTP library The HTMLTidy library The File I/O library The Application Mapping the HTTP library into the Application 1/2 Mapping the HTTP library into the Application 2/2 Mapping the File I/O library into the Application Mapping the HTMLTidy library into the Application In use Conclusion "
},
{
	"uri": "https://ned14.github.io/outcome/tutorial/essential/no-value/builtin/",
	"title": "Built-in policies",
	"tags": [],
	"description": "",
	"content": "These are the predefined policies built into Outcome:\n\u0026nbsp;\nall_narrow If there is an observation of a value/error/exception which is not present, the program is put into a hard undefined behaviour situation. The compiler literally compiles no code for an invalid observation \u0026ndash; the CPU \u0026ldquo;runs off\u0026rdquo; into the unknown.\nAs bad as this may sound, it generates the most optimal code, and such hard UB is very tool-friendly for detection e.g. undefined behaviour sanitiser, valgrind memcheck, etc.\nIf you are considering choosing this policy, definitely read static void _ub(Impl \u0026amp;\u0026amp;) first.\nNote that unchecked\u0026lt;T, E = varies\u0026gt; aliases a basic_result with the all_narrow no-value policy.\n\u0026nbsp;\nterminate Observation of a missing value/error/exception causes a call to std::terminate().\nNote that configuring EC = void or EP = void causes default_policy to choose terminate as the no-value policy.\n\u0026nbsp;\nerror_code_throw_as_system_error\u0026lt;T, EC, EP\u0026gt; This policy assumes that EC has the interface of std::error_code, and EP has the interface of std::exception_ptr. Upon missing value observation:\n if an exception is stored through pointer of type EP it is rethrown; otherwise, if an error of type EC is stored, it is converted to error_code and then thrown as system_error.  Upon missing error observation throws:\n bad_result_access(\u0026quot;no error\u0026quot;) from instances of basic_result\u0026lt;\u0026gt;. bad_outcome_access(\u0026quot;no error\u0026quot;) from instances of basic_outcome\u0026lt;\u0026gt;.  Upon missing exception observation throws bad_outcome_access(\u0026quot;no exception\u0026quot;).\nOverloads are provided for boost::system::error_code and boost::exception_ptr.\nNote that if is_error_code_available\u0026lt;T\u0026gt; is true for EC, and (if basic_outcome) is_exception_ptr_available\u0026lt;T\u0026gt; is true for EP, default_policy chooses error_code_throw_as_system_error\u0026lt;T, EC, EP\u0026gt; as the no-value policy.\n\u0026nbsp;\nexception_ptr_rethrow\u0026lt;T, EC, EP\u0026gt; This policy assumes that either EC or EP (unless void) has the interface of std::exception_ptr. Upon missing value observation:\n in instances of basic_result\u0026lt;\u0026gt;, rethrows exception pointed to by EC; in instances of basic_outcome\u0026lt;\u0026gt;, if exception EP is present rethrows it, otherwise rethrows EC.  Upon missing error observation:\n in instances of basic_result\u0026lt;\u0026gt;, throws bad_result_access(\u0026quot;no error\u0026quot;) ; in instances of basic_outcome\u0026lt;\u0026gt;, throws bad_outcome_access(\u0026quot;no error\u0026quot;).  Upon missing exception observation throws bad_outcome_access(\u0026quot;no exception\u0026quot;).\nOverloads are provided for boost::exception_ptr.\nNote that if is_exception_ptr_available\u0026lt;T\u0026gt; is true for EC, or (if basic_outcome) is_exception_ptr_available\u0026lt;T\u0026gt; is true for EP, default_policy chooses exception_ptr_rethrow\u0026lt;T, EC, EP\u0026gt; as the no-value policy.\n\u0026nbsp;\nthrow_bad_result_access\u0026lt;EC\u0026gt; Upon missing value observation throws bad_result_access_with\u0026lt;EC\u0026gt;(ec), where ec is the value of the stored error. If error is not stored, the behaviour is undefined.\nUpon missing error observation throws bad_result_access(\u0026quot;no error\u0026quot;).\nThis policy can be used with basic_outcome\u0026lt;\u0026gt; instances, where it always throws bad_outcome_access for all no-value/error/exception observations.\nNote that checked\u0026lt;T, E = varies\u0026gt; aliases a basic_result with the throw_bad_result_access\u0026lt;EC\u0026gt; no-value policy.\n"
},
{
	"uri": "https://ned14.github.io/outcome/experimental/c-api/from-cxx/",
	"title": "Calling C++ from C",
	"tags": [],
	"description": "",
	"content": "C++ has excellent two-way compatibility with the C ABI, but there are some limitations you must observe to write C++ code which C code can call without marshalling at the ABI boundary:\n A C++ function may not throw exceptions if it is safe to call from C, and so should always be marked noexcept.\n A C++ function should be annotated with extern \u0026quot;C\u0026quot; to prevent its symbol being mangled, and thus give it the C rather than C++ ABI.\n You cannot use overloading in your extern \u0026quot;C\u0026quot; functions.\n You may only use types in your C++ function declaration for which these traits are both true:\n std::is_standard_layout_v\u0026lt;T\u0026gt; std::is_trivially_copyable_v\u0026lt;T\u0026gt;  (Note that std::is_trivially_copyable_v\u0026lt;T\u0026gt; requires trivial destruction, but NOT trivial construction. This means that C++ can do non-trivial construction of otherwise trivial types)\n  The above is what the standard officially requires for well defined C and C++ interop. However, all of the three major compilers MSVC, GCC and clang are considerably more relaxed. In those three major compilers, \u0026ldquo;almost-standard-layout\u0026rdquo; C++ types work fine in C.\n\u0026ldquo;Almost-standard-layout\u0026rdquo; C++ types have these requirements:\n No virtual functions or virtual base classes i.e. std::is_polymorphic_v\u0026lt;T\u0026gt; must be false. This is because the vptrs offset the proper front of the data layout in an unknowable way to C. Non-static data members of reference type appear to C as pointers. You must never supply from C to C++ a non-null pointer which is seen as a reference in C++. C++ inheritance is seen in C data layout as if the most derived class has nested variables of the inherited types at the top, in order of inheritance. Types with non-trivial destructors work fine so long as at least move construction and assignment is the same as copying bits like memcpy(). You just need to make sure instances of the type return to C++, and don\u0026rsquo;t get orphaned in C. This was referred to in previous pages in this section as \u0026ldquo;move relocating\u0026rdquo; types.  Experimental Outcome\u0026rsquo;s support for being used from C does not meet the current strict requirements, and thus relies on the (very common) implementation defined behaviour just described (it is hoped that future C++ standards can relax the requirements to those just described).\nSpecifically, proposed status_code is an almost-standard-layout type, and thus while it can\u0026rsquo;t be returned from extern \u0026quot;C\u0026quot; functions as the compiler will complain, it is perfectly safe to return from C++ functions to C code on the three major compilers, as it is an \u0026ldquo;almost-standard-layout\u0026rdquo; C++ type if T is an \u0026ldquo;almost-standard-layout\u0026rdquo; C++ type.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/concepts/",
	"title": "Concepts",
	"tags": [],
	"description": "",
	"content": " basic_outcome\u0026lt;T\u0026gt; A boolean concept matching types which are convertible to a basic_outcome\u0026lt;T, EC, EP, NoValuePolicy\u0026gt;.\n basic_result\u0026lt;T\u0026gt; A boolean concept matching types which are convertible to a basic_result\u0026lt;T, E, NoValuePolicy\u0026gt;.\n value_or_error\u0026lt;T\u0026gt; A boolean concept matching types with either a value or an error.\n value_or_none\u0026lt;T\u0026gt; A boolean concept matching types with an optional value.\n "
},
{
	"uri": "https://ned14.github.io/outcome/tutorial/essential/coroutines/awaitables/",
	"title": "Coroutine awaitables",
	"tags": ["coroutines", "eager", "lazy", "awaitables"],
	"description": "",
	"content": "The second part of the support is provided by header \u0026lt;outcome/coroutine_support.hpp\u0026gt; (or \u0026lt;outcome/experimental/coroutine_support.hpp\u0026gt; if you want Coroutine support for Experimental Outcome). This adds into namespace OUTCOME_V2_NAMESPACE::awaitables (or OUTCOME_V2_NAMESPACE::experimental::awaitables) these awaitable types suitable for returning from a Coroutinised function:\n eager\u0026lt;T, Executor = void\u0026gt; An eagerly evaluated Coroutine: invoking co_await upon a function returning one of these immediately begins the execution of the function now. If the function never suspends, the overhead is similar to calling an ordinary function.\n lazy\u0026lt;T, Executor = void\u0026gt; A lazily evaluated Coroutine (often named task\u0026lt;T\u0026gt; in most C++ Coroutine literature): invoking co_await upon a function returning one of these causes the function to be immediately suspended as soon as execution begins. Only resuming the execution of the coroutine proceeds execution.\n generator\u0026lt;T, Executor = void\u0026gt; A lazily evaluated generator of values: the coroutine is resumed to generate the next value, upon which it is suspended until the next iteration.\n atomic_eager\u0026lt;T, Executor = void\u0026gt;\neager\u0026lt;T\u0026gt; does not employ thread synchronisation during resumption of dependent coroutines which is fine if you do not traverse kernel threads during a suspend-resume cycle. If you do however potentially traverse kernel threads during suspend-resume, you ought to use atomic_eager\u0026lt;T\u0026gt; instead \u0026ndash; this uses atomics to synchronise the setting and checking of state to ensure correctness.\n atomic_lazy\u0026lt;T, Executor = void\u0026gt;\nSame for lazy\u0026lt;T\u0026gt; as atomic_eager\u0026lt;T\u0026gt; is for eager\u0026lt;T\u0026gt;.\n  "
},
{
	"uri": "https://ned14.github.io/outcome/experimental/c-api/from-c/declare/",
	"title": "Declare a Result",
	"tags": [],
	"description": "Declaring a C Result",
	"content": "// Declare to C a Result with a happy value of intptr_t CXX_DECLARE_RESULT_SYSTEM(result_int, intptr_t) // Save oneself typing out CXX_RESULT_SYSTEM(result_int) all the time typedef CXX_RESULT_SYSTEM(result_int) result; // Our custom C enum enum c_enum { c_enum_not_found, c_enum_bad_argument }; // Make a custom status code domain for this C enum CXX_DECLARE_RESULT_SYSTEM_FROM_ENUM(result_int, // The C Result type declared above  c_enum, // The C enum we wish to wrap  \u0026#34;{74ceb994-7622-3a21-07f0-b016aa705585}\u0026#34;, // Unique UUID for this domain  // Mappings of C enum values to textual description and semantic equivalances to generic codes  {c_enum::c_enum_not_found, \u0026#34;item not found\u0026#34;, {errc::no_such_file_or_directory}}, {c_enum::c_enum_bad_argument, \u0026#34;invoked wrong\u0026#34;, {errc::invalid_argument}}) // Make helper macros #define SUCCESS(v) CXX_MAKE_RESULT_SYSTEM_SUCCESS(result_int, (v)) #define FAILURE(v) CXX_MAKE_RESULT_SYSTEM_FROM_ENUM(result_int, c_enum, (v)) View this code on Github The key to making C programming easy is to alias the long complex things into short easy thing. Obviously SUCCESS(expr) and FAILURE(expr) is too generic, but for the purposes of this documentation it makes thing easier.\n"
},
{
	"uri": "https://ned14.github.io/outcome/experimental/c-api/from-cxx/example/",
	"title": "Example C++ function",
	"tags": [],
	"description": "",
	"content": "Let us start with a simple C++ function which we wish to make available to C code:\nnamespace outcome_e = OUTCOME_V2_NAMESPACE::experimental; // Fill the supplied buffer with the integer v converted to a string, // returning length of string minus null terminator outcome_e::status_result\u0026lt;size_t\u0026gt; to_string(char *buffer, size_t bufferlen, int v) noexcept { try { // Could throw an exception!  std::string temp(std::to_string(v)); // Will this string exceed the supplied buffer?  if(temp.size() + 1 \u0026gt; bufferlen) return outcome_e::errc::no_buffer_space; // Copy the string into the supplied buffer, and return length of string  memcpy(buffer, temp.data(), temp.size() + 1); return temp.size(); } catch(...) { // This is the \u0026lt;system_error2\u0026gt; analogue of Standard Outcome\u0026#39;s  // error_from_exception() utility function. It consumes an exception  // ptr (defaulted to current exception), and tries to match it to a  // standard C++ library exception type, returning a system_code  // with an appropriate code domain (generic_code, posix_code,  // win32_code).  //  // Note that using this function requires including  // \u0026lt;outcome/experimental/status-code/include/system_code_from_exception.hpp\u0026gt;  // It is NOT included by Experimental Outcome by default.  return outcome_e::system_code_from_exception(); } } View this code on Github As the alias status_result\u0026lt;size_t\u0026gt; defaults the erased type to the alias system_code, the to_string() function returns (in concrete types) basic_result\u0026lt;size_t, status_code\u0026lt;erased\u0026lt;intptr_t\u0026gt;\u0026gt;\u0026gt;.\nThe standard Outcome function referenced is documented at  std::error_code error_from_exception(std::exception_ptr \u0026amp;\u0026amp;ep = std::current_exception(), std::error_code not_matched = std::make_error_code(std::errc::resource_unavailable_try_again)) noexcept . The proposed \u0026lt;system_error2\u0026gt; reference library implementation provides an identically named function taking similar parameters, but it returns a outcome_e::system_code (status_code\u0026lt;erased\u0026lt;intptr_t\u0026gt;\u0026gt;) instead of a std::error_code.\n"
},
{
	"uri": "https://ned14.github.io/outcome/tutorial/essential/result/inspecting/",
	"title": "Inspecting result&lt;T, EC&gt;",
	"tags": ["nodiscard", "value", "error", "try"],
	"description": "",
	"content": "Suppose we will be writing a function print_half that takes a std::string representing an integer and prints half the integer:\noutcome::result\u0026lt;void\u0026gt; print_half(const std::string\u0026amp; text); View this code on Github The type result\u0026lt;void\u0026gt; means that there is no value to be returned upon success, but that the operation might still fail, and we may be interested in inspecting the cause of the failure. The class template result\u0026lt;\u0026gt; is declared with the attribute [[nodiscard]], which means the compiler will warn you if you forget to inspect the returned object (in C++ 17 or later).\nThe implementation will do the following: if the integral number can be represented by an int, we will convert to int and use its arithmetical operations. If the number is too large, we will fall back to using a custom BigInt implementation that needs to allocate memory. In the implementation we will use the function convert defined in the previous section.\noutcome::result\u0026lt;void\u0026gt; print_half(const std::string\u0026amp; text) { if (outcome::result\u0026lt;int\u0026gt; r = convert(text)) // #1  { std::cout \u0026lt;\u0026lt; (r.value() / 2) \u0026lt;\u0026lt; std::endl; // #2  } else { if (r.error() == ConversionErrc::TooLong) // #3  { OUTCOME_TRY(auto i, BigInt::fromString(text)); // #4  std::cout \u0026lt;\u0026lt; i.half() \u0026lt;\u0026lt; std::endl; } else { return r.as_failure(); // #5  } } return outcome::success(); // #6 } View this code on Github #1. You test if result\u0026lt;\u0026gt; object represents a successful operation with contextual conversion to bool.\n#2. The function .value() extracts the successfully returned int.\n#3. The function .error() allows you to inspect the error sub-object, representing information about the reason for failure.\n#4. Macro OUTCOME_TRY represents a control statement. It implies that the expression in the second argument returns a result\u0026lt;\u0026gt;. The function is defined as:\n/*static*/ outcome::result\u0026lt;BigInt\u0026gt; BigInt::fromString(const std::string\u0026amp; s) View this code on Github Our control statement means: if fromString returned failure, this same error information should be returned from print_half, even though the type of result\u0026lt;\u0026gt; is different. If fromString returned success, we create variable i of type BigInt with the value returned from fromString. If control goes to subsequent line, it means fromString succeeded and variable of type BigInt is in scope.\n#5. In the return statement we extract the error information and use it to initialize the return value from print_half. We could have written return r.error(); instead, and it would have the same effect, but r.as_failure() will work when implicit construction from E has been disabled due to T and E having a constructibility relationship.\n#6. Function success() returns an object of type success\u0026lt;void\u0026gt; representing success. This is implicitly converted by all result and outcome types into a successful return, default constructing any T if necessary.\n"
},
{
	"uri": "https://ned14.github.io/outcome/experimental/differences/",
	"title": "Major differences",
	"tags": [],
	"description": "",
	"content": "The major design differences between \u0026lt;system_error\u0026gt; and proposed \u0026lt;system_error2\u0026gt; are as follows:\n experimental::status_code\u0026lt;DomainType\u0026gt; can represent warnings and form-of-success codes as well as failure codes. experimental::errored_status_code\u0026lt;DomainType\u0026gt; is more similar to std::error_code, in that it can only represent failures (this is enforced by C++ 20 contract or runtime assertion check).\n The code\u0026rsquo;s domain implementation defines the payload type to be transported around by experimental::status_code\u0026lt;DomainType\u0026gt;, rather than it being hardcoded to int as in std::error_code. The payload type can be anything you like, including non-trivially-copyable, move-only, complex etc types.\nThis facility is extremely useful. Extra failure metadata such as stack backtraces can be returned, for example. You can absolutely vary the payload depending on whether NDEBUG or _DEBUG is defined, too.\n If your domain defines a payload type which is trivially copyable or move relocating1, it gains an implicit convertibility to a move-only experimental::status_code\u0026lt;erased\u0026lt;T\u0026gt;\u0026gt; where T is another trivially copyable or move relocating type. This permits global headers to use a single, common, type erased, status code type which is highly desirable for code bases of any complexity. However, unlike std::error_code, which fulfils the exact same role in \u0026lt;system_error\u0026gt; based code, the type erased payload can be bigger than the hardcoded int in std::error_code.\nThis facility is also extremely useful, as extra failure metadata can be type erased, transported through code with no knowledge of such things, and the original type with failure metadata resurrected at the handling point. Indeed P1095 proposed std::error is a type alias to experimental::status_code\u0026lt;erased\u0026lt;intptr_t\u0026gt;\u0026gt;, and it can transport erased std::exception_ptr instances, POSIX error codes, and much more besides.\n Equality comparisons between status code\u0026rsquo;s with non-identical domains are always semantic i.e. are they semantically equivalent, rather than exactly equal? This mirrors when you compare std::error_code to a std::error_condition, but as there is no equivalent for the latter in \u0026lt;system_error2\u0026gt;, this means that when you see the code:\nif(code1 == code2) ...  \u0026hellip; you can be highly confident that this is an inexact, semantic, match operation. The same code under \u0026lt;system_error\u0026gt; is highly ambiguous as to whether exact or inexact comparison is being performed (after all, all there is is \u0026ldquo;code1 == code2\u0026rdquo;, so it depends on the types of code1 and code2 which usually is not obvious).\nThe ambiguity, and high cognitive load during auditing \u0026lt;system_error\u0026gt; code for correctness, has led to many surprising and unexpected failure handling bugs during the past decade in production C++.\n \u0026lt;system_error2\u0026gt;, being a new design, has all-constexpr construction and destruction which avoids the need for static global variables, as \u0026lt;system_error\u0026gt; has. Each of those static global variables requires an atomic fence just in case it has not been initialised, thus every retrieval of an error category bloats code and inhibits optimisation, plus makes the use of custom error code categories in header-only libraries unreliable. Boost.System has replicated the all-constexpr construction and destruction from \u0026lt;system_error2\u0026gt;, and thus now has similar characteristics in this regard.\n Finally, this is a small but important difference. Under \u0026lt;system_error\u0026gt;, this extremely common use case is ambiguous:\nif(ec) ...  Does this code mean \u0026ldquo;if there was an error?\u0026rdquo;, or \u0026ldquo;if the error code is set?\u0026rdquo;, or \u0026ldquo;is the error code non-zero?\u0026rdquo;. The correct answer according to the standard is the last choice, but a quick survey of open source \u0026lt;system_error\u0026gt; based code on github quickly demonstrates there is widespread confusion regarding correct usage.\n\u0026lt;system_error2\u0026gt; solves this by removing the boolean test entirely. One now writes if(sc.success()) ..., if(sc.failure()) ..., if(sc.empty()) ... and so on, thus eliminating ambiguity.\n   Move relocating is not in the standard, it is currently within WG21 Evolution Working Group Incubator. It is defined to be a type whose move constructor memcpy()\u0026rsquo;s the bits from source to destination, followed by memcpy() of the bits of a default constructed instance to source, and with a programmer-given guarantee that the destructor, when called on a default constructed instance, has no observable side effects. A surprising number of standard library types can meet this definition of move relocating, including std::vector\u0026lt;T\u0026gt;, std::shared_ptr\u0026lt;T\u0026gt;, and std::exception_ptr. [return]   "
},
{
	"uri": "https://ned14.github.io/outcome/tutorial/advanced/interop/filelib/",
	"title": "The File I/O library",
	"tags": [],
	"description": "",
	"content": "The File I/O library we shall be using is very similar to the one we saw earlier in this tutorial:\n// You may remember this from the tutorial section on Custom Payloads namespace filelib { // Error code + paths related to a failure. Also causes ADL discovery  // to check this namespace.  struct failure_info { std::error_code ec; path path1{}, path2{}; }; // Tell Outcome that failure_info is to be treated as a std::error_code  inline const std::error_code \u0026amp;make_error_code(const failure_info \u0026amp;fi) { return fi.ec; } // Tell Outcome that no-value observation should throw a custom exception  inline void outcome_throw_as_system_error_with_payload(failure_info fi) { // If the error code is not filesystem related e.g. ENOMEM, throw that  // as a standard STL exception.  OUTCOME_V2_NAMESPACE::try_throw_std_exception_from_error(fi.ec); // Throw the exact same filesystem_error exception which the throwing  // copy_file() edition does.  throw filesystem_error(fi.ec.message(), std::move(fi.path1), std::move(fi.path2), fi.ec); } // Localise a result implementation specific to this namespace.  template \u0026lt;classT\u0026gt; using result = OUTCOME_V2_NAMESPACE::result\u0026lt;T, failure_info\u0026gt;; // Writes a chunk of data to some file. Returns bytes written, or  // failure_info. Never throws exceptions.  result\u0026lt;size_t\u0026gt; write_file(string_view chunk) noexcept; } // namespace filelib View this code on Github This uses the advanced Outcome feature of programming the lazy synthesis of custom C++ exception throws from a payload carrying E type called failure_info. Like the HTTP library, it too template aliases a localised result implementation into its namespace with ADL bridging so Outcome customisation points can be discovered.\n"
},
{
	"uri": "https://ned14.github.io/outcome/experimental/worked-example-long/value_type/",
	"title": "The payload",
	"tags": [],
	"description": "",
	"content": "We define the code domain\u0026rsquo;s value_type \u0026ndash; the payload to be transported by status codes using this code domain \u0026ndash; to be a POSIX errno value, an integer line number and a const char pointer.\npublic: // This is the value type for `file_io_error`. We add line number and source file path.  struct value_type { typename outcome_e::posix_code::value_type errcode; // from POSIX, as we inherit from _posix_code_domain  // Our additional payload  int lineno; // from __LINE__  const char *file; // from __FILE__  // Could also place a backtrace of void *[16] here ...  }; View this code on Github You will note that this is a TriviallyCopyable type, and so gains an implicit conversion to any status_code\u0026lt;erased\u0026lt;T\u0026gt;\u0026gt; where sizeof(T) \u0026gt;= sizeof(value_type).\nerror is however status_code\u0026lt;erased\u0026lt;intptr_t\u0026gt;\u0026gt;, and sizeof(intptr_t) \u0026lt; sizeof(value_type), so it is not possible to implicitly convert status codes from this domain into error. Instead, you must tell the compiler how to do the conversion, as we shall see later.\n"
},
{
	"uri": "https://ned14.github.io/outcome/changelog/upgrade_v21_v22/",
	"title": "Upgrade guide v2.1 =&gt; v2.2",
	"tags": [],
	"description": "",
	"content": "In the start of 2020, after a year of listening to user feedback since entering Boost, Outcome v2.2 was published with a number of breaking source changes from Outcome v2.1 The full year of 2020 (three Boost releases) was given to announcing those upcoming changes, and testing the v2.2 branch in production. In late December 2020, Outcome v2.2 became the default Outcome, and all Outcome v2.1 code shall need to be upgraded to work with v2.2.\nTo upgrade an Outcome v2.1 based codebase to Outcome v2.2 is very easy:\n You will need a tool capable of finding regular expressions in all source files in a directory tree and replacing them \u0026ndash; most IDEs such as Visual Studio have such a tool with GUI, on POSIX a shell script such as this ought to work:\nfind /path/to/project -type f -name \u0026quot;*.hpp\u0026quot; | xargs sed -i \u0026quot;s/_TRY\\(([^(]*?),(.*?)\\);/_TRY((auto \u0026amp;\u0026amp;, \\1),\\2);/g\u0026quot; find /path/to/project -type f -name \u0026quot;*.cpp\u0026quot; | xargs sed -i \u0026quot;s/_TRY\\(([^(]*?),(.*?)\\);/_TRY((auto \u0026amp;\u0026amp;, \\1),\\2);/g\u0026quot; find /path/to/project -type f -name \u0026quot;*.hpp\u0026quot; | xargs sed -i \u0026quot;s/_TRY\\(([^(]*?)\\);/_TRYV2(auto \u0026amp;\u0026amp;, \\1);/g\u0026quot; find /path/to/project -type f -name \u0026quot;*.cpp\u0026quot; | xargs sed -i \u0026quot;s/_TRY\\(([^(]*?)\\);/_TRYV2(auto \u0026amp;\u0026amp;, \\1);/g\u0026quot;  The transformation needed are the regular expressions _TRY\\(([^(]*?),(.*?)\\); =\u0026gt; _TRY((auto \u0026amp;\u0026amp;, \\1),\\2); and TRY\\(([^(]*?)\\); =\u0026gt; _TRYV2(auto \u0026amp;\u0026amp;, \\1);. This is because in Outcome v2.2 onwards, OUTCOME_TRY(var, expr) no longer implicitly declares the variable created as auto\u0026amp;\u0026amp; on your behalf, now you must specify the storage of the variable. It also declares the internal uniquely named temporary as a value rather than as a reference, the initial brackets overrides this to force the use of a rvalue reference for the internal uniquely named temporary instead.\nThis makes use of Outcome\u0026rsquo;s new TRY syntax to tell the TRY operation to use references rather than values for the internal uniquely named temporary, thus avoiding any copies and moves. The only way to override the storage of the internal uniquely named temporary for non-value outputting TRY is via the new OUTCOME_TRYV2() which takes the storage specifier you desire as its first parameter.\nThe principle advantage of this change is that you can now assign to existing variables the successful results of expressions, instead of being forced to TRY into a new variable, and move that variable into the destination you intended. Also, because you can now specify storage, you can now assign the result of a TRYied operation into static or thread local storage.\n The find regex and replace rule above is to preserve exact semantics with Outcome v2.1 whereby the internal uniquely named temporary and the variable for the value are both rvalue references. If you\u0026rsquo;re feeling like more work, it is safer if you convert as many OUTCOME_TRY((auto \u0026amp;\u0026amp;, v), expr) to OUTCOME_TRY(auto \u0026amp;\u0026amp;v, expr) as possible. This will mean that TRY \u0026lsquo;consumes\u0026rsquo; expr i.e. moves it into the internal uniquely named temporary, if expr is an rvalue reference. Usually this does not affect existing code, but occasionally it can, generally a bit of code reordering will fix it.\n If your code uses the ADL discovered event hooks to intercept when basic_result and basic_outcome is constructed, copies or moved, you will need to either define the macro OUTCOME_ENABLE_LEGACY_SUPPORT_FOR to less than 220 to enable emulation, or upgrade the code to use the new mechanism.\nThe hooks themselves have identical signature, only the name and location has changed. Therefore upgrade is usually a case of copy-pasting the hook implementation into a custom NoValuePolicy implementation, and changing the ADL free function\u0026rsquo;s name from hook_* to on_*.\nYou are recommended to upgrade if possible, as the ADL discovered hooks were found in real world code usage to be brittle and surprising.\n Any usage of CamelCase named concepts from Outcome must be replaced with snake_case named concepts instead:\n concepts::ValueOrError\u0026lt;T\u0026gt; =\u0026gt; concepts::value_or_error\u0026lt;T\u0026gt; concepts::ValueOrNone\u0026lt;T\u0026gt; =\u0026gt; concepts::value_or_none\u0026lt;T\u0026gt;  The CamelCase naming is aliased to the snake_case naming if the macro OUTCOME_ENABLE_LEGACY_SUPPORT_FOR is defined to less than 220. Nevertheless you ought to upgrade here is possible, as due to a late change in C++ 20 all standard concepts are now snake_case named.\n Finally, despite that Outcome does not currently offer a stable ABI guarantee (hoped to begin in 2022), v2.1 had a stable storage layout for basic_result and basic_outcome. In v2.2 that storage layout has changed, so the ABIs generated by use of v2.1 and v2.2 are incompatible i.e. you will need to recompile everything using Outcome after you upgrade to v2.2.\n  "
},
{
	"uri": "https://ned14.github.io/outcome/tutorial/advanced/payload/copy_file2/",
	"title": "Upgrading the Filesystem TS",
	"tags": ["payload"],
	"description": "",
	"content": "An Outcome based solution to the dual overload problem is straightforward:\nnamespace filesystem2 { // Error code + paths related to a failure. Also causes ADL discovery to check this namespace.  struct failure_info { std::error_code ec; path path1, path2; }; // Tell Outcome that failure_info is to be treated as a std::error_code  inline const std::error_code \u0026amp;make_error_code(const failure_info \u0026amp;fi) { return fi.ec; } // Localise an outcome implementation specific to this namespace. Normally would just  // be `result`, but for clarity we\u0026#39;ll use `fs_result`.  template \u0026lt;classT\u0026gt; using fs_result = outcome::result\u0026lt;T, failure_info\u0026gt;; /*! Copies the file at path `from` to path `to`. \\returns Successful if file was successfully copied, otherwise the error code reported by the operating system plus a payload of the paths involved. \\throws Never throws. */ fs_result\u0026lt;void\u0026gt; copy_file(const path \u0026amp;from, const path \u0026amp;to) noexcept; } View this code on Github Starting at the bottom, there is now a single copy_file() function which returns a fs_result\u0026lt;void\u0026gt;. As result is either successful or not, there is no longer any point in returning a boolean, so we simply return void on success. On failure, as the template alias fs_result\u0026lt;T\u0026gt; above it shows, we are returning a failure_info structure containing an error code and the same additional information as filesystem_error provides.\nIt is important to note that the fact that failure_info is defined in namespace filesystem2 is very important. This is because Outcome uses Argument Dependent Lookup (ADL) to find the make_error_code() function, as well as other customisation point free functions. In other words, only the namespaces as defined by ADL are searched when finding a free function telling us what to do for failure_info, which includes the namespace failure_info is declared into.\n"
},
{
	"uri": "https://ned14.github.io/outcome/motivation/errno/",
	"title": "errno",
	"tags": [],
	"description": "errno with their good and bad sides.",
	"content": " The idiom of returning, upon failure, a special value and storing an error code (an int) inside a global (or thread-local) object errno is inherited from C, and used in its Standard Library:\nint readValue(const char * filename) { FILE* f = fopen(filename, \u0026#34;r\u0026#34;); if (f == NULL) return 0; // special value indicating failure  // keep errno value set by fopen()  int i; int r = fscanf(f, \u0026#34;%d\u0026#34;, \u0026amp;i); if (r == 0 || r == EOF) { // special values: i not read  errno = ENODATA; // choose error value to return  return 0; fclose(f); errno = 0; // clear error info (success)  return i; }  One advantage (to some, and a disadvantage to others) of this technique is that it uses familiar control statements (if and return) to indicate all execution paths that handle failures. When we read this code we know when and under what conditions it can exit without producing the expected result.\nDownsides Because on failure, as well as success, we write into a global (or thread-local) object, our functions are not pure: they have side effects. This means many useful compiler optimizations (like common subexpression elimination) cannot be applied. This shows that it is not only C++ that chooses suboptimal solutions for reporting failures.\nWhatever type we return, we always need a special value to spare, which is sometimes troublesome. In the above example, if the successfully read value of i is 0, and we return it, our callers will think it is a failure even though it is not.\nError propagation using if statements and early returns is manual. We can easily forget to check for the failure, and incorrectly let the subsequent operations execute, potentially causing damage to the program state.\nUpon nearly each function call layer we may have to change error code value so that it reflects the error condition adequate to the current layer. If we do so, the original error code is gone.\n"
},
{
	"uri": "https://ned14.github.io/outcome/tutorial/essential/outcome/",
	"title": "outcome&lt;&gt;",
	"tags": ["outcome"],
	"description": "Success-or-failure return types where failure can take two forms, expected/handled failure and unexpected/abort failure.",
	"content": " Type outcome\u0026lt;T, EC = varies, EP = varies, NoValuePolicy = policy::default_policy\u0026lt;T, EC, EP\u0026gt;\u0026gt; represents either a successfully computed value of type T, or one or two reasons for failure. Failure can be represented by EC, or EP, or both, although usually it will either be an EC or an EP. Similarly to result, EC defaults to std::error_code/boost::system::error_code, and EP defaults to std::exception_ptr/boost::exception_ptr.\nThe distinction is made into two types, EC and EP:\n EC represents a recoverable failure from a lower-layer function, perhaps which was returned through result\u0026lt;T, E = varies, NoValuePolicy = policy::default_policy\u0026lt;T, E, void\u0026gt;\u0026gt; . EP represents an unrecoverable failure where a C++ exception would ordinarily have been thrown. This is usually a pointer to an exception throw.  It should be emphasised that this distinction is by convention only, but it will be confusing to your users if you deviate significantly from this convention.\n Legacy codebases outcome is useful for transporting exceptions across layers of the program that were never designed with exception safety in mind.\nConsider a program consisting of three layers:\nmermaid.initialize({startOnLoad:true}); graph BT L3[\"Layer3\"] L2[\"Layer2_old\"] -- L3 L1[\"Layer1\"] -- L2   The highest-level layer, Layer3, uses exceptions for signalling failures. The middle layer, Layer2_old, was not designed with exception safety in mind and functions need to return information about failures in return value. But down in the implementation details, in Layer1, another library is used that again throws exceptions. The goal is to be able to transfer an exception thrown in Layer1 through Layer2_old, which is not exception-safe, and be able to rethrow it in Layer3.\nIn Layer1 we have two functions from two libraries: one reports failures by throwing exceptions, the other by returning result\u0026lt;\u0026gt;:\nauto f() -\u0026gt; int; // throws on failure auto g() noexcept -\u0026gt; outcome::result\u0026lt;int\u0026gt;; View this code on Github In Layer2_old we cannot use exceptions, so its function h uses return type outcome\u0026lt;\u0026gt; to report failures. It is using functions f and g and reports their failures inside outcome\u0026lt;\u0026gt;:\nauto old::h() noexcept -\u0026gt; outcome::outcome\u0026lt;int\u0026gt; { OUTCOME_TRY(auto i, (g())); // #1  try { return i + f(); } catch (...) { return std::current_exception(); // #2  } } View this code on Github #1. Operator TRY can forward failures encoded in result\u0026lt;T, EC\u0026gt; as outcome\u0026lt;T, EC, EP\u0026gt; without any loss in information. You can also use TRY to forward failure from one outcome\u0026lt;\u0026gt; to another.\n#2. You can store the current exception through std::exception_ptr inside outcome\u0026lt;T, EC, EP\u0026gt; without any loss in information (provided that EP is std::exception_ptr).\n"
},
{
	"uri": "https://ned14.github.io/outcome/alternatives/error_code/",
	"title": "std error codes",
	"tags": [],
	"description": "Advantages and disadvantages of `std::error_code`",
	"content": " std::error_code came originally from boost::error_code which was designed around 2008 as part of implementing Filesystem and Networking. They are a simple trivially copyable type offering improved type safety and functionality over C enumerations. You can read more about how std::error_code works here. They were standardised in the C++ 11 standard, and have been available in Boost since 2008.\nPros:  Predictable runtime overhead on the happy path.\n Predictable runtime overhead on the sad path.\n Unbiased syntax equal for both success and failure requiring explicit code written to handle both.\n Very little codegen bloat added to binaries (though there is a fixed absolute overhead for support libraries).\n Once constructed, passing around std::error_code instances optimises well, often being passed in CPU registers.\n Works well in all configurations of C++, including C++ exceptions and RTTI globally disabled.\n Works well on all niche architectures, such as HPC, GPUs, DSPs and microcontrollers.\n Ships with every standard library since C++ 11.\n  Cons:  Failure to write handling code for failure means failures get silently dropped. This is disturbingly easy to do.\n Results in branchy code, which is slow \u0026ndash; though predictably so \u0026ndash; for embedded controller CPUs.\n Because the std::error_category instance used in construction comes from a magic static, the compiler inserts an atomic operation around every std::error_code construction (e.g. https://godbolt.org/z/oGaf4qe8a). This can impact optimisation on compilers with poor optimisation of atomics.\n The payload of type int is incredibly constraining sometimes, especially on 64-bit platforms. It would have been much better if it were intptr_t instead of int.\n The payload value of all bits zero has silent hard coded semantics which is incompatible with many C enumerations, which start from value zero. This can cause silent dropping of failures in a very hard to debug way.\n How comparisons between disparate code categories (i.e. mapping) is supposed to work is non-obvious, and even standard library maintainers and many members of WG21 have been confused by it in the past.\n  (Note that this long list of design caveats is what led to the proposed superseding of std::error_code with std::error, which you can use today in Outcome.Experimental. See this page for more information).\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/converters/",
	"title": "Converters",
	"tags": [],
	"description": "",
	"content": " value_or_error\u0026lt;T, U\u0026gt; A customisable converter of value_or_error\u0026lt;T, E\u0026gt; concept matching types.\n "
},
{
	"uri": "https://ned14.github.io/outcome/tutorial/essential/no-value/",
	"title": "No-value policies",
	"tags": ["policies"],
	"description": "Describes the concept of NoValuePolicy and how to use no-value policies.",
	"content": "In the previous section we have seen that it would be useful if calling member function .value() on object of type outcome\u0026lt;T\u0026gt; that did not contain a value, would cause an exception to be thrown according to some user-defined policy.\nLet us consider result\u0026lt;T\u0026gt; first. It is an alias to basic_result\u0026lt;T, E, NoValuePolicy\u0026gt; , where E is the type storing error information and defaulted to std::error_code/boost::system::error_code, and NoValuePolicy is a no-value policy defaulted to default_policy\u0026lt;T, EC, EP\u0026gt; .\nThe semantics of basic_result::value() are:\n Calls NoValuePolicy::wide_value_check(*this). Return a reference to the contained value. If no value is actually stored, your program has entered undefined behaviour.  Thus, the semantics of function .value() depend on the no-value policy. The default policy (policy::default_policy\u0026lt;T, EC, void\u0026gt;) for EC of type std::error_code1 does the following:\n If r.has_value() == false throws exception std::system_error{r.error()}, otherwise no effect.  Class templates basic_result\u0026lt;T, E, NoValuePolicy\u0026gt; and basic_outcome\u0026lt;T, EC, EP, NoValuePolicy\u0026gt;\nnever use exceptions. Any exception-related logic is provided exclusively through no-value policies.\n When designing your own success-or-failure type using templates basic_result\u0026lt;\u0026gt; or basic_outcome\u0026lt;\u0026gt; you have to decide what no-value policy you want to use. Either create your own, or use one of the predefined policies.\nYou can also use one of the two other predefined aliases for basic_result\u0026lt;\u0026gt;:\n unchecked\u0026lt;T, E = varies\u0026gt; : it uses policy all_narrow , where any observation of a missing value or error is undefined behavior; checked\u0026lt;T, E = varies\u0026gt; : it uses policy throw_bad_result_access\u0026lt;EC\u0026gt; , where any observation of a missing value or error throws bad_result_access_with\u0026lt;EC\u0026gt; or bad_result_access respectively.   Similar overloads exist for throwing boost::system::system_error when EC is boost::system::error_code. [return]   "
},
{
	"uri": "https://ned14.github.io/outcome/tutorial/advanced/interop/app/",
	"title": "The Application",
	"tags": [],
	"description": "",
	"content": "The application is of course also based on Outcome, and like the HTTP library is also of mixed-failure design in that failure can be returned via error code, type erased exception_ptr or indeed a C++ exception throw.\n// This is the namespace of the application which is connecting together the httplib, // filelib and tidylib libraries into a solution. namespace app { // Create an ADL bridge so copy/move hooks will be searched for in this namespace  struct error_code : public std::error_code { // passthrough  using std::error_code::error_code; error_code() = default; error_code(std::error_code ec) : std::error_code(ec) { } }; // Localise an outcome implementation for this namespace  template \u0026lt;classT\u0026gt; using outcome = //  OUTCOME_V2_NAMESPACE::outcome\u0026lt;T, error_code /*, std::exception_ptr */\u0026gt;; using OUTCOME_V2_NAMESPACE::success; } // namespace app View this code on Github Here we localise a passthrough error_code solely for the purpose of ADL bridging, otherwise the localised outcome configured is the default one which comes with Outcome. We covered this technique of \u0026ldquo;passthrough error_code\u0026rdquo; earlier in this tutorial.\nThe way we are going to configure interop is as follows:\n The application shall use error_code for anticipated failure and C++ exception throws for unanticipated failure. We shall choose the convention that app::outcome with exception ptr solely and exclusively represents a type erased failure from a third party library.  Thus if one calls .value() on an app::outcome, both anticipated failure within the app and type erased failure from a third party library shall be converted to a C++ exception throw.\n"
},
{
	"uri": "https://ned14.github.io/outcome/tutorial/advanced/payload/copy_file3/",
	"title": "Auto-throwing filesystem_error",
	"tags": ["default-actions", "value"],
	"description": "",
	"content": "Something not mentioned at all until now (and properly described in the next section, Default actions) is that Outcome can be programmed take various actions when the user tries to observe .value() when there is no value, and so on for the other possible state observations.\nSeeing as we are replacing the throwing overload of copy_file() in the Filesystem TS with a result returning edition instead, it would make sense if an attempt to observe the value of an unsuccessful fs_result threw the exact same filesystem_error as the Filesystem TS does.\nTelling Outcome how to throw a filesystem_error with payload of the failing paths is easy:\nnamespace filesystem2 { // If we would like Outcome to do something other than the default action (see next  // section), we can declare this ADL discovered free function to customise what  // to do instead.  //  // Note that rvalue semantics are propagated internally by Outcome, so if the user  // called .value() on a rvalued result, failure_info will be moved rather than  // copied from the result. That means we can overload once with value semantics,  // and not need to overload for lvalue and rvalue situations unless we really feel  // we need to for some reason.  inline void outcome_throw_as_system_error_with_payload(failure_info fi) { // If the error code is not filesystem related e.g. ENOMEM, throw that as a  // standard STL exception.  outcome::try_throw_std_exception_from_error(fi.ec); // Throw the exact same filesystem_error exception which the throwing copy_file()  // edition does.  throw filesystem_error(fi.ec.message(), std::move(fi.path1), //  std::move(fi.path2), fi.ec); } } View this code on Github Reference documentation for the above functions:\n List of builtin outcome_throw_as_system_error_with_payload() overloads void try_throw_std_exception_from_error(std::error_code ec, const std::string \u0026amp;msg = std::string{})   Usage of our new \u0026ldquo;upgraded\u0026rdquo; Filesystem copy_file() might now be as follows:\n// Non-throwing use case  auto o = filesystem2::copy_file(\u0026#34;dontexist\u0026#34;, \u0026#34;alsodontexist\u0026#34;); if(!o) { std::cerr \u0026lt;\u0026lt; \u0026#34;Copy file failed with error \u0026#34; \u0026lt;\u0026lt; o.error().ec.message() //  \u0026lt;\u0026lt; \u0026#34; (path1 = \u0026#34; \u0026lt;\u0026lt; o.error().path1 \u0026lt;\u0026lt; \u0026#34;, path2 = \u0026#34; \u0026lt;\u0026lt; o.error().path2 \u0026lt;\u0026lt; \u0026#34;)\u0026#34; //  \u0026lt;\u0026lt; std::endl; } // Throwing use case  try { // Try to observe the successful value, thus triggering default actions which invokes  // our outcome_throw_as_system_error_with_payload() above which then throws filesystem_error  // exactly like the Filesystem TS does for its throwing overload.  filesystem2::copy_file(\u0026#34;dontexist\u0026#34;, \u0026#34;alsodontexist\u0026#34;).value(); } catch(const filesystem2::filesystem_error \u0026amp;e) { std::cerr \u0026lt;\u0026lt; \u0026#34;Copy file failed with exception \u0026#34; \u0026lt;\u0026lt; e.what() //  \u0026lt;\u0026lt; \u0026#34; (path1 = \u0026#34; \u0026lt;\u0026lt; e.path1() \u0026lt;\u0026lt; \u0026#34;, path2 = \u0026#34; \u0026lt;\u0026lt; e.path2() \u0026lt;\u0026lt; \u0026#34;)\u0026#34; //  \u0026lt;\u0026lt; std::endl; } catch(const std::exception \u0026amp;e) { std::cerr \u0026lt;\u0026lt; \u0026#34;Copy file failed with exception \u0026#34; \u0026lt;\u0026lt; e.what() //  \u0026lt;\u0026lt; std::endl; } View this code on Github "
},
{
	"uri": "https://ned14.github.io/outcome/experimental/c-api/from-c/",
	"title": "C Results",
	"tags": [],
	"description": "Outcome&#39;s C Result support",
	"content": "The C macro API header \u0026lt;outcome/experimental/result.h\u0026gt; has some macros for working with any kind of Result:\n CXX_DECLARE_RESULT(ident, T, E) Declares to C a basic_result type uniquely identified by ident. T is available at the member variable .value, and E is available at the member variable .error. If you call this from within C++, make SURE it is not within a extern \"C\" block! CXX_RESULT(ident) A reference to a previously declared result type with unique ident. CXX_RESULT_HAS_VALUE(r) Evaluates to 1 (true) if the input result has a value. CXX_RESULT_HAS_ERROR(r) Evaluates to 1 (true) if the input result has an error. CXX_RESULT_ERROR_IS_ERRNO(r) Evaluates to 1 (true) if the input result's error value is a code in the POSIX errno domain.  The above let you work, somewhat awkwardly, with any C-compatible basic_result\u0026lt;T, E\u0026gt;. basic_result\u0026lt;T, E\u0026gt; is trivially copyable and standard layout if its T and E are both so, and it has the C layout:\nstruct cxx_result_##ident { union { T value; E error; }; unsigned flags; };  Note that this layout is different to that of CXX_DECLARE_STATUS_CODE as the C++ result has a different layout if E is a status code.\n"
},
{
	"uri": "https://ned14.github.io/outcome/experimental/c-api/from-cxx/example2/",
	"title": "Calling it from C",
	"tags": [],
	"description": "",
	"content": "Firstly we need to declare to C our result returning C++ function:\n// Declare our C++ function\u0026#39;s returning result type. Only needs to be done once. // This declares an `status_result\u0026lt;size_t, system_code\u0026gt;` which is an alias to // `basic_result\u0026lt;size_t, status_code\u0026lt;erased\u0026lt;intptr_t\u0026gt;\u0026gt;\u0026gt;`. // // The first parameter is some unique identifier for this type which will be used // whenever we reference this type in the future. CXX_DECLARE_RESULT_SYSTEM(to_string_rettype, size_t) // Tell C about our extern C++ function `to_string()` extern CXX_RESULT_SYSTEM(to_string_rettype) _Z9to_stringPcmi(char *buffer, size_t bufferlen, int v); View this code on Github Now let\u0026rsquo;s call the C++ function from C:\nvoid print(int v) { char buffer[4]; CXX_RESULT_SYSTEM(to_string_rettype) res; res = _Z9to_stringPcmi(buffer, sizeof(buffer), v); if(CXX_RESULT_HAS_VALUE(res)) { printf(\u0026#34;to_string(%d) fills buffer with \u0026#39;%s\u0026#39; of %zu characters\\n\u0026#34;, v, buffer, res.value); return; } // Is the error returned in the POSIX domain and thus an errno?  if(CXX_RESULT_ERROR_IS_ERRNO(res)) { fprintf(stderr, \u0026#34;to_string(%d) failed with error code %d (%s)\\n\u0026#34;, v, (int) res.error.value, strerror((int) res.error.value)); return; } fprintf(stderr, \u0026#34;to_string(%d) failed with unknown error code %lld\\n\u0026#34;, v, (long long) res.error.value); } int main(void) { print(9); print(99); print(999); print(9999); return 0; } View this code on Github Running this C program yields:\nto_string(9) fills buffer with '9' of 1 characters to_string(99) fills buffer with '99' of 2 characters to_string(999) fills buffer with '999' of 3 characters to_string(9999) failed with error code 105 (No buffer space available)  "
},
{
	"uri": "https://ned14.github.io/outcome/tutorial/essential/coroutines/",
	"title": "Coroutines",
	"tags": ["coroutines"],
	"description": "Using Outcome in C++ Coroutines",
	"content": "In v2.1.2 Outcome published official support for using Outcome within C++ coroutines. This page documents that support.\nAll standard C++ Coroutines have the following form:\n// Coroutine functions MUST return an AWAITABLE type AWAITABLE\u0026lt;int\u0026gt; function_name(Args ...) { ... ordinary C++ ... if(!...) { co_return 5; // CANNOT use ordinary \u0026#39;return\u0026#39; from coroutines  } ... // Possibly suspend this coroutine\u0026#39;s execution until the  // awaitable resumes execution of dependent code  auto x = co_await expr_resulting_in_AWAITABLE; ... }  The type AWAITABLE\u0026lt;T\u0026gt; is any type which publishes the Coroutine protocol telling C++ how to suspend and resume execution of a coroutine which returns a T. It is out of scope of this page to document how to do this, however note that the eager\u0026lt;T, Executor = void\u0026gt; and lazy\u0026lt;T, Executor = void\u0026gt; types below are completely generic awaitables suitable for use in ANY code. They only behave differently if T, the type being returned by the awaitable, is an Outcome type e.g. outcome::basic_result or outcome::basic_outcome.\n"
},
{
	"uri": "https://ned14.github.io/outcome/tutorial/advanced/payload/",
	"title": "Custom payloads",
	"tags": ["payload", "has_error_code", "make_error_code"],
	"description": "Success-or-failure return types where extra information in addition to the error code accompanies failure.",
	"content": "So far in this tutorial, type EC in result\u0026lt;T, EC\u0026gt; has always been a std::error_code or boost::system::error_code. With NoValuePolicy set to default_policy\u0026lt;T, EC, EP\u0026gt; , EC needs in fact to merely satisfy the trait is_error_code_available\u0026lt;T\u0026gt; for EC to be treated as if an error_code. Outcome specialises that trait for std::error_code and boost::system::error_code, hence they \u0026ldquo;just work\u0026rdquo;.\nIf no specialisation exists, trait::is_error_code_available\u0026lt;EC\u0026gt; is true if there exists some ADL discovered free function make_error_code(EC).\nThus, we can in fact use any custom EC type we like, including one carrying additional information, or payload. This payload can carry anything you like, and you can tell Outcome to do various things with that payload under various circumstances. For example:\n If the user tries to observe an unsuccessful result, throw a custom exception containing the cause of failure with accompanying context from the payload. If the user ever constructs an outcome from a payload carrying result, set the exception ptr in the constructed outcome to a custom exception containing the cause of the failure with accompanying context from the payload. Transmit a stack backtrace specifying the exact point at which failure occurred, symbolising that backtrace into human readable text at the moment of conversion into human readable text. Upon a namespace-localised result from library A being copy/moved into a namespace-localised result from C bindings library B, set the C errno if the error code and category map onto the errno domain.  There are many, many other options of course. This tutorial can only cover a reasonable subset. This section covers Example 1 above, throwing custom exceptions with payload upon observation of an unsuccessful result.\n"
},
{
	"uri": "https://ned14.github.io/outcome/motivation/error_codes/",
	"title": "Error codes",
	"tags": [],
	"description": "Error codes with their good and bad sides.",
	"content": " Error codes are reasonable error handling technique, also working in C. In this case the information is also stored as an int, but returned by value, which makes it possible to make functions pure (side-effect-free and referentially transparent).\nint readInt(const char * filename, int\u0026amp; val) { FILE* fd; int r = openFile(filename, /*out*/ fd); if (r != 0) return r; // return whatever error openFile() returned  r = readInt(fd, /*out*/ val); if (r != 0) return READERRC_NOINT; // my error code  return 0; // success }  Because the type of the error information (int) is known statically, no memory allocation or type erasure is required. This technique is very efficient.\nDownsides All failure paths written manually can be considered both an advantage and a disadvantage. Forgetting to put a failure handling if causes bugs.\nIf I need to substitute an error code returned by lower-level function with mine more appropriate at this level, the information about the original failure is gone.\nAlso, all possible error codes invented by different programmers in different third party libraries must fit into one int and not overlap with any other error code value. This is quite impossible and does not scale well.\nBecause errors are communicated through returned values, we cannot use function\u0026rsquo;s return type to return computed values. Computed values are written to function output parameters, which requires objects to be created before we have values to put into them. This requires many objects in unintended state to exist. Writing to output parameters often requires an indirection and can incur some run-time cost.\n"
},
{
	"uri": "https://ned14.github.io/outcome/faq/",
	"title": "Frequently asked questions",
	"tags": [],
	"description": "",
	"content": "    Is Outcome safe to use in extern APIs? Does Outcome implement over-alignment? Does Outcome implement the no-fail, strong or basic exception guarantee? Does Outcome have a stable ABI and API? Can I use result\u0026lt;T, EC\u0026gt; across DLL/shared object boundaries? Why two types result\u0026lt;\u0026gt; and outcome\u0026lt;\u0026gt;, rather than just one? How badly will including Outcome in my public interface affect compile times? Is Outcome suitable for fixed latency/predictable execution coding such as for high frequency trading or audio? What kind of runtime performance impact will using Outcome in my code introduce?  High end CPU: Intel Skylake x64 Mid tier CPU: ARM Cortex A72 Low end CPUs: Intel Silvermont x64 and ARM Cortex A53  Why is implicit default construction disabled? How far away from the proposed std::expected\u0026lt;T, E\u0026gt; is Outcome\u0026rsquo;s checked\u0026lt;T, E\u0026gt;? Why doesn\u0026rsquo;t Outcome duplicate std::expected\u0026lt;T, E\u0026gt;\u0026rsquo;s design? Is Outcome riddled with undefined behaviour for const, const-containing and reference-containing types?  More detail     Is Outcome safe to use in extern APIs? Outcome is specifically designed for use in the public interfaces of multi-million line codebases. result\u0026rsquo;s layout is hard coded to:\nstruct trivially_copyable_result_layout { union { value_type value; error_type error; }; unsigned int flags; };  \u0026hellip; if both value_type and error_type are TriviallyCopyable, otherwise:\nstruct non_trivially_copyable_result_layout { value_type value; unsigned int flags; error_type error; };  This is C-compatible if value_type and error_type are C-compatible.  std::error_code is probably C-compatible, but its layout is not standardised (though there is a normative note in the standard about its layout). Hence Outcome cannot provide a C macro API for standard Outcome, but we can for Experimental Outcome.\nDoes Outcome implement over-alignment? Outcome propagates any over-alignment of the types you supply to it as according to the layout specified above. Therefore the ordinary alignment and padding rules for your compiler are used.\nDoes Outcome implement the no-fail, strong or basic exception guarantee? (You can read about the meaning of these guarantees at cppreference.com)\nIf for the following operations:\n Construction Assignment Swap  \u0026hellip; the corresponding operation in all of value_type, error_type (and exception_type for outcome) is noexcept(true), then result and outcome\u0026rsquo;s operation is noexcept(true). This propagates the no-fail exception guarantee of the underlying types. Otherwise the basic guarantee applies for all but Swap, under the same rules as for the struct layout type given above e.g. value would be constructed first, then the flags, then the error. If the error throws, value and status bits would be as if the failure had not occurred, same as for aborting the construction of any struct type.\nIt is recognised that these weak guarantees may be unsuitable for some people, so Outcome implements swap() with much stronger guarantees, as one can locally refine, without too much work, one\u0026rsquo;s own custom classes from result and outcome implementing stronger guarantees for construction and assignment using swap() as the primitive building block.\nThe core ADL discovered implementation of strong guarantee swap is strong_swap(bool \u0026amp;all_good, T \u0026amp;a, T \u0026amp;b) . This can be overloaded by third party code with custom strong guarantee swap implementations, same as for std::swap(). Because strong guarantee swap may fail when trying to restore input state during handling of failure to swap, the all_good boolean becomes false if restoration fails, at which point both results/outcomes get marked as tainted via has_lost_consistency() .\nIt is up to you to check this flag to see if known good state has been lost, as Outcome never does so on your behalf. The simple solution to avoiding having to deal with this situation is to always choose your value, error and exception types to have non-throwing move constructors and move assignments. This causes the strong swap implementation to no longer be used, as it is no longer required, and standard swap is used instead.\nDoes Outcome have a stable ABI and API? The layout changed for all trivially copyable types between Outcome v2.1 and v2.2, as union based storage was introduced. From v2.2 onwards, the layout is not expected to change again.\nIf v2.2 proves to be unchanging for 24 months, Outcome\u0026rsquo;s ABI and API will be formally fixed as the v2 interface and written into stone forever. Thereafter the ABI compliance checker will be run per-commit to ensure Outcome\u0026rsquo;s ABI and API remains stable. This is currently expected to occur in 2022.\nNote that the stable ABI and API guarantee will only apply to standalone Outcome, not to Boost.Outcome. Boost.Outcome has dependencies on other parts of Boost which are not stable across releases.\nNote also that the types you configure a result or outcome with also need to be ABI stable if result or outcome is to be ABI stable.\nCan I use result\u0026lt;T, EC\u0026gt; across DLL/shared object boundaries? A known problem with using Windows DLLs (and to smaller extent POSIX shared libraries) is that global objects may get duplicated: one instance in the executable and one in the DLL. This behaviour is not incorrect according to the C++ Standard, as the Standard does not recognize the existence of DLLs or shared libraries. Therefore, program designs that depend on globals having unique addresses may become compromised when used in a program using DLLs.\nNothing in Outcome depends on the addresses of globals, plus the guaranteed fixed data layout (see answer above) means that different versions of Outcome can be used in different DLLs, and it probably will work okay (it is still not advised that you do that as that is an ODR violation). However, one of the most likely candidate for EC \u0026ndash; std::error_code \u0026ndash; does depend on the addresses of globals for correct functioning.\nThe standard library is required to implement globally unique addresses for the standard library provided  std::error_category implementations e.g. std::system_category(). User defined error code categories may not have unique global addresses, and thus introduce misoperation.\nboost::system::error_code, since version 1.69 does offer an opt-in guarantee that it does not depend on the addresses of globals if the user defined error code category opts-in to the 64-bit comparison mechanism. This can be seen in the specification of error_category::operator== in Boost.System synopsis.\nAlternatively, the status_code in Experimental Outcome, due to its more modern design, does not suffer from any problems from being used in shared libraries in any configuration.\nWhy two types result\u0026lt;\u0026gt; and outcome\u0026lt;\u0026gt;, rather than just one? result is the simple, success OR failure type.\noutcome extends result with a third state to transport, conventionally (but not necessarily) some sort of \u0026ldquo;abort\u0026rdquo; or \u0026ldquo;exceptional\u0026rdquo; state which a function can return to indicate that not only did the operation fail, but it did so catastrophically i.e. please abort any attempt to retry the operation.\nA perfect alternative to using outcome is to throw a C++ exception for the abort code path, and indeed most programs ought to do exactly that instead of using outcome. However there are a number of use cases where choosing outcome shines:\n Where C++ exceptions or RTTI is not available, but the ability to fail catastrophically without terminating the program is important. Where deterministic behaviour is required even in the catastrophic failure situation. In unit test suites of code using Outcome it is extremely convenient to accumulate test failures into an outcome for later reporting. A similar convenience applies to RPC situations, where C++ exception throws need to be accumulated for reporting back to the initiating endpoint. Where a function is \u0026ldquo;dual use deterministic\u0026rdquo; i.e. it can be used deterministically, in which case one switches control flow based on .error(), or it can be used non-deterministically by throwing an exception perhaps carrying a custom payload.  How badly will including Outcome in my public interface affect compile times? The quick answer is that it depends on how much convenience you want.\nThe convenience header \u0026lt;result.hpp\u0026gt; is dependent on \u0026lt;system_error\u0026gt; or Boost.System, which unfortunately includes \u0026lt;string\u0026gt; and thus drags in quite a lot of other slow-to-parse stuff. If your public interface already includes \u0026lt;string\u0026gt;, then the impact of additionally including Outcome will be low. If you do not include \u0026lt;string\u0026gt;, unfortunately impact may be relatively quite high, depending on the total impact of your public interface files.\nIf you\u0026rsquo;ve been extremely careful to avoid ever including the most of the STL headers into your interfaces in order to maximise build performance, then \u0026lt;basic_result.hpp\u0026gt; can have as few dependencies as:\n \u0026lt;cstdint\u0026gt; \u0026lt;initializer_list\u0026gt; \u0026lt;iosfwd\u0026gt; \u0026lt;new\u0026gt; \u0026lt;type_traits\u0026gt; \u0026lt;cstdio\u0026gt; \u0026lt;cstdlib\u0026gt; \u0026lt;cassert\u0026gt;  These, apart from \u0026lt;iosfwd\u0026gt;, tend to be very low build time impact in most standard library implementations. If you include only \u0026lt;basic_result.hpp\u0026gt;, and manually configure basic_result\u0026lt;\u0026gt; by hand, compile time impact will be minimised.\n(See reference documentation for basic_result\u0026lt;T, E, NoValuePolicy\u0026gt; for more detail.\nIs Outcome suitable for fixed latency/predictable execution coding such as for high frequency trading or audio? Great care has been taken to ensure that Outcome never unexpectedly executes anything with unbounded execution times such as malloc(), dynamic_cast\u0026lt;\u0026gt;() or throw. Outcome works perfectly with C++ exceptions and RTTI globally disabled.\nOutcome\u0026rsquo;s entire design premise is that its users are happy to exchange a small, predictable constant overhead during successful code paths, in exchange for predictable failure code paths.\nIn contrast, table-based exception handling gives zero run time overhead for the successful code path, and completely unpredictable (and very expensive) overhead for failure code paths.\nFor code where predictability of execution, no matter the code path, is paramount, writing all your code to use Outcome is not a bad place to start. Obviously enough, do choose a non-throwing policy when configuring outcome or result such as all_narrow to guarantee that exceptions can never be thrown by Outcome (or use the convenience typedef for result, unchecked\u0026lt;T, E = varies\u0026gt; which uses policy::all_narrow).\nWhat kind of runtime performance impact will using Outcome in my code introduce? It is very hard to say anything definitive about performance impacts in codebases one has never seen. Each codebase is unique. However to come up with some form of measure, we timed traversing ten stack frames via each of the main mechanisms, including the \u0026ldquo;do nothing\u0026rdquo; (null) case.\nA stack frame is defined to be something called by the compiler whilst unwinding the stack between the point of return in the ultimate callee and the base caller, so for example ten stack allocated objects might be destructed, or ten levels of stack depth might be unwound. This is not a particularly realistic test, but it should at least give one an idea of the performance impact of returning Outcome\u0026rsquo;s result or outcome over say returning a plain integer, or throwing an exception.\nThe following figures are for Outcome v2.1.0 with GCC 7.4, clang 8.0 and Visual Studio 2017.9. Figures for newer Outcomes with newer compilers can be found at https://github.com/ned14/outcome/tree/develop/benchmark.\nHigh end CPU: Intel Skylake x64 This is a high end CPU with very significant ability to cache, predict, parallelise and execute out-of-order such that tight, repeated loops perform very well. It has a large Œºop cache able to wholly contain the test loop, meaning that these results are a best case performance.\n  Log graph comparing GCC 7.4, clang 8.0 and Visual Studio 2017.9 on x64, for exceptions-globally-disabled, ordinary and link-time-optimised build configurations.   As you can see, throwing and catching an exception is expensive on table-based exception handling implementations such as these, anywhere between 26,000 and 43,000 CPU cycles. And this is the hot path situation, this benchmark is a loop around hot cached code. If the tables are paged out onto storage, you are talking about millions of CPU cycles.\nSimple integer returns (i.e. do nothing null case) are always going to be the fastest as they do the least work, and that costs 80 to 90 CPU cycles on this Intel Skylake CPU.\nNote that returning a result\u0026lt;int, std::error_code\u0026gt; with a \u0026ldquo;success (error code)\u0026rdquo; is no more than 5% added runtime overhead over returning a naked int on GCC and clang. On MSVC it costs an extra 20% or so, mainly due to poor code optimisation in the VS2017.9 compiler. Note that \u0026ldquo;success (experimental status code)\u0026rdquo; optimises much better, and has almost no overhead over a naked int.\nReturning a result\u0026lt;int, std::error_code\u0026gt; with a \u0026ldquo;failure (error code)\u0026rdquo; is less than 5% runtime overhead over returning a success on GCC, clang and MSVC.\nYou might wonder what happens if type E has a non-trivial destructor, thus making the result\u0026lt;T, E\u0026gt; have a non-trivial destructor? We tested E = std::exception_ptr and found less than a 5% overhead to E = std::error_code for returning success. Returning a failure was obviously much slower at anywhere between 300 and 1,100 CPU cycles, due to the dynamic memory allocation and free of the exception ptr, plus at least two atomic operations per stack frame, but that is still two orders of magnitude better than throwing and catching an exception.\nWe conclude that if failure is anything but extremely rare in your C++ codebase, using Outcome instead of throwing and catching exceptions ought to be quicker overall:\n Experimental Outcome is statistically indistinguishable from the null case on this high end CPU, for both returning success and failure, on all compilers. Standard Outcome is less than 5% worse than the null case for returning successes on GCC and clang, and less than 10% worse than the null case for returning failures on GCC and clang. Standard Outcome optimises poorly on VS2017.9, indeed markedly worse than on previous point releases, so let\u0026rsquo;s hope that Microsoft fix that soon. It currently has a less than 20% overhead on the null case.  Mid tier CPU: ARM Cortex A72 This is a four year old mid tier CPU used in many high end mobile phones and tablets of its day, with good ability to cache, predict, parallelise and execute out-of-order such that tight, repeated loops perform very well. It has a Œºop cache able to wholly contain the test loop, meaning that these results are a best case performance.\n  Log graph comparing GCC 7.3 and clang 7.3 on ARM64, for exceptions-globally-disabled, ordinary and link-time-optimised build configurations.   This ARM chip is a very consistent performer \u0026ndash; null case, success, or failure, all take almost exactly the same CPU cycles. Choosing Outcome, in any configuration, makes no difference to not using Outcome at all. Throwing and catching a C++ exception costs about 90,000 CPU cycles, whereas the null case/Outcome costs about 130 - 140 CPU cycles.\nThere is very little to say about this CPU, other than Outcome is zero overhead on it. The same applied to the ARM Cortex A15 incidentally, which I test cased extensively when deciding on the Outcome v2 design back after the first peer review. The v2 design was chosen partially because of such consistent performance on ARM.\nLow end CPUs: Intel Silvermont x64 and ARM Cortex A53 These are low end CPUs with a mostly or wholly in-order execution core. They have a small or no Œºop cache, meaning that the CPU must always decode the instruction stream. These results represent an execution environment more typical of CPUs two decades ago, back when table-based EH created a big performance win if you never threw an exception.\n  Log graph comparing GCC 7.3 and clang 7.3 on x64, for exceptions-globally-disabled, ordinary and link-time-optimised build configurations.     Log graph comparing GCC 7.3 and clang 7.3 on ARM64, for exceptions-globally-disabled, ordinary and link-time-optimised build configurations.  \nThe first thing to mention is that clang generates very high performance code for in-order cores, far better than GCC. It is said that this is due to a very large investment by Apple in clang/LLVM for their devices sustained over many years. In any case, if you\u0026rsquo;re targeting in-order CPUs, don\u0026rsquo;t use GCC if you can use clang instead!\nFor the null case, Silvermont and Cortex A53 are quite similar in terms of CPU clock cycles. Ditto for throwing and catching a C++ exception (approx 150,000 CPU cycles). However the Cortex A53 does far better with Outcome than Silvermont, a 15% versus 100% overhead for Standard Outcome, and a 4% versus 20% overhead for Experimental Outcome.\nMuch of this large difference is in fact due to calling convention differences. x64 permits up to 8 bytes to be returned from functions by CPU register. result\u0026lt;int\u0026gt; consumes 24 bytes, so on x64 the compiler writes the return value to the stack. However ARM64 permits up to 64 bytes to be returned in registers, so result\u0026lt;int\u0026gt; is returned via CPU registers on ARM64.\nOn higher end CPUs, memory is read and written in cache lines (32 or 64 bytes), and reads and writes are coalesced and batched together by the out-of-order execution core. On these low end CPUs, memory is read and written sequentially per assembler instruction, so only one load or one store to L1 cache can occur at a time. This makes writing the stack particularly slow on in-order CPUs. Memory operations which \u0026ldquo;disappear\u0026rdquo; on higher end CPUs take considerable time on low end CPUs. This particularly punishes Silvermont in a way which does not punish the Cortex A53, because of having to write multiple values to the stack to create the 24 byte object to be returned.\nThe conclusion to take away from this is that if you are targeting a low end CPU, table-based EH still delivers significant performance improvements for the success code path. Unless determinism in failure is critically important, you should not use Outcome on in-order execution CPUs.\nWhy is implicit default construction disabled? This was one of the more interesting points of discussion during the peer review of Outcome v1. v1 had a formal empty state. This came with many advantages, but it was not felt to be STL idiomatic as std::optional\u0026lt;result\u0026lt;T\u0026gt;\u0026gt; is what was meant, so v2 has eliminated any legal possibility of being empty.\nThe expected\u0026lt;T, E\u0026gt; proposal of that time (May 2017) did permit default construction if its T type allowed default construction. This was specifically done to make expected\u0026lt;T, E\u0026gt; more useful in STL containers as one can say resize a vector without having to supply an expected\u0026lt;T, E\u0026gt; instance to fill the new items with. However there was some unease with that design choice, because it may cause programmers to use some type T whose default constructed state is overloaded with additional meaning, typically \u0026ldquo;to be filled\u0026rdquo; i.e. a de facto empty state via choosing a magic value.\nFor the v2 redesign, the various arguments during the v1 review were considered. Unlike expected\u0026lt;T, E\u0026gt; which is intended to be a general purpose Either monad vocabulary type, Outcome\u0026rsquo;s types are meant primarily for returning success or failure from functions. The API should therefore encourage the programmer to not overload the successful type with additional meaning of \u0026ldquo;to be filled\u0026rdquo; e.g. result\u0026lt;std::optional\u0026lt;T\u0026gt;\u0026gt;. The decision was therefore taken to disable implicit default construction, but still permit explicit default construction by making the programmer spell out their intention with extra typing.\nTo therefore explicitly default construct a result\u0026lt;T\u0026gt; or outcome\u0026lt;T\u0026gt;, use one of these forms as is the most appropriate for the use case:\n Construct with just in_place_type\u0026lt;T\u0026gt; e.g. result\u0026lt;T\u0026gt;(in_place_type\u0026lt;T\u0026gt;). Construct via success() e.g. outcome\u0026lt;T\u0026gt;(success()). Construct from a void form e.g. result\u0026lt;T\u0026gt;(result\u0026lt;void\u0026gt;(in_place_type\u0026lt;void\u0026gt;)).  How far away from the proposed std::expected\u0026lt;T, E\u0026gt; is Outcome\u0026rsquo;s checked\u0026lt;T, E\u0026gt;? Not far, in fact after the first Boost.Outcome peer review in May 2017, Expected moved much closer to Outcome, and Outcome deliberately provides checked\u0026lt;T, E = varies\u0026gt; as a semantic equivalent.\nHere are the remaining differences which represent the divergence of consensus opinion between the Boost peer review and WG21 on the proper design for this object:\n checked\u0026lt;T, E\u0026gt; has no default constructor. Expected has a default constructor if T has a default constructor. checked\u0026lt;T, E\u0026gt; uses the same constructor design as std::variant\u0026lt;...\u0026gt;. Expected uses the constructor design of std::optional\u0026lt;T\u0026gt;. checked\u0026lt;T, E\u0026gt; cannot be modified after construction except by assignment. Expected provides an .emplace() modifier. checked\u0026lt;T, E\u0026gt; permits implicit construction from both T and E when unambiguous. Expected permits implicit construction from T alone. checked\u0026lt;T, E\u0026gt; does not permit T and E to be the same, and becomes annoying to use if they are constructible into one another (implicit construction self-disables). Expected permits T and E to be the same. checked\u0026lt;T, E\u0026gt; throws bad_result_access_with\u0026lt;E\u0026gt; instead of Expected\u0026rsquo;s bad_expected_access\u0026lt;E\u0026gt;. checked\u0026lt;T, E\u0026gt; models std::variant\u0026lt;...\u0026gt;. Expected models std::optional\u0026lt;T\u0026gt;. Thus:  checked\u0026lt;T, E\u0026gt; does not provide operator*() nor operator-\u0026gt; checked\u0026lt;T, E\u0026gt; .error() is wide (i.e. throws on no-value) like .value(). Expected\u0026rsquo;s .error() is narrow (UB on no-error). [checked\u0026lt;T, E\u0026gt; provides .assume_value() and .assume_error() for narrow (UB causing) observers].  checked\u0026lt;T, E\u0026gt; uses success\u0026lt;T\u0026gt; and failure\u0026lt;E\u0026gt; type sugars for disambiguation. Expected uses unexpected\u0026lt;E\u0026gt; only. checked\u0026lt;T, E\u0026gt; does not implement (prone to unintended misoperation) comparison operators which permit implicit conversion e.g. checked\u0026lt;T\u0026gt; == T will fail to compile. Instead write unambiguous code e.g. checked\u0026lt;T\u0026gt; == success(T) or checked\u0026lt;T\u0026gt; == failure(T). checked\u0026lt;T, E\u0026gt; defaults E to std::error_code or boost::system::error_code. Expected does not default E.  In fact, the two are sufficiently close in design that a highly conforming expected\u0026lt;T, E\u0026gt; can be implemented by wrapping up checked\u0026lt;T, E\u0026gt; with the differing functionality:\n/* Here is a fairly conforming implementation of P0323R3 `expected\u0026lt;T, E\u0026gt;` using `checked\u0026lt;T, E\u0026gt;`. It passes the reference test suite for P0323R3 at https://github.com/viboes/std-make/blob/master/test/expected/expected_pass.cpp with modifications only to move the test much closer to the P0323R3 Expected, as the reference test suite is for a much older proposed Expected. Known differences from P0323R3 in this implementation: - `T` and `E` cannot be the same type. - `E` must be default constructible. - No variant storage is implemented (note the Expected proposal does not actually require this). */ namespace detail { template \u0026lt;classT, classE\u0026gt; using expected_result = OUTCOME_V2_NAMESPACE::checked\u0026lt;T, E\u0026gt;; template \u0026lt;classT, classE\u0026gt; struct enable_default_constructor : public expected_result\u0026lt;T, E\u0026gt; { using base = expected_result\u0026lt;T, E\u0026gt;; using base::base; constexpr enable_default_constructor() : base{OUTCOME_V2_NAMESPACE::in_place_type\u0026lt;T\u0026gt;} { } }; template \u0026lt;classT, classE\u0026gt; using select_expected_base = std::conditional_t\u0026lt;std::is_default_constructible\u0026lt;T\u0026gt;::value, enable_default_constructor\u0026lt;T, E\u0026gt;, expected_result\u0026lt;T, E\u0026gt;\u0026gt;; } template \u0026lt;classT, classE\u0026gt; classexpected : public detail::select_expected_base\u0026lt;T, E\u0026gt; { static_assert(!std::is_same\u0026lt;T, E\u0026gt;::value, \u0026#34;T and E cannot be the same in this expected implementation\u0026#34;); using base = detail::select_expected_base\u0026lt;T, E\u0026gt;; public: // Inherit base\u0026#39;s constructors  using base::base; expected() = default; // Expected takes in_place not in_place_type  template \u0026lt;class... Args\u0026gt; constexpr explicit expected(std::in_place_t /*unused*/, Args \u0026amp;\u0026amp;... args) : base{OUTCOME_V2_NAMESPACE::in_place_type\u0026lt;T\u0026gt;, std::forward\u0026lt;Args\u0026gt;(args)...} { } // Expected always accepts a T even if ambiguous  OUTCOME_TEMPLATE(classU) OUTCOME_TREQUIRES(OUTCOME_TPRED(std::is_constructible\u0026lt;T, U\u0026gt;::value)) constexpr expected(U \u0026amp;\u0026amp;v) : base{OUTCOME_V2_NAMESPACE::in_place_type\u0026lt;T\u0026gt;, std::forward\u0026lt;U\u0026gt;(v)} { } // Expected has an emplace() modifier  template \u0026lt;class... Args\u0026gt; void emplace(Args \u0026amp;\u0026amp;... args) { *static_cast\u0026lt;base *\u0026gt;(this) = base{OUTCOME_V2_NAMESPACE::in_place_type\u0026lt;T\u0026gt;, std::forward\u0026lt;Args\u0026gt;(args)...}; } // Expected has a narrow operator* and operator-\u0026gt;  constexpr const T \u0026amp;operator*() const \u0026amp; { return base::assume_value(); } constexpr T \u0026amp;operator*() \u0026amp; { return base::assume_value(); } constexpr const T \u0026amp;\u0026amp;operator*() const \u0026amp;\u0026amp; { return base::assume_value(); } constexpr T \u0026amp;\u0026amp;operator*() \u0026amp;\u0026amp; { return base::assume_value(); } constexpr const T *operator-\u0026gt;() const { return \u0026amp;base::assume_value(); } constexpr T *operator-\u0026gt;() { return \u0026amp;base::assume_value(); } // Expected has a narrow error() observer  constexpr const E \u0026amp;error() const \u0026amp; { return base::assume_error(); } constexpr E \u0026amp;error() \u0026amp; { return base::assume_error(); } constexpr const E \u0026amp;\u0026amp;error() const \u0026amp;\u0026amp; { return base::assume_error(); } constexpr E \u0026amp;error() \u0026amp;\u0026amp; { return base::assume_error(); } }; template \u0026lt;classE\u0026gt; classexpected\u0026lt;void, E\u0026gt; : public OUTCOME_V2_NAMESPACE::result\u0026lt;void, E, OUTCOME_V2_NAMESPACE::policy::throw_bad_result_access\u0026lt;E, void\u0026gt;\u0026gt; { using base = OUTCOME_V2_NAMESPACE::result\u0026lt;void, E, OUTCOME_V2_NAMESPACE::policy::throw_bad_result_access\u0026lt;E, void\u0026gt;\u0026gt;; public: // Inherit base constructors  using base::base; // Expected has a narrow operator* and operator-\u0026gt;  constexpr void operator*() const { base::assume_value(); } constexpr void operator-\u0026gt;() const { base::assume_value(); } }; template \u0026lt;classE\u0026gt; using unexpected = OUTCOME_V2_NAMESPACE::failure_type\u0026lt;E\u0026gt;; template \u0026lt;classE\u0026gt; unexpected\u0026lt;E\u0026gt; make_unexpected(E \u0026amp;\u0026amp;arg) { return OUTCOME_V2_NAMESPACE::failure\u0026lt;E\u0026gt;(std::forward\u0026lt;E\u0026gt;(arg)); } template \u0026lt;classE, class... Args\u0026gt; unexpected\u0026lt;E\u0026gt; make_unexpected(Args \u0026amp;\u0026amp;... args) { return OUTCOME_V2_NAMESPACE::failure\u0026lt;E\u0026gt;(std::forward\u0026lt;Args\u0026gt;(args)...); } template \u0026lt;classE\u0026gt; using bad_expected_access = OUTCOME_V2_NAMESPACE::bad_result_access_with\u0026lt;E\u0026gt;; View this code on Github Why doesn\u0026rsquo;t Outcome duplicate std::expected\u0026lt;T, E\u0026gt;\u0026rsquo;s design? There are a number of reasons:\n Outcome is not aimed at the same audience as Expected. We target developers and users who would be happy to use Boost. Expected targets the standard library user.\n Outcome believes that the monadic use case isn\u0026rsquo;t as important as Expected does. Specifically, we think that 99% of use of Expected in the real world will be to return failure from functions, and not as some sort of enhanced or \u0026ldquo;rich\u0026rdquo; Optional. Outcome therefore models a subset of Variant, whereas Expected models an extended Optional.\n Outcome believes that if you are thinking about using something like Outcome, then for you writing failure code will be in the same proportion as writing success code, and thus in Outcome writing for failure is exactly the same as writing for success. Expected assumes that success will be more common than failure, and makes you type more when writing for failure.\n Outcome goes to considerable effort to help the end user type fewer characters during use. This results in tighter, less verbose, more succinct code. The cost of this is a steeper learning curve and more complex mental model than when programming with Expected.\n Outcome has facilities to make easier interoperation between multiple third party libraries each using incommensurate Outcome (or Expected) configurations. Expected does not do any of this, but subsequent WG21 papers do propose various interoperation mechanisms, one of which Outcome implements so code using Expected will seamlessly interoperate with code using Outcome.\n Outcome was designed with the benefit of hindsight after Optional and Expected, where how those do implicit conversions have been found to be prone to writing unintentionally buggy code. Outcome simultaneously permits more implicit conversions for ease of use and convenience, where those are unambigiously safe, and prevents other implicit conversions which the Boost peer review reported as dangerous.\n  Is Outcome riddled with undefined behaviour for const, const-containing and reference-containing types? The short answer is not any more in C++ 20 and after, thanks to changes made to C++ 20 at the Belfast WG21 meeting in November 2019.\nThe longer answer is that before C++ 20, use of placement new on types containing const member types where the resulting pointer was thrown away is undefined behaviour. As of the resolution of a national body comment, this is no longer the case, and now Outcome is free of this particular UB for C++ 20 onwards.\nThis still affects C++ before 20, though no major compiler is affected. Still, if you wish to avoid UB, don\u0026rsquo;t use const types within Outcome types (or any optional\u0026lt;T\u0026gt;, or vector\u0026lt;T\u0026gt; or any STL container type for that matter).\nMore detail Before the C++ 14 standard, placement new into storage which used to contain a const type was straight out always undefined behaviour, period. Thus all use of placement new within a result\u0026lt;const_containing_type\u0026gt;, or indeed an optional\u0026lt;const_containing_type\u0026gt;, is always undefined behaviour before C++ 14. From [basic.life] for the C++ 11 standard:\n Creating a new object at the storage location that a const object with static, thread, or automatic storage duration occupies or, at the storage location that such a const object used to occupy before its lifetime ended results in undefined behavior.\n This being excessively restrictive, from C++ 14 onwards, [basic_life] now states:\n If, after the lifetime of an object has ended and before the storage which the object occupied is reused or released, a new object is created at the storage location which the original object occupied, a pointer that pointed to the original object, a reference that referred to the original object, or the name of the original object will automatically refer to the new object and, once the lifetime of the new object has started, can be used to manipulate the new object, if:\n‚Äî the storage for the new object exactly overlays the storage location which the original object occupied, and\n‚Äî the new object is of the same type as the original object (ignoring the top-level cv-qualifiers), and\n‚Äî the type of the original object is not const-qualified, and, if a class type, does not contain any non-static data member whose type is const-qualified or a reference type, and\n‚Äî neither the original object nor the new object is a potentially-overlapping subobject\n Leaving aside my personal objections to giving placement new of non-const non-reference types magical pointer renaming powers, the upshot is that if you want defined behaviour for placement new of types containing const types or references, you must store the pointer returned by placement new, and use that pointer for all further reference to the newly created object. This obviously adds eight bytes of storage to a result\u0026lt;const_containing_type\u0026gt;, which is highly undesirable given all the care and attention paid to keeping it small. The alternative is to use  std::launder , which was added in C++ 17, to \u0026lsquo;launder\u0026rsquo; the storage into which we placement new before each and every use of that storage. This forces the compiler to reload the object stored by placement new on every occasion, and not assume it can be constant propagated, which impacts codegen quality.\nAs mentioned above, this issue (in so far as it applies to types containing user supplied T which might be const) has been resolved as of C++ 20 onwards, and it is extremely unlikely that any C++ compiler will act on any UB here in C++ 17 or 14 given how much of STL containers would break.\n"
},
{
	"uri": "https://ned14.github.io/outcome/tutorial/advanced/hooks/hook_result/",
	"title": "Hook result",
	"tags": [],
	"description": "",
	"content": "We now tell Outcome that for every instance of our localised result\u0026lt;T\u0026gt;, that on failure construction only, we want custom code to be run which increments the current slot in TLS storage and writes the current stack backtrace into it.\nFor Outcome before v2.2, we must do this by inserting a specially named free function into a namespace searched by ADL:\nnamespace error_code_extended { // Specialise the result construction hook for our localised result  // We hook any non-copy, non-move, non-inplace construction, capturing a stack backtrace  // if the result is errored.  template \u0026lt;classT, classU\u0026gt; inline void hook_result_construction(result\u0026lt;T\u0026gt; *res, U \u0026amp;\u0026amp; /*unused*/) noexcept { if(res-\u0026gt;has_error()) { // Grab the next extended info slot in the TLS  extended_error_info \u0026amp;eei = mythreadlocaldata().next(); // Write the index just grabbed into the spare uint16_t  OUTCOME_V2_NAMESPACE::hooks::set_spare_storage(res, mythreadlocaldata().current - 1); // Capture a backtrace into my claimed extended info slot in the TLS  eei.items = ::backtrace(eei.backtrace.data(), eei.backtrace.size()); } } } View this code on Github For Outcome v2.2 and later, we must do this by using a custom no value policy which contains a function named on_result_construction(). The function implementation is identical between both mechanisms, just the name and placement of the function declaration differs.\nThe only non-obvious part above is the call to void set_spare_storage(basic_result|basic_outcome *, uint16_t) noexcept .\nBoth result and outcome keep their internal state metadata in a uint32_t, half of which is not used by Outcome. As it can be very useful to keep a small unique number attached to any particular result or outcome instance, we permit user code to set those sixteen bits to anything they feel like. The corresponding function to retrieve those sixteen bits is uint16_t spare_storage(const basic_result|basic_outcome *) noexcept .\nThe state of the sixteen bits of spare storage are ignored during comparison operations.\nThe sixteen bits of spare storage propagate during the following operations:\n Copy and move construction between result\u0026rsquo;s. Copy and move construction between outcome\u0026rsquo;s. Copy and move construction from a result to an outcome. Converting copy and move constructions for all the above. Assignment for all of the above.  They are NOT propagated in these operations:\n Any conversion or translation which goes through a failure_type or success_type. Any conversion or translation which goes through a ValueOrError concept match. Any unpacking or repacking of value/error/exception e.g. a manual repack of an outcome into a result.  "
},
{
	"uri": "https://ned14.github.io/outcome/reference/functions/hooks/",
	"title": "Hooks",
	"tags": [],
	"description": "Functions used to hook into the functionality of `basic_result` and `basic_outcome`.",
	"content": " uint16_t spare_storage(const basic_result|basic_outcome *) noexcept Returns the sixteen bits of spare storage in the specified result or outcome.\n void hook_outcome_construction(T *, U \u0026amp;\u0026amp;) noexcept (Until v2.2.0) ADL discovered free function hook invoked by the implicit constructors of basic_outcome.\n void hook_outcome_construction(T *, U \u0026amp;\u0026amp;, V \u0026amp;\u0026amp;) noexcept (Until v2.2.0) ADL discovered free function hook invoked by the implicit constructors of basic_outcome.\n void hook_outcome_copy_construction(T *, U \u0026amp;\u0026amp;) noexcept (Until v2.2.0) ADL discovered free function hook invoked by the converting copy constructors of basic_outcome.\n void hook_outcome_copy_construction(T *, U \u0026amp;\u0026amp;, V \u0026amp;\u0026amp;) noexcept (Until v2.2.0) ADL discovered free function hook invoked by the converting copy constructors of basic_outcome.\n void hook_outcome_in_place_construction(T *, in_place_type_t\u0026lt;U\u0026gt;, Args \u0026amp;\u0026amp;...) noexcept (Until v2.2.0) ADL discovered free function hook invoked by the in-place constructors of basic_outcome.\n void hook_outcome_move_construction(T *, U \u0026amp;\u0026amp;) noexcept (Until v2.2.0) ADL discovered free function hook invoked by the converting move constructors of basic_outcome.\n void hook_outcome_move_construction(T *, U \u0026amp;\u0026amp;, V \u0026amp;\u0026amp;) noexcept (Until v2.2.0) ADL discovered free function hook invoked by the converting move constructors of basic_outcome.\n void hook_result_construction(T *, U \u0026amp;\u0026amp;) noexcept (Until v2.2.0) ADL discovered free function hook invoked by the implicit constructors of basic_result.\n void hook_result_copy_construction(T *, U \u0026amp;\u0026amp;) noexcept (Until v2.2.0) ADL discovered free function hook invoked by the converting copy constructors of basic_result.\n void hook_result_in_place_construction(T *, in_place_type_t\u0026lt;U\u0026gt;, Args \u0026amp;\u0026amp;...) noexcept (Until v2.2.0) ADL discovered free function hook invoked by the in-place constructors of basic_result.\n void hook_result_move_construction(T *, U \u0026amp;\u0026amp;) noexcept (Until v2.2.0) ADL discovered free function hook invoked by the converting move constructors of basic_result.\n void override_outcome_exception(basic_outcome\u0026lt;T, EC, EP, NoValuePolicy\u0026gt; *, U \u0026amp;\u0026amp;) noexcept Overrides the exception to something other than what was constructed.\n void set_spare_storage(basic_result|basic_outcome *, uint16_t) noexcept Sets the sixteen bits of spare storage in the specified result or outcome.\n "
},
{
	"uri": "https://ned14.github.io/outcome/tutorial/essential/outcome/inspecting/",
	"title": "Inspecting outcome&lt;T, EC, EP&gt;",
	"tags": ["outcome", "value", "error", "exception"],
	"description": "",
	"content": "Continuing with the previous example, in Layer3 we have function z which again reports failures via exceptions. It will call function h from Layer2_old which returns outcome\u0026lt;int\u0026gt; (which may store an int or a std::error_code or a std::exception_ptr). The goal is to unpack it to either the successful return value int or to throw an appropriate exception: if we are storing an std::exception_ptr, just rethrow it. If we are storing a std::error_code throw it as std::system_error, which is designed to store std::error_code\u0026rsquo;s:\nauto z() -\u0026gt; int // throws on failure { if (outcome::outcome\u0026lt;int\u0026gt; o = old::h()) return o.value(); else if (o.has_exception()) std::rethrow_exception(o.exception()); else throw std::system_error{o.error()}; } View this code on Github Function has_exception() checks if it is EP (std::exception_ptr) that is stored, function exception() accesses it. Similarly, function error() accesses the EC (std::error_code) if it is stored. outcome\u0026lt;\u0026gt; also has a function has_failure() to check if either EC or EP is being stored.\nIt would seem obvious that the above pattern of \u0026lsquo;unpacking\u0026rsquo; outcome\u0026lt;\u0026gt; is so common that it ought to be implemented inside function .value(), so function z could be written as:\nreturn old::h().value();  And this is exactly what the aforementioned no-value policy template argument is for, which is described in the next section.\n"
},
{
	"uri": "https://ned14.github.io/outcome/tutorial/advanced/interop/app-map-httplib1/",
	"title": "Mapping the HTTP library into the Application `1/2`",
	"tags": [],
	"description": "",
	"content": "Firstly, remember that we are the application writer who has the problem of integrating three third party libraries into our application\u0026rsquo;s Outcome-based failure handling mechanism. We cannot modify those third party library sources; we must be non-intrusive.\nWe start by dealing with the HTTP library. We will integrate this into our application by wrapping up httplib::failure into a custom STL exception type. We then type erase it into an exception_ptr instance. Please note that this code is exclusively defined in the app namespace:\nnamespace app { // Specialise an exception type for httplib errors  struct httplib_error : std::runtime_error { // passthrough  using std::runtime_error::runtime_error; httplib_error(httplib::failure _failure, std::string msg) : std::runtime_error(std::move(msg)) , failure(std::move(_failure)) { } // the original failure  httplib::failure failure; }; // Type erase httplib::result\u0026lt;U\u0026gt; into a httplib_error exception ptr  template \u0026lt;classU\u0026gt; //  inline std::exception_ptr make_httplib_exception(const httplib::result\u0026lt;U\u0026gt; \u0026amp;src) { std::string str(\u0026#34;httplib failed with error \u0026#34;); switch(src.error().status) { case httplib::status_code::success: str.append(\u0026#34;success\u0026#34;); break; case httplib::status_code::bad_request: str.append(\u0026#34;bad request\u0026#34;); break; case httplib::status_code::access_denied: str.append(\u0026#34;access denied\u0026#34;); break; case httplib::status_code::logon_failed: str.append(\u0026#34;logon failed\u0026#34;); break; case httplib::status_code::forbidden: str.append(\u0026#34;forbidden\u0026#34;); break; case httplib::status_code::not_found: str.append(\u0026#34;not found\u0026#34;); break; case httplib::status_code::internal_error: str.append(\u0026#34;internal error\u0026#34;); break; } str.append(\u0026#34; [url was \u0026#34;); str.append(src.error().url); str.append(\u0026#34;]\u0026#34;); return std::make_exception_ptr(httplib_error(src.error(), std::move(str))); } } // namespace app View this code on Github Most of the complexity in this code fragment is driven by the need to create some sort of descriptive string for std::runtime_error so its .what() returns a useful summary of the original failure. This is the main purpose of the app::make_httplib_exception() function.\n(Note that if you have Reflection in your C++ compiler, it may be possible to script the conversion of enum values to string representations)\nThe only real thing to note about app::httplib_error is that it squirrels away the original httplib::failure in case that is ever needed.\n"
},
{
	"uri": "https://ned14.github.io/outcome/tutorial/advanced/constructors/static-constructor/",
	"title": "Phase 2 construction",
	"tags": [],
	"description": "",
	"content": "Its phase 2 constructor:\n// Phase 2 static member constructor function, which cannot throw inline outcome::result\u0026lt;file_handle\u0026gt; file_handle::file(file_handle::path_type path, file_handle::mode mode) noexcept { // Perform phase 1 of object construction  file_handle ret; // Perform phase 2 of object construction  int flags = 0; switch(mode) { case mode::attr_read: case mode::read: flags = O_RDONLY; break; case mode::attr_write: case mode::write: flags = O_RDWR; break; case mode::append: flags = O_APPEND; break; default: return std::errc::invalid_argument; } ret._fd = ::open(path.u8string().c_str(), flags); if(-1 == ret._fd) { // Note that if we bail out here, ~file_handle() will correctly not call ::close()  return {errno, std::system_category()}; } if(-1 == ::fstat(ret._fd, \u0026amp;ret._stat)) { // Note that if we bail out here, ~file_handle() will correctly call ::close()  return {errno, std::system_category()}; } // Returning ret directly is an area full of compiler specific behaviour quirks,  // so be explicit by wrapping into an initialiser list with embedded move.  return {std::move(ret)}; } View this code on Github The static member function implementing phase 2 firstly calls phase 1 which puts the object into a legally destructible state. We then proceed to implement phase 2 of construction, filling in the various parts as we go, reporting via result any failures.\nRemember that operator new has a non-throwing form, new(std::nothrow).\n For the final return, in theory we could just return ret and depending on the C++ version currently in force, it might work via move, or via copy, or it might refuse to compile. You can of course type lots of boilerplate to be explicit, but this use via initialiser list is a reasonable balance of explicitness versus brevity, and it should generate minimum overhead code irrespective of compiler, C++ version, or any other factor.\n"
},
{
	"uri": "https://ned14.github.io/outcome/tutorial/essential/coroutines/returning/",
	"title": "Returning Outcome types from Coroutines",
	"tags": ["coroutines"],
	"description": "",
	"content": "eager\u0026lt;T, Executor = void\u0026gt; and lazy\u0026lt;T, Executor = void\u0026gt; and their atomic editions are completely standard awaitables with no special behaviours, except if T is a basic_result or basic_outcome. In that situation, the following occurs:\nIf the Coroutine throws a C++ exception which was not handled inside the Coroutine body, Outcome\u0026rsquo;s awaitable types try to convert it into a form which your Result or Outcome type being returned can transport. For example:\n If your Coroutine were returning a result\u0026lt;T, std::exception_ptr\u0026gt;, an errored Result with a pointer to the exception thrown would be returned.\n If your Coroutine were returning a result\u0026lt;T, std::error_code\u0026gt;, the exception ptr is passed to error_from_exception( ) to see if it can be matched to an equivalent std::error_code. If it can, an errored Result with the equivalent error code would be returned.\n If your Coroutine were returning an outcome\u0026lt;T, std::error_code, std::exception_ptr\u0026gt;, an Errored Outcome is chosen preferentially to an Excepted Outcome.\n If your Coroutine were returning an experimental::status_result\u0026lt;T, system_code\u0026gt;, because Experimental SG14 system_code can transport error codes or exception ptrs (or indeed std::error_code\u0026rsquo;s), an errored Result is returned.\n  "
},
{
	"uri": "https://ned14.github.io/outcome/tutorial/essential/result/try/",
	"title": "TRY operations",
	"tags": ["try"],
	"description": "",
	"content": " In the implementation of function print_half we have seen the usage of the macro OUTCOME_TRYV(expr)/OUTCOME_TRY(expr) :\nOUTCOME_TRY (auto i, BigInt::fromString(text));  The OUTCOME_TRY macro uses C macro overloading to select between two implementations based on the number of input parameters. If there is exactly one input parameter i.e. without the i, the control statement is roughly equivalent to:\nauto __result = BigInt::fromString(text); if (!__result) return __result.as_failure();  Where __result is a compile time generated unique name. This single argument form is equivalent to OUTCOME_TRYV(expr), incidentally.\nIf there are between two and eight parameters, this control statement is roughly equivalent to:\nauto __result = BigInt::fromString(text); if (!__result) return __result.as_failure(); auto i = __result.value();  So here i as the first C macro parameter is set to the value of any successful result.\nC macro overloads are provided for up to eight arguments. To prevent the confounding of the C preprocessor by commas in template specifications causing more than eight arguments appearing to the C preprocessor, you should consider wrapping the second argument in brackets.\nIf you are within a C++ Coroutine, you ought to use OUTCOME_CO_TRYV(expr)/OUTCOME_CO_TRY(expr) instead.\n Compiler-specific extension: OUTCOME_TRYX This macro makes use of a proprietary extension in GCC and clang, and is not portable. The macro is not made available on unsupported compilers, so you can test for its presence using #ifdef OUTCOME_TRYX.\n GCC and Clang provide an extension to C++ known as statement expressions. These make it possible to use a more convenient macro: OUTCOME_TRYX, which is an expression. With the above macro, the above declaration of variable i can be rewritten to:\nint i = OUTCOME_TRYX (BigInt::fromString(text));  This has an advantage that you can use it any place where you can put an expression, e.g., in \u0026ldquo;simple initialization\u0026rdquo;:\nif (int i = OUTCOME_TRYX(BigInt::fromString(text))) use_a_non_zero_int(i);  or in as a subexpression of a bigger full expression:\nint ans = OUTCOME_TRYX(BigInt::fromString(\u0026#34;1\u0026#34;)) + OUTCOME_TRYX(BigInt::fromString(\u0026#34;2\u0026#34;));  There is also an OUTCOME_CO_TRYX(expr) if you are inside a C++ Coroutine.\n"
},
{
	"uri": "https://ned14.github.io/outcome/experimental/worked-example-long/constructor/",
	"title": "The constructor",
	"tags": [],
	"description": "",
	"content": "Code domains are 100% constexpr to construct and destruct, as are status codes. This enables the compiler to 100% instantiate both only in its mind, and to emit zero code and thus zero overhead.\nUnfortunately it also means that it must be possible for each domain to be instantiated an infinite number of times, and being 100% in constexpr, any instances never have a unique address in memory either. Thus we cannot compare domains for equivalence using their address in memory, as  std::error_category does.\nWe solve this by using a very random 64 bit number taken from a hard random number source. The website https://www.random.org/cgi-bin/randbyte?nbytes=8\u0026amp;format=h is strongly suggested as the source for this number.\n(In case you are wondering about the chance of collision for a 64 bit integer, SG14 estimated that approximately 190,000 separate domains would need to exist in a single process for there to be a 0.00000001% probability of collision if the random number source is very random)\n// unique id must be from a hard random number source  // Use https://www.random.org/cgi-bin/randbyte?nbytes=8\u0026amp;format=h to get a hard random 64 bit id.  // Do NOT make up your own value. Do NOT use zero.  constexpr explicit _file_io_error_domain(typename _base::unique_id_type id = 0x230f170194fcc6c7) noexcept : _base(id) {} static inline constexpr const _file_io_error_domain \u0026amp;get(); View this code on Github A nice side effect of this approach is that custom error domains in header-only libraries are safe, unlike custom \u0026lt;system_error\u0026gt; error categories. Boost.System\u0026rsquo;s error categories can now opt into this same safe mechanism in order to also be safe in header only library use cases.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/traits/",
	"title": "Traits",
	"tags": [],
	"description": "",
	"content": " is_basic_outcome\u0026lt;T\u0026gt; An integral constant type true for basic_outcome\u0026lt;T, EC, EP, NoValuePolicy\u0026gt; types.\n is_basic_result\u0026lt;T\u0026gt; An integral constant type true for basic_result\u0026lt;T, E, NoValuePolicy\u0026gt; types.\n is_error_code_available\u0026lt;T\u0026gt; True if an error code can be constructed from a T.\n is_error_type\u0026lt;E\u0026gt; A customisable integral constant type true for E types which are to receive error throwing no-value policies.\n is_error_type_enum\u0026lt;E, Enum\u0026gt; A customisable integral constant type true for E types constructible from Enum types which are to receive error throwing no-value policies.\n is_exception_ptr_available\u0026lt;T\u0026gt; True if an exception ptr can be constructed from a T.\n is_failure_type\u0026lt;T\u0026gt; An integral constant boolean variable true for failure_type\u0026lt;EC, E = void\u0026gt; types.\n is_move_bitcopying\u0026lt;T\u0026gt; (\u0026gt;= Outcome v2.2.0) A customisable integral constant type true for T types which are move bitcopying safe.\n is_success_type\u0026lt;T\u0026gt; An integral constant boolean variable true for success_type\u0026lt;T\u0026gt; types.\n type_can_be_used_in_basic_result\u0026lt;R\u0026gt; A constexpr boolean true for types permissible in basic_result\u0026lt;T, E, NoValuePolicy\u0026gt;.\n "
},
{
	"uri": "https://ned14.github.io/outcome/experimental/c-api/from-c/use/",
	"title": "Using a Result",
	"tags": [],
	"description": "Using a C Result",
	"content": "This models the earlier C++ example of use, and its C equivalent isn\u0026rsquo;t much more verbose thanks to our helper typedefs and macros:\nresult positive_only(int x) { if(x \u0026lt; 0) { return FAILURE(c_enum_bad_argument); } return SUCCESS(x); } bool test(int x) { result r = positive_only(x); if(CXX_RESULT_HAS_ERROR(r)) { if(outcome_status_code_equal_generic(\u0026amp;r.error, EINVAL)) { fprintf(stderr, \u0026#34;Positive numbers only!\\n\u0026#34;); return false; } } return true; } View this code on Github For this to link, the CXX_DECLARE_RESULT_SYSTEM_FROM_ENUM macro needs to be compiled at least once within C++ within the final binary to emit the extern functions needed by C.\n"
},
{
	"uri": "https://ned14.github.io/outcome/alternatives/expected/",
	"title": "std expected",
	"tags": [],
	"description": "Advantages and disadvantages of `std::expected&lt;T, E&gt;`",
	"content": " std::expected\u0026lt;T, E\u0026gt; came originally from an experimental monadic and generic programming library outside of Boost written by Boost and WG21 developers around 2013. Before Outcome v1, I deployed the then Expected into a large codebase and I was dismayed with the results, especially on build times. You can read here how those experiences led me to develop Outcome v1.\nstd::expected\u0026lt;T, E\u0026gt; is a constrained variant type with a strong preference for the successful type T which it models like a std::optional\u0026lt;T\u0026gt;. If, however, there is no T value then it supplies an \u0026lsquo;unexpected\u0026rsquo; E value instead. std::expected\u0026lt;T, E\u0026gt; was standardised in the C++ 23 standard.\nOutcome\u0026rsquo;s Result type can be configured to act just like Expected if you want that, however ultimately Outcome\u0026rsquo;s Result doesn\u0026rsquo;t solve the same problem as Expected, plus Outcome models std::variant\u0026lt;T, E\u0026gt; rather than std::optional\u0026lt;T\u0026gt; which we think much superior for many use cases, which to summarise:\n If you are parsing input which may rarely contain unexpected values, Expected is the right choice here.\n If you want an alternative to C++ exception handling i.e. a generalised whole-program error handling framework, Expected is an inferior choice to alternatives.\n  Outcome recognises Expected-like types and will construct from them, which aids interoperability.\nPros:  Predictable runtime overhead on the happy path.\n Predictable runtime overhead on the sad path.\n Very little codegen bloat added to binaries (though there is a fixed absolute overhead for support libraries).\n Variant storage means storage overhead is minimal, except when either T or E has a throwing move constructor which typically causes storage blowup.\n Works well in all configurations of C++, including C++ exceptions and RTTI globally disabled.\n Works well on all niche architectures, such as HPC, GPUs, DSPs and microcontrollers.\n Ships with every standard library since C++ 23.\n  Cons:  Success-orientated syntax makes doing anything with the E type is awkward and clunky.\n Results in branchy code, which is slow \u0026ndash; though predictably so \u0026ndash; for embedded controller CPUs.\n Failure to examine an Expected generates a compiler diagnostic, but failure to handle both failure and success does not. This can mean failures or successes get accidentally dropped.\n Lack of a try operator makes use tedious and verbose.\n Variant storage does have an outsize impact on build times in the same way widespread use of std::variant has. This is because implementing exception guarantees during copies and moves of non-trivially-copyable types in union storage involves a lot of work for the compiler on every use of copy and move.\n  "
},
{
	"uri": "https://ned14.github.io/outcome/changelog/v22/",
	"title": "v2.2 major changes",
	"tags": [],
	"description": "",
	"content": "Major changes in v2.2 over v2.1 are listed here.\n A new trait is_move_bitcopying\u0026lt;T\u0026gt; is added, which opts types into a library-based emulation of P1029 move = bitcopies. Experimental std::error is opted in by default. If this trait is true for your T or E type, Outcome will track moved-from status for your type, and will only call your type\u0026rsquo;s destructor if it was not moved from. If your compiler\u0026rsquo;s optimiser is sufficiently able to fold code, this improves codegen quality for Experimental Outcome very considerably, approaching the same gains as P1029 types would have. Note that the empirical performance difference will likely be nil, but the codegen does look much more elegant.\n If for basic_result\u0026lt;T, E\u0026gt; both T and E are trivially copyable, union-based rather than struct-based storage will be used. This significantly improves performance in synthetic benchmarks which do nothing in deep call stacks of function calls except create and return result\u0026lt;T, E\u0026gt;, and makes Outcome return competitive results to alternative error handling choices, improving comparative optics. It is not expected that the performance difference will be detectable empirically in real world code. It is expected that the build time impact of union storage won\u0026rsquo;t be noticeable, as union storage for trivially copyable types is much easier than for non-TC types.\nNote that storage remains struct-based if either T or E is neither trivially copyable nor for which trait is_move_bitcopying\u0026lt;T\u0026gt; is true. This is because union-based storage for complex types has significant build time impact, as anyone who has deployed std::variant or std::expected into globally visible public APIs will have noticed.\n The compile time requirement for E types to have a default constructor is removed.\n OUTCOME_TRY(var, expr) no longer always declares var as auto \u0026amp;\u0026amp;var, but simply uses it as is. This allows TRY to initialise or assign. You can use the macro OUTCOME21_TRY if you want the pre-Outcome v2.2 behaviour. You may find the regular expression _TRY\\(([^(]*?),(.*?)\\); =\u0026gt; _TRY(auto \u0026amp;\u0026amp;\\1,\\2); of use to you when upgrading code.\n OUTCOME_TRY now declares its internal uniquely named temporary variable which holds the result of the expression as auto unique = expr instead of auto \u0026amp;\u0026amp;unique = expr. This will cause TRY of result\u0026lt;UncopyableAndImmovable\u0026gt; and outcome\u0026lt;UncopyableAndImmovable\u0026gt; to fail to compile, whereas previously they did compile. Another big change in semantic is that TRY now will \u0026lsquo;consume\u0026rsquo; values moved into it, whereas previously it did not/ The reason for this change was that the previous behaviour produced undefined behaviour in various corner use cases, particulary in generic code. You can tell TRY to use references instead of values for its uniquely named temporary using a special syntax.\n OUTCOME_TRY now propagates the value from spare_storage(const basic_result|basic_outcome *) noexcept of the input Result/Outcome into any failure_type\u0026lt;T\u0026gt; returned by TRY. Result/Outcome now sets its spare storage value from any success_type\u0026lt;T\u0026gt; or failure_type\u0026lt;T\u0026gt; from which it is constructed. This is a breaking change, as spare storage values were not propagated beforehand. However this change means that any stack backtrace identifier captured by a failed result construction hook is now fully propagated from failure point up through all TRY operations to the code which handles the failure.\n The ADL discovered event hooks have been replaced with policy-specified event hooks instead. This is due to brittleness (where hooks would quietly self-disable if somebody changed something), compiler bugs (a difference in compiler settings causes the wrong hooks, or some but not all hooks, to get discovered), and end user difficulty in using them at all. The policy-specified event hooks can be told to default to ADL discovered hooks for backwards compatibility: set OUTCOME_ENABLE_LEGACY_SUPPORT_FOR to less than 220 to enable emulation.\n  "
},
{
	"uri": "https://ned14.github.io/outcome/reference/functions/iostream/",
	"title": "Iostream",
	"tags": [],
	"description": "Functions used to print, serialise and deserialise `basic_result` and `basic_outcome`.",
	"content": " std::istream \u0026amp;operator\u0026gt;\u0026gt;(std::istream \u0026amp;, basic_outcome\u0026lt;T, EC, EP, NoValuePolicy\u0026gt; \u0026amp;) Deserialises a basic_outcome from a std::istream.\n std::istream \u0026amp;operator\u0026gt;\u0026gt;(std::istream \u0026amp;, basic_result\u0026lt;T, E, NoValuePolicy\u0026gt; \u0026amp;) Deserialises a basic_result from a std::istream.\n std::ostream \u0026amp;operator\u0026lt;\u0026lt;(std::ostream \u0026amp;, const basic_outcome\u0026lt;T, EC, EP, NoValuePolicy\u0026gt; \u0026amp;) Serialises a basic_outcome to a std::ostream.\n std::ostream \u0026amp;operator\u0026lt;\u0026lt;(std::ostream \u0026amp;, const basic_result\u0026lt;T, E, NoValuePolicy\u0026gt; \u0026amp;) Serialises a basic_result to a std::ostream.\n std::string print(const basic_outcome\u0026lt;T, EC, EP, NoValuePolicy\u0026gt; \u0026amp;) Returns a string containing a human readable rendition of the basic_outcome.\n std::string print(const basic_result\u0026lt;T, E, NoValuePolicy\u0026gt; \u0026amp;) Returns a string containing a human readable rendition of the basic_result.\n "
},
{
	"uri": "https://ned14.github.io/outcome/tutorial/advanced/interop/app-map-httplib2/",
	"title": "Mapping the HTTP library into the Application `2/2`",
	"tags": [],
	"description": "",
	"content": "If you remember the tutorial section on the value_or_error Concept, this is an example of how to implement a custom value_or_error Concept converter in Outcome:\n// Inject custom ValueOrError conversion OUTCOME_V2_NAMESPACE_BEGIN namespace convert { // Provide custom ValueOrError conversion from  // httplib::result\u0026lt;U\u0026gt; into any app::outcome\u0026lt;T\u0026gt;  template \u0026lt;classT, classU\u0026gt; //  struct value_or_error\u0026lt;app::outcome\u0026lt;T\u0026gt;, httplib::result\u0026lt;U\u0026gt;\u0026gt; { // False to indicate that this converter wants `result`/`outcome`  // to NOT reject all other `result`  static constexpr bool enable_result_inputs = true; // False to indicate that this converter wants `outcome` to NOT  // reject all other `outcome`  static constexpr bool enable_outcome_inputs = true; template \u0026lt;classX, //  typename = std::enable_if_t\u0026lt;std::is_same\u0026lt;httplib::result\u0026lt;U\u0026gt;, std::decay_t\u0026lt;X\u0026gt;\u0026gt;::value //  \u0026amp;\u0026amp; std::is_constructible\u0026lt;T, U\u0026gt;::value\u0026gt;\u0026gt; //  constexpr app::outcome\u0026lt;T\u0026gt; operator()(X \u0026amp;\u0026amp;src) { // Forward any successful value, else synthesise an exception ptr  return src.has_value() ? //  app::outcome\u0026lt;T\u0026gt;{std::forward\u0026lt;X\u0026gt;(src).value()} //  : app::outcome\u0026lt;T\u0026gt;{app::make_httplib_exception(std::forward\u0026lt;X\u0026gt;(src))}; } }; } // namespace convert OUTCOME_V2_NAMESPACE_END View this code on Github The first thing that you should note is that these custom converters must be injected directly into the OUTCOME_V2_NAMESPACE::convert namespace, and they must partially or completely specialise value_or_error\u0026lt;T, U\u0026gt; . Here we specialise the converter for value_or_error conversions from httplib::result\u0026lt;U\u0026gt; to app::outcome\u0026lt;T\u0026gt; i.e. from our third party HTTP library\u0026rsquo;s error type into our application\u0026rsquo;s outcome type (which is unique to our application, as we hard code an app-local error type).\nThe second thing to note is that you need to set enable_result_inputs and enable_outcome_inputs appropriately, otherwise result and outcome inputs will not be matched by this converter1. In this converter, we really do wish to convert other result and outcome inputs, so we mark these booleans as true.\nThe third thing to note is the requirements on operator(). If the requirements are not met, the value_or_error converting constructor in basic_result and basic_outcome disables. Note the requirement that the decayed operator() input X matches httplib::result\u0026lt;U\u0026gt;, and that T is constructible from U. This means that the explicit basic_result(concepts::value_or_error\u0026lt;T, E\u0026gt; \u0026amp;\u0026amp;) and explicit basic_outcome(concepts::value_or_error\u0026lt;T, E\u0026gt; \u0026amp;\u0026amp;) constructors are available if, and only if, the input type is a httplib::result\u0026lt;U\u0026gt;, and the result\u0026rsquo;s value type is constructible from the input\u0026rsquo;s value type.\nIf operator() is available, it naturally converts a httplib::result\u0026lt;U\u0026gt; into an app::outcome\u0026lt;T\u0026gt; by either forwarding any success as-is, or calling app::make_httplib_exception() to type erase the httplib::failure into an app::httplib_error.\n Here we refer to result and outcome as defined by this specific Outcome library. If result or outcome from another Outcome implementation is seen, those always must get parsed via the ValueOrError matching conversion framework. [return]   "
},
{
	"uri": "https://ned14.github.io/outcome/tutorial/advanced/hooks/poke_exception/",
	"title": "Custom exception ptr",
	"tags": [],
	"description": "",
	"content": "If you merely want result to capture stack backtraces without calling a memory allocator and retaining any triviality of copy which is important for optimisation, you already have everything you need.\nBut let\u0026rsquo;s keep going by intercepting any construction of our localised outcome from our localised result, retrieving any stored backtrace and using it to synthesise an exception ptr with a message text including the backtrace. Firstly let us look at the function which synthesises the exception ptr:\nnamespace error_code_extended { // Synthesise a custom exception_ptr from the TLS slot and write it into the outcome  template \u0026lt;classR\u0026gt; inline void poke_exception(outcome\u0026lt;R\u0026gt; *o) { if(o-\u0026gt;has_error()) { extended_error_info *eei = mythreadlocaldata().get(OUTCOME_V2_NAMESPACE::hooks::spare_storage(o)); if(eei != nullptr) { // Make a custom string for the exception  std::string str(o-\u0026gt;error().message()); str.append(\u0026#34; [\u0026#34;); struct unsymbols // RAII cleaner for symbols  { char **_{nullptr}; ~unsymbols() { ::free(_); } } symbols{::backtrace_symbols(eei-\u0026gt;backtrace.data(), eei-\u0026gt;items)}; if(symbols._ != nullptr) { for(size_t n = 0; n \u0026lt; eei-\u0026gt;items; n++) { if(n \u0026gt; 0) { str.append(\u0026#34;; \u0026#34;); } str.append(symbols._[n]); } } str.append(\u0026#34;]\u0026#34;); // Override the payload/exception member in the outcome with our synthesised exception ptr  OUTCOME_V2_NAMESPACE::hooks::override_outcome_exception(o, std::make_exception_ptr(std::runtime_error(str))); } } } } View this code on Github If the localised outcome being constructed is errored, try fetching the TLS slot for the unique 16-bit value in its spare storage. If that is valid, symbolise the stack backtrace into a string and make an exception ptr with a runtime error with that string. Finally, override the payload/exception member in our just-copy-constructed localised outcome with the new exception ptr.\n As the reference documentation for void override_outcome_exception(basic_outcome\u0026lt;T, EC, EP, NoValuePolicy\u0026gt; *, U \u0026amp;\u0026amp;) noexcept points out, you almost certainly never want to use this function if there is any other alternative. It is worth explaining what is meant by this.\nIn this section, we always synthesise an exception ptr from the stored state and error code at the exact point of transition from result based APIs to outcome based APIs. This is acceptable only because we know that our code enforces that discipline.\nIf one were designing a library facility, one could not assume such discipline in the library user. One would probably be better off making the exception ptr synthesis lazy via a custom no-value policy which generates the stacktrace-containing error message only on demand e.g. .exception() observation, or a .value() observation where no value is available.\nSuch a design is however more indeterminate than the design presented in this section, because the indeterminacy is less predictable than in this design. Ultimately which strategy you adopt depends on how important absolute determinism is to your Outcome-based application.\n"
},
{
	"uri": "https://ned14.github.io/outcome/tutorial/advanced/interop/app-map-filelib/",
	"title": "Mapping the File I/O library into the Application",
	"tags": [],
	"description": "",
	"content": "To handle the File I/O library, once again we turn to custom ValueOrError converters:\n// Inject custom ValueOrError conversion OUTCOME_V2_NAMESPACE_BEGIN namespace convert { // Provide custom ValueOrError conversion from filelib::result\u0026lt;U\u0026gt;  // into any app::outcome\u0026lt;T\u0026gt;  template \u0026lt;classT, classU\u0026gt; //  struct value_or_error\u0026lt;app::outcome\u0026lt;T\u0026gt;, filelib::result\u0026lt;U\u0026gt;\u0026gt; { // True to indicate that this converter wants `result`/`outcome`  // to NOT reject all other `result`  static constexpr bool enable_result_inputs = true; // False to indicate that this converter wants `outcome` to NOT  // reject all other `outcome`  static constexpr bool enable_outcome_inputs = true; template \u0026lt;classX, //  typename = std::enable_if_t\u0026lt;std::is_same\u0026lt;filelib::result\u0026lt;U\u0026gt;, std::decay_t\u0026lt;X\u0026gt;\u0026gt;::value //  \u0026amp;\u0026amp; std::is_constructible\u0026lt;T, U\u0026gt;::value\u0026gt;\u0026gt; //  constexpr app::outcome\u0026lt;T\u0026gt; operator()(X \u0026amp;\u0026amp;src) { // Forward any successful value  if(src.has_value()) { return {std::forward\u0026lt;X\u0026gt;(src).value()}; } // Synthesise a filesystem_error, exactly as if someone had  // called src.value()  auto \u0026amp;fi = src.error(); OUTCOME_V2_NAMESPACE::try_throw_std_exception_from_error(fi.ec); // might throw  return {std::make_exception_ptr( //  filelib::filesystem_error(fi.ec.message(), std::move(fi.path1), std::move(fi.path2), fi.ec))}; } }; } // namespace convert OUTCOME_V2_NAMESPACE_END View this code on Github Note that the conversion exactly duplicates the implementation of throw_as_system_error_with_payload(failure_info fi) from namespace filelib. In a production implementation, you probably ought to call that function and catch the exception it throws into a pointer, as that would be more long term maintainable.\n"
},
{
	"uri": "https://ned14.github.io/outcome/alternatives/outcome/",
	"title": "Outcome (proposed std result)",
	"tags": [],
	"description": "Advantages and disadvantages of Outcome and its proposed `std::result&lt;T&gt;`",
	"content": " Outcome (the library described by this documentation) originated in a negative reaction to then originally proposed std::expected\u0026lt;T, E\u0026gt;, though what got eventually standardised as std::expected\u0026lt;T, E\u0026gt; looks much more like Outcome\u0026rsquo;s result\u0026lt;T, E\u0026gt; than the original Expected. You can read here how those experiences led me to develop Outcome v1. Outcome comes in both standalone and Boost editions, and its current design was completed in 2018.\nOutcome\u0026rsquo;s core is two workhorse types and a macro:\n basic_result\u0026lt;T, E, NoValuePolicy\u0026gt;  basic_outcome\u0026lt;T, EC, EP, NoValuePolicy\u0026gt;  OUTCOME_TRY(var, expr)   These three core items are then mixed into a veritable cornucopia of convenience typedefs and variations to support a wide range of use cases, including in C++ coroutines, plus there is extensive plumbing and customisation points for deciding how incompatible types ought to interact, or being notified of lifecycle events (e.g. capture a stack backtrace if a result\u0026lt;T, E\u0026gt; is constructed with an error).\nOutcome perfectly propagates constexpr, triviality and noexcept-ness of each individual operation of the types you configure it with. It never touches dynamic memory allocation, and it has been carefully written so the compiler will optimise it out of codegen entirely wherever that is possible. It is capable of \u0026lsquo;true moves\u0026rsquo; for types which declare themselves \u0026lsquo;move bitcopying compatible\u0026rsquo; i.e. destructor calls on moved-from values are elided. \u0026lsquo;True moves\u0026rsquo; can have a game changing performance gain on types with virtual destructors.\nOutcome takes a lot of care to have the least possible impact on build times, and it guarantees that a binary built with it will have stable ABI so it is safe to use in really large C++ codebases (standalone edition only). For interoperation with other languages, it guarantees that C code can work with Outcome data types, and it provides a C macro API header file to help with that.\nOutcome recognises Expected-like types and will construct from them, which aids interoperability. A simplified Result type is proposed for standardisation as std::result\u0026lt;T\u0026gt; where the E type is hard coded to a proposed std::error. This proposed standardisation has been deployed on billions of devices at the time of writing, and you can use it today via Experimental.Outcome, the reference implementation.\nPros:  Predictable runtime overhead on the happy path.\n Predictable runtime overhead on the sad path.\n Very little codegen bloat added to binaries (though there is a fixed absolute overhead for support libraries if you use Outcome\u0026rsquo;s bundled error types).\n Neither success nor failure is prioritised during use \u0026ndash; types will implicitly construct from both T and E if it is unambiguous, so no clunky added markup needed to return an E.\n Sad path control flow is required to be explicitly specified in every situation. This significantly reduces the number of sad control flow paths in a code base, making it much easier to test all of them. It also means that sad paths get audited and checked during code reviews.\n Macro TRY operator feels a bit unnatural to use, but is a god send to saving visual code clutter when all you want to say is \u0026lsquo;handle this failure by asking my caller to handle it\u0026rsquo;. It also works with non-Outcome types, and has its own suite of customisation points for third party extension.\n Works well in all configurations of C++, including C++ exceptions and RTTI globally disabled.\n Works well on all niche architectures, such as HPC, GPUs, DSPs and microcontrollers, and does not dynamically allocate memory.\n  Cons:  Sad path control flow is required to be explicitly specified in every situation. For code where failure is extremely unlikely, or is not important because it always results in aborting the current operation, the added visual code clutter is unhelpful.\n Results in branchy code, which is slow \u0026ndash; though predictably so \u0026ndash; for embedded controller CPUs.\n Failure to examine an Outcome type generates a compiler diagnostic, but failure to handle both failure and success does not. This can mean failures or successes get accidentally dropped.\n To prevent variant storage having an outsize impact on build times in the same way widespread use of std::variant has, Outcome only implements union storage when both T and E are trivially copyable or move bitcopying. Otherwise struct storage is used, which means Outcome\u0026rsquo;s types are larger than Expected\u0026rsquo;s. This is because implementing exception guarantees during copies and moves of non-trivially-copyable types in union storage involves a lot of work for the compiler on every use of copy and move, so by using struct storage Outcome reduces build time impact from copies and moves significantly.\nNote that one of the major uses of Outcome types is as the return type from a function, in which case copy elision would happen in C++ 14 and is guaranteed from C++ 17 onwards. This means that the larger footprint of struct storage typically has much less impact in optimised code than might be the case if you store these types inside other types.\n  "
},
{
	"uri": "https://ned14.github.io/outcome/tutorial/advanced/constructors/metaprogrammg1/",
	"title": "Phase 3",
	"tags": [],
	"description": "",
	"content": "We have built our first two phases of construction for file_handle, and for some users they might be happy writing:\noutcome::result\u0026lt;file_handle\u0026gt; fh1 = file_handle::file(\u0026#34;hello\u0026#34; /*, file_handle::mode::read */); if(!fh1) { std::cerr \u0026lt;\u0026lt; \u0026#34;Opening file \u0026#39;hello\u0026#39; failed with \u0026#34; \u0026lt;\u0026lt; fh1.error().message() \u0026lt;\u0026lt; std::endl; } View this code on Github \u0026hellip; and be done with it.\nBut wouldn\u0026rsquo;t it be nicer if we could instead write:\noutcome::result\u0026lt;file_handle\u0026gt; fh2 = make\u0026lt;file_handle\u0026gt;{\u0026#34;hello\u0026#34; /*, file_handle::mode::read */}(); if(!fh2) { std::cerr \u0026lt;\u0026lt; \u0026#34;Opening file \u0026#39;hello\u0026#39; failed with \u0026#34; \u0026lt;\u0026lt; fh2.error().message() \u0026lt;\u0026lt; std::endl; } View this code on Github The eye is immediately drawn to the two-stage invocation pattern, so we are constructing a type make\u0026lt;file_handle\u0026gt; using the arguments with which we wish to invoke the file_handle constructor with, and then invoking the call operator on that make\u0026lt;file_handle\u0026gt; instance to do the actual construction.\nIt may seem a bit clunky to use brace initialisation for parameters followed by a \u0026ldquo;spurious\u0026rdquo; set of empty brackets, but we think that this is a better approach than alternatives. We shall briefly cover those at the end of this section.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/policies/",
	"title": "Policies",
	"tags": [],
	"description": "",
	"content": " base Base class of most policy classes defining the narrow observer policies.\n static void _ub(Impl \u0026amp;\u0026amp;) Special function which causes noticeable hard undefined behaviour.\n static bool _has_value(Impl \u0026amp;\u0026amp;) noexcept Returns true if a value is present in the implementation passed in. Constexpr, never throws.\n static bool _has_error(Impl \u0026amp;\u0026amp;) noexcept Returns true if an error is present in the implementation passed in. Constexpr, never throws.\n static bool _has_exception(Impl \u0026amp;\u0026amp;) noexcept Returns true if an exception is present in the implementation passed in. Constexpr, never throws.\n static bool _has_error_is_errno(Impl \u0026amp;\u0026amp;) noexcept Returns true if the error code in the implementation passed in has a domain or category matching that of POSIX errno. Constexpr, never throws.\n static auto \u0026amp;\u0026amp;_value(Impl \u0026amp;\u0026amp;) noexcept Returns a reference to the value in the implementation passed in. Constexpr, never throws.\n static auto \u0026amp;\u0026amp;_error(Impl \u0026amp;\u0026amp;) noexcept Returns a reference to the error in the implementation passed in. Constexpr, never throws.\n static auto \u0026amp;\u0026amp;_exception(Impl \u0026amp;\u0026amp;) noexcept Returns a reference to the exception in the implementation passed in. Constexpr, never throws.\n static void _set_has_value(Impl \u0026amp;\u0026amp;, bool) noexcept Sets whether the implementation has a value. Constexpr, never throws.\n static void _set_has_error(Impl \u0026amp;\u0026amp;, bool) noexcept Sets whether the implementation has an error. Constexpr, never throws.\n static void _set_has_exception(Impl \u0026amp;\u0026amp;, bool) noexcept Sets whether the implementation has an exception. Constexpr, never throws.\n static void _set_has_exception(Impl \u0026amp;\u0026amp;, bool) noexcept Sets whether the implementation\u0026rsquo;s error code has a domain or category matching that of POSIX errno. Constexpr, never throws.\n static void narrow_value_check(Impl \u0026amp;\u0026amp;) noexcept Observer policy performing hard UB if no value is present. Constexpr, never throws.\n static void narrow_error_check(Impl \u0026amp;\u0026amp;) noexcept Observer policy performing hard UB if no error is present. Constexpr, never throws.\n static void narrow_exception_check(Impl \u0026amp;\u0026amp;) noexcept Observer policy performing hard UB if no exception is present. Constexpr, never throws.\n static void on_outcome_construction(T *, U \u0026amp;\u0026amp;) noexcept (\u0026gt;= Outcome v2.2.0) Hook invoked by the implicit constructors of basic_outcome.\n static void on_outcome_construction(T *, U \u0026amp;\u0026amp;, V \u0026amp;\u0026amp;) noexcept (\u0026gt;= Outcome v2.2.0) Hook invoked by the implicit constructors of basic_outcome.\n static void on_outcome_copy_construction(T *, U \u0026amp;\u0026amp;) noexcept (\u0026gt;= Outcome v2.2.0) Hook invoked by the converting copy constructors of basic_outcome.\n static void on_outcome_copy_construction(T *, U \u0026amp;\u0026amp;, V \u0026amp;\u0026amp;) noexcept (\u0026gt;= Outcome v2.2.0) Hook invoked by the converting copy constructors of basic_outcome.\n static void on_outcome_in_place_construction(T *, in_place_type_t\u0026lt;U\u0026gt;, Args \u0026amp;\u0026amp;...) noexcept (\u0026gt;= Outcome v2.2.0) Hook invoked by the in-place constructors of basic_outcome.\n static void on_outcome_move_construction(T *, U \u0026amp;\u0026amp;) noexcept (\u0026gt;= Outcome v2.2.0) Hook invoked by the converting move constructors of basic_outcome.\n static void on_outcome_move_construction(T *, U \u0026amp;\u0026amp;, V \u0026amp;\u0026amp;) noexcept (\u0026gt;= Outcome v2.2.0) Hook invoked by the converting move constructors of basic_outcome.\n static void on_result_construction(T *, U \u0026amp;\u0026amp;) noexcept (\u0026gt;= Outcome v2.2.0) Hook invoked by the implicit constructors of basic_result.\n static void on_result_copy_construction(T *, U \u0026amp;\u0026amp;) noexcept (\u0026gt;= Outcome v2.2.0) Hook invoked by the converting copy constructors of basic_result.\n static void on_result_in_place_construction(T *, in_place_type_t\u0026lt;U\u0026gt;, Args \u0026amp;\u0026amp;...) noexcept (\u0026gt;= Outcome v2.2.0) Hook invoked by the in-place constructors of basic_result.\n static void on_result_move_construction(T *, U \u0026amp;\u0026amp;) noexcept (\u0026gt;= Outcome v2.2.0) Hook invoked by the converting move constructors of basic_result.\n all_narrow Policy class defining that hard undefined behaviour should occur on incorrect narrow and wide value, error or exception observation. Inherits publicly from base.\n error_code_throw_as_system_error\u0026lt;T, EC, EP\u0026gt; Policy class defining that EP ought to be rethrown if possible, then the ADL discovered free function outcome_throw_as_system_error_with_payload() should be called on incorrect wide value observation. Inherits publicly from base. Can only be used with basic_outcome.\n error_code_throw_as_system_error\u0026lt;T, EC, void\u0026gt; Policy class defining that the ADL discovered free function outcome_throw_as_system_error_with_payload() should be called on incorrect wide value observation. Inherits publicly from base. Can only be used with basic_result.\n exception_ptr_rethrow\u0026lt;T, EC, EP\u0026gt; Policy class defining that the ADL discovered free function rethrow_exception() should be called on incorrect wide value observation. Inherits publicly from base. Can only be used with basic_outcome.\n exception_ptr_rethrow\u0026lt;T, EC, void\u0026gt; Policy class defining that the ADL discovered free function rethrow_exception() should be called on incorrect wide value observation. Inherits publicly from base. Can only be used with basic_result.\n fail_to_compile_observers Policy class defining that a static assertion should occur upon compilation of the wide value, error or exception observation. Inherits publicly from base.\n terminate Policy class defining that std::terminate() should be called on incorrect wide value, error or exception observation. Inherits publicly from base.\n throw_bad_result_access\u0026lt;EC\u0026gt; Policy class defining that bad_result_access_with\u0026lt;EC\u0026gt; should be thrown on incorrect wide value observation. Inherits publicly from base.\n "
},
{
	"uri": "https://ned14.github.io/outcome/reference/functions/policy/",
	"title": "Policy",
	"tags": [],
	"description": "Functions used to customise how the policy classes operate.",
	"content": " auto basic_outcome_failure_exception_from_error(const EC \u0026amp;) ADL discovered free function synthesising an exception type from an error type, used by the .failure() observers.\n decltype(auto) error_code(T \u0026amp;\u0026amp;) Extracts a boost::system::error_code or std::error_code from the input via ADL discovery of a suitable make_error_code(T) function.\n decltype(auto) exception_ptr(T \u0026amp;\u0026amp;) Extracts a boost::exception_ptr or std::exception_ptr from the input via ADL discovery of a suitable make_exception_ptr(T) function.\n void outcome_throw_as_system_error_with_payload(BoostErrorCodeEnum \u0026amp;\u0026amp;) Specialisation of outcome_throw_as_system_error_with_payload() for input types where boost::system::is_error_code_enum\u0026lt;BoostErrorCodeEnum\u0026gt; or boost::system::is_error_condition_enum\u0026lt;BoostErrorCodeEnum\u0026gt; is true.\n void outcome_throw_as_system_error_with_payload(ErrorCodeEnum \u0026amp;\u0026amp;) Specialisation of outcome_throw_as_system_error_with_payload() for input types where std::is_error_code_enum\u0026lt;ErrorCodeEnum\u0026gt; or std::is_error_condition_enum\u0026lt;ErrorCodeEnum\u0026gt; is true.\n void outcome_throw_as_system_error_with_payload(const boost::system::error_code \u0026amp;) Specialisation of outcome_throw_as_system_error_with_payload() for boost::system::error_code.\n void outcome_throw_as_system_error_with_payload(const std::error_code \u0026amp;) Specialisation of outcome_throw_as_system_error_with_payload() for std::error_code.\n "
},
{
	"uri": "https://ned14.github.io/outcome/experimental/worked-example-long/string_ref/",
	"title": "String refs",
	"tags": [],
	"description": "",
	"content": "\u0026lt;system_error2\u0026gt; does not use std::string to return possibly statically or dynamically allocated strings, and thus avoids dragging in a lot of the standard library which impacts build times.\nInstead status code domains have a string_ref, which has a polymorphic implementation which may or may not manage a dynamic memory allocation using an atomic reference counter. Due to this polymorphism, you don\u0026rsquo;t need to worry which implementation is actually in use under the bonnet when you pass around string_ref instances.\nstring_ref provides the same member functions as a span\u0026lt;const char\u0026gt;, and so participates ordinarily in STL algorithms and containers. In particular, if you need to string search or slice it, you can construct a string_view on top easily.\n// Return the name of our custom code domain  virtual _base::string_ref name() const noexcept override final // NOLINT  { static string_ref v(\u0026#34;file i/o error domain\u0026#34;); return v; // NOLINT  } View this code on Github Now you understand what string_ref does, returning the name of the status code domain is self describing. Note we use the non-managing constructor of string_ref, as the string \u0026quot;file i/o error domain\u0026quot; is statically stored. We cache the returned value locally in static storage.\n"
},
{
	"uri": "https://ned14.github.io/outcome/experimental/c-api/from-c/try/",
	"title": "TRY a C Result",
	"tags": [],
	"description": "Operation TRY on a C Result",
	"content": "Thanks to much of the magic of OUTCOME_TRY(var, expr) being implemented using C preprocessor metaprogramming, we can offer a very similar experience for the C try operation and without needing anything compiled in C++ as support functions:\nresult test2(int x) { CXX_RESULT_SYSTEM_TRY(int v, // what to set to value if successful  fprintf(stderr, \u0026#34;Positive numbers only!\\n\u0026#34;), // what cleanup to run if unsuccessful  positive_only(x)); return SUCCESS(v + 1); } View this code on Github The principle difference is that you can specify a cleanup routine to perform if failure is encountered. This is especially useful in C, which has no stack unwinding.\nAlso due to lack of type sugaring and user defined implicit conversions, if your callers result type isn\u0026rsquo;t your callee\u0026rsquo;s, you may need to specify what your caller\u0026rsquo;s result type is so the error state can be correctly propagated.\n"
},
{
	"uri": "https://ned14.github.io/outcome/tutorial/essential/result/try_greedy/",
	"title": "TRY is greedy",
	"tags": ["try"],
	"description": "",
	"content": "OUTCOME_TRYV(expr)/OUTCOME_TRY(expr) has \u0026lsquo;greedier\u0026rsquo; implicit conversion semantics than basic_result\u0026lt;T, E, NoValuePolicy\u0026gt; . For example, this code won\u0026rsquo;t compile:\noutcome::result\u0026lt;int, std::error_code\u0026gt; test(outcome::result\u0026lt;int, std::errc\u0026gt; r) { return r; // you need to use explicit construction here  // i.e. return outcome::result\u0026lt;int\u0026gt;(r); }  This is chosen because there is a non-trivial conversion between std::errc and std::error_code, so even though that conversion is implicit for std::error_code, Outcome does not expose the implicitness here in order to keep the implicit constructor count low (implicit constructors add significantly to build times).\nThe TRY operation is more greedy though:\noutcome::result\u0026lt;int, std::error_code\u0026gt; test(outcome::result\u0026lt;int, std::errc\u0026gt; r) { OUTCOME_TRY(r); // no explicit conversion needed  return r.value(); }  This is because result\u0026lt;int, std::error_code\u0026gt; will implicitly construct from anything which either int or std::error_code will implicitly construct from. However, result\u0026lt;int, std::error_code\u0026gt; will not implicitly construct from result\u0026lt;int, std::errc\u0026gt;.\nThus bear this in mind during usage: TRY is greedier for implicit conversions than the Outcome types themselves.\n"
},
{
	"uri": "https://ned14.github.io/outcome/videos/",
	"title": "Videos",
	"tags": [],
	"description": "",
	"content": " Outcome has been presented at some of the major C++ conferences as it has evolved. As the older content is less relevant to Outcome today, this list is given in reverse chronological order.\nDublin C++ users group 2018 \u0026ldquo;Deterministic Disappointment\u0026rdquo; Literature review of the WG21 papers relating to deterministically handling failure, and using libraries such as Outcome to implement the same.\n   Meeting C++ 2017 \u0026ldquo;Introduction to proposed std::expected\u0026lt;T, E\u0026gt;\u0026ldquo; Literature review of the several WG21 papers relating to std::expected.\n   ACCU 2017 \u0026ldquo;Mongrel Monads, Dirty, dirty, dirty\u0026rdquo; Covers the history of error handling in C++, and how the LEWG Expected works.\n(Note that the Expected presented here no longer exists, it was substantially changed after the Outcome v1 peer review. Furthermore the Outcome presented here no longer exists, the peer review demanded a complete rebuild)\n   "
},
{
	"uri": "https://ned14.github.io/outcome/tutorial/essential/coroutines/co_await/",
	"title": "`operator co_await` as TRY operator",
	"tags": ["coroutines", "co_await"],
	"description": "",
	"content": "Many people have requested that operator co_await be overloaded to behave as a TRY operator when supplied with an Outcome type.\nOutcome does not implement that extension, nor will we accept PRs contributing support for this. We think you should use OUTCOME_CO_TRY() as this will lead to more maintainable and future proof code.\nHowever, we deliberately do not get in the way of you implementing that overload yourself in your own Outcome-based code. Just be sure that you document what you are doing loudly and clearly, and be aware that future C++ standards may have a proper operator try overload mechanism.\n"
},
{
	"uri": "https://ned14.github.io/outcome/experimental/status_result/",
	"title": "`status_result` and `status_outcome`",
	"tags": [],
	"description": "",
	"content": "status_result and status_outcome are type aliases to basic_result\u0026lt;T, E, NoValuePolicy\u0026gt; and basic_outcome\u0026lt;T, EC, EP, NoValuePolicy\u0026gt; in the usual way, but with a defaulted NoValuePolicy which selects on the basis of status_code\u0026lt;DomainType\u0026gt; instead.\nIf the E type is not some status_code\u0026lt;\u0026gt;, the default policy selector will complain.\n The specifications are:\nexperimental::status_result\u0026lt;T, E = experimental::error\u0026gt; experimental::status_outcome\u0026lt;T, E = experimental::error, EP = std::exception_ptr\u0026gt;  So, the default E is the erased errored status code system_code, which can represent any generic_code, posix_code, win32_code, nt_code, com_code and many other integer error and status codings. Because it is an errored status code, it will always represent a failure.\nYou can absolutely choose an E type which is non-erased e.g. posix_code directly. You can also choose an E type which is not contract guaranteed to be a failure, though your users may find that surprising.\nWhether to choose typed status codes versus the erased status codes depends on your use cases. Outcome replicates faithfully the implicit and explicit conversion semantics of its underlying types, so you can mix results and outcomes of \u0026lt;system_error2\u0026gt; types exactly as you can the \u0026lt;system_error2\u0026gt; types themselves e.g. typed forms will implicitly convert into erased forms if the source type is trivially copyable or move relocating. This means that you can return a generic_code from a function returning a system_code or error, and it\u0026rsquo;ll work exactly as you\u0026rsquo;d expect (implicit conversion).\nAs status_code\u0026lt;erased\u0026lt;T\u0026gt;\u0026gt; is move-only, so is any status_result or status_outcome. For some reason this surprises a lot of people, and they tend to react by not using the erased form because it seems \u0026ldquo;difficult\u0026rdquo;.\n It is actually, in fact, a wise discipline to follow to make all functions return move-only types if you care about determinism and performance. Whilst C++ 17 onwards does much to have the compiler avoid copying of identical function return values thanks to guaranteed copy elision, when a chain of functions return different types, if the programmer forgets to scatter std::move() appropriately, copies rather than moves tend to occur in non-obvious ways. No doubt future C++ standards will improve on the automatic use of moves instead of copies where possible, but until then making all your result and outcome types move-only is an excellent discipline.\nNote that move-only result and outcome capable code (i.e. your project is in Experimental Outcome configuration) usually compiles fine when result and outcome are copyable (i.e. your project is in Standard Outcome configuration), albeit sometimes with a few compiler warnings about unnecessary use of std::move().\n"
},
{
	"uri": "https://ned14.github.io/outcome/motivation/std_error_code/",
	"title": "std::error_code",
	"tags": [],
	"description": "Overview of std::error_code",
	"content": "Type std::error_code has been designed to be sufficiently small and trivial to be cheaply passed around, and at the same time be able to store sufficient information to represent any error situation from any library/sub-system in the world without a clash. Its representation is basically:\nclasserror_code { error_category* domain; // domain from which the error originates  int value; // numeric value of error within the domain };  Here, domain indicates the library from which the error originates. It is a pointer to a global object representing a given library/domain. Different libraries will be represented by different pointers to different globals. Each domain is expected to be represented by a global object derived from std::error_category. The uniqueness of the domain pointer value is guaranteed by the uniqueness of addresses of different global objects.\nNow, value represents a numeric value of a particular error situation within the domain. Thus, different domains can use the same numeric value 1 to indicate different error situations, but two std::error_code objects will be different because the pointers representing domains will be different.\nstd::error_code comes with additional tools: a facility for defining custom domains with their set of error codes, and a facility for building predicates that allow classifying errors.\nOnce created and passed around (either inside a thrown exception or returned from functions by value) there is never a need to change the value of error_code object at any level. But at different levels one can use different predicates for classifying error situations appropriately to the program layer.\nWhen a new library needs to represent its own set of error situations in an error_code it first has to declare the list of numeric value as an enumeration:\nenum classConvertErrc { StringTooLong = 1, // 0 should not represent an error  EmptyString = 2, IllegalChar = 3, };  Then it has to put some boiler-plate code to plug the new enumeration into the std::error_code system. Then, it can use the enum as an error_code:\nstd::error_code ec = ConvertErrc::EmptyString; assert(ec == ConvertErrc::EmptyString);  Member value is mapped directly from the numeric value in the enumeration, and member domain is mapped from the type of the enumeration. Thus, this is a form of type erasure, but one that does allow type std::error_code to be trivial and standard-layout.\n"
},
{
	"uri": "https://ned14.github.io/outcome/tutorial/advanced/interop/app-map-tidylib/",
	"title": "Mapping the HTMLTidy library into the Application",
	"tags": [],
	"description": "",
	"content": "Once again, we create a custom STL exception type to represent failure from the HTMLTidy library. We also create an app namespace wrapper for the C tidy_html() function which is more C++ friendly.\nnamespace app { // Specialise an exception type for tidylib errors  struct tidylib_error : std::system_error { // passthrough  using std::system_error::system_error; tidylib_error() = default; explicit tidylib_error(int c) : std::system_error(c, std::generic_category()) { } }; // Create a C++ invoking wrapper for the tidylib C API, modifying data with the returned data,  // returing a unique_ptr to release storage on scope exit.  struct call_free { template \u0026lt;classT\u0026gt; void operator()(T *p) { ::free(p); } }; inline outcome\u0026lt;std::unique_ptr\u0026lt;char, call_free\u0026gt;\u0026gt; tidy_html(string_view \u0026amp;data) { char *out = nullptr; size_t outlen = 0; int errcode = ::tidy_html(\u0026amp;out, \u0026amp;outlen, data.data(), data.size()); if(errcode != 0) { // If the error code matches a standard STL exception, throw as that.  OUTCOME_V2_NAMESPACE::try_throw_std_exception_from_error(std::error_code(errcode, std::generic_category())); // Otherwise wrap the error code into a tidylib_error exception throw  return std::make_exception_ptr(tidylib_error(errcode)); } // Reset input view to tidied html  data = string_view(out, outlen); // Return a unique ptr to release storage on scope exit  return std::unique_ptr\u0026lt;char, call_free\u0026gt;(out); } } // namespace app View this code on Github "
},
{
	"uri": "https://ned14.github.io/outcome/tutorial/advanced/constructors/",
	"title": "Result returning constructors",
	"tags": ["constructors"],
	"description": "How to metaprogram construction of objects which use result&lt;T, EC&gt; to return failure instead of throwing a C++ exception.",
	"content": "An oft-asked question during conference talks on Expected/Outcome is how to exclusively use result to implement constructor failure. This is asked because whilst almost every member function in a class can return a result, constructors do not return values and thus cannot return a result. The implication is that one cannot avoid throwing C++ exceptions to abort a construction.\nAs with most things in C++, one can achieve zero-exception-throw object construction using a lot of extra typing of boilerplate, and a little bit of simple C++ metaprogramming. This section shows you how to implement these for those who are absolutely adverse to ever throwing an exception, or cannot because C++ exceptions have been globally disabled.\nThe technique described here is not suitable for non-copyable and non-movable types. There is also an assumption that moving your type is cheap.\n"
},
{
	"uri": "https://ned14.github.io/outcome/tutorial/advanced/hooks/hook_outcome/",
	"title": "Hook outcome",
	"tags": [],
	"description": "",
	"content": "The final step is to add event hooks for the very specific case of when our localised outcome is copy or move constructed from our localised result.\nYou ought to be very careful that the noexcept-ness of these matches the noexcept-ness of the types in the outcome. You may have noticed that poke_exception() creates a std::string and appends to it. This can throw an exception. If the copy and/or move constructors of T, EC and EP are noexcept, then so will be outcome\u0026rsquo;s copy and/or move constructor. Thus if poke_exception() throws, instant program termination would occur, which is bad.\nWe avoid that problem in this case by wrapping poke_exception() in a try...catch which throws away any exceptions thrown. For Outcome before v2.2, these specially named free functions must be placed into a namespace which is ADL searched:\nnamespace error_code_extended { // Specialise the outcome copy and move conversion hook for when our localised result  // is used as the source for copy construction our localised outcome  template \u0026lt;classT, classU\u0026gt; inline void hook_outcome_copy_construction(outcome\u0026lt;T\u0026gt; *res, const result\u0026lt;U\u0026gt; \u0026amp; /*unused*/) noexcept { try { // when copy constructing from a result\u0026lt;T\u0026gt;, poke in an exception  poke_exception(res); } catch(...) { // Do nothing  } } template \u0026lt;classT, classU\u0026gt; inline void hook_outcome_move_construction(outcome\u0026lt;T\u0026gt; *res, result\u0026lt;U\u0026gt; \u0026amp;\u0026amp; /*unused*/) noexcept { try { // when move constructing from a result\u0026lt;T\u0026gt;, poke in an exception  poke_exception(res); } catch(...) { // Do nothing  } } } View this code on Github For Outcome v2.2 and later, these functions must be placed into a custom no value policy with the names on_outcome_copy_construction() and on_outcome_move_construction() respectively. As with before, the implementation of the functions is identical, just the name and location has changed.\n"
},
{
	"uri": "https://ned14.github.io/outcome/tutorial/advanced/hooks/",
	"title": "Hooking events",
	"tags": ["hooks"],
	"description": "Intercepting useful events such as initial construction, copies and moves so you can capture backtraces, fire debug breakpoints etc.",
	"content": "Outcome provides multiple methods for user code to intercept various lifecycle events which occur. The deepest method is simply to inherit from basic_result or basic_outcome, and override member functions, for which you will need to study the source code as that form of customisation is out of scope for this tutorial.\nAnother option is to supply a custom NoValuePolicy (see preceding section). From Outcome v2.2 onwards, intercepting construction, copies and moves requires a custom NoValuePolicy.\nBefore Outcome v2.2, there was an ADL discovered event hook mechanism for intercepting construction, copies and moves (it was found to be brittle, error prone and surprising in empirical use, which is why it was replaced). The ADL discovered event hooks still function in Outcome v2.2 and later if OUTCOME_ENABLE_LEGACY_SUPPORT_FOR is set to less than 220 to enable emulation.\nYou will note that the naming is simply one of hook_* =\u0026gt; on_*, the parameters remain identical. This eases porting code from Outcome v2.1 to v2.2, it\u0026rsquo;s usually just a case of copy-pasting the ADL hook code into a custom NoValuePolicy.\nPolicy set event hooks (Outcome v2.2 onwards):\n Constructed  void on_result_construction(T *, U \u0026amp;\u0026amp;) noexcept  void on_outcome_construction(T *, U \u0026amp;\u0026amp;) noexcept   In-place constructed  void on_result_in_place_construction(T *, in_place_type_t\u0026lt;U\u0026gt;, Args \u0026amp;\u0026amp;...) noexcept  void on_outcome_in_place_construction(T *, in_place_type_t\u0026lt;U\u0026gt;, Args \u0026amp;\u0026amp;...) noexcept   Copied  void on_result_copy_construction(T *, U \u0026amp;\u0026amp;) noexcept  void on_outcome_copy_construction(T *, U \u0026amp;\u0026amp;) noexcept   Moved  void on_result_move_construction(T *, U \u0026amp;\u0026amp;) noexcept  void on_outcome_move_construction(T *, U \u0026amp;\u0026amp;) noexcept    ADL discovered event hooks (before Outcome v2.2):\n Constructed  void hook_result_construction(T *, U \u0026amp;\u0026amp;) noexcept  void hook_outcome_construction(T *, U \u0026amp;\u0026amp;) noexcept   In-place constructed  void hook_result_in_place_construction(T *, in_place_type_t\u0026lt;U\u0026gt;, Args \u0026amp;\u0026amp;...) noexcept  void hook_outcome_in_place_construction(T *, in_place_type_t\u0026lt;U\u0026gt;, Args \u0026amp;\u0026amp;...) noexcept   Copied  void hook_result_copy_construction(T *, U \u0026amp;\u0026amp;) noexcept  void hook_outcome_copy_construction(T *, U \u0026amp;\u0026amp;) noexcept   Moved  void hook_result_move_construction(T *, U \u0026amp;\u0026amp;) noexcept  void hook_outcome_move_construction(T *, U \u0026amp;\u0026amp;) noexcept    One criticism often levelled against library-based exception throw alternatives is that they do not provide as rich a set of facilities as C++ exception throws. This section shows you how to configure Outcome, using the event hooks, to take a stack backtrace on construction of an errored result\u0026lt;T, error_code\u0026gt;, and if that result\u0026lt;T, error_code\u0026gt; should ever be converted into an outcome\u0026lt;T, error_code, std::exception_ptr\u0026gt;, a custom std::exception_ptr will be just-in-time synthesised consisting of the std::system_error for the error code, plus an expanded message string containing the stack backtrace of where the error originally occurred.\nOne can see the use case for such a configuration where low-level, deterministic, fixed latency code is built with result, and it dovetails into higher-level application code built with outcome where execution time guarantees are not important, and thus where a malloc is okay. One effectively has constructed a \u0026ldquo;lazy indeterminism\u0026rdquo;, or \u0026ldquo;just-in-time indeterminism\u0026rdquo; mechanism for handling failure, but with all the rich information of throwing C++ exceptions.\n"
},
{
	"uri": "https://ned14.github.io/outcome/tutorial/advanced/interop/app-go/",
	"title": "In use",
	"tags": [],
	"description": "",
	"content": "This is how you might now write application code using these three libraries:\nnamespace app { // A markup function to indicate when we are ValueOrError converting  template \u0026lt;classT\u0026gt; inline outcome\u0026lt;typename T::value_type\u0026gt; ext(T \u0026amp;\u0026amp;v) { //  return outcome\u0026lt;typename T::value_type\u0026gt;(std::move(v)); } outcome\u0026lt;void\u0026gt; go() // NOT noexcept, this can throw STL exceptions e.g. bad_alloc  { // Note that explicit construction is required when converting between differing types  // of outcome and result. This makes it explicit what you intend to do as conversion  // may be a lot more expensive than moves.  // Try to GET this URL. If an unsuccessful HTTP status is returned, serialise a string  // containing a description of the HTTP status code and the URL which failed, storing  // that into a httplib_error exception type which is stored as an exception ptr. The  // TRY operation below will return that exception ptr to be rethrown in the caller.  // Otherwise the fetched data is returned in a std::string data.  OUTCOME_TRY(auto data, ext(httplib::get(\u0026#34;http://www.nedproductions.biz/\u0026#34;))); string_view data_view(data); // HTML tidy the fetched data. If the C library fails due to an error corresponding to  // a standard library exception type, throw that. Otherwise, synthesise an exception  // ptr of type tidylib_error which stores the error code returned in an error code with  // generic category (i.e. errno domain).  // TRY operation below will return that exception ptr to be rethrown in the caller.  // Otherwise the tidied data is returned into holdmem, with the string view updated to  // point at the tidied data.  OUTCOME_TRY(auto holdmem, ext(tidy_html(data_view))); // Write the tidied data to some file. If the write fails, synthesise a filesystem_error  // exception ptr exactly as if one called filelib::write_file(data_view).value().  OUTCOME_TRY(auto written, ext(filelib::write_file(data_view))); return success(); } } // namespace app View this code on Github The curiosity will be surely the ext() markup function, which needs explaining. It was felt important during Outcome\u0026rsquo;s design that value_or_error conversions never be implicit, as they almost always represent a transition across an ABI or semantic boundary. They are also usually non-trivial to implement and compile, and it was felt important that the programmer ought to always mark the semantic boundary transition at the point of every use, as considerable amounts of code may execute.\nHow the end user chooses to mark up their code is up to them, however above we use a simple ext() function to mark up that the function being called is external to the application. This ticks our box of requiring the documentation, at the point of use, of every transition in failure handling boundaries.\nNote that we are able to use TRY as normal throughout this function. Everything \u0026ldquo;just works\u0026rdquo;.\nAnd most especially note that we never, at any stage, needed to modify the source code of httplib, tidylib nor filelib, nor inject custom things into their namespaces. This entire worked example was achieved solely by app based customisation points, and via convert.\n"
},
{
	"uri": "https://ned14.github.io/outcome/alternatives/leaf/",
	"title": "LEAF",
	"tags": [],
	"description": "Advantages and disadvantages of Lightweight Error Augmentation Framework",
	"content": " As much as Outcome originated in a negative reaction to the then originally proposed std::expected\u0026lt;T, E\u0026gt;, LEAF originated in a negative reaction to Outcome. Some of the perceived issues with Outcome were (LEAF\u0026rsquo;s own rendition of this can be viewed here):\n Outcome based code is visually cluttered, as both happy and sad paths appear in code.\n Outcome based code generates branchy code at runtime, which impacts low end CPUs and first time code execution.\n Outcome\u0026rsquo;s Result type encodes the type of the error in the function signature, which could be considered as more brittle and problematic for large scale code refactoring1.\n Outcome is more strongly opinionated about being the ultimate error handling framework in a program (i.e. all third party custom error handling is assumed to flow into Outcome via customisation point adapters), whereas LEAF is less strongly opinionated, and yet provides equivalent functionality.\n  LEAF therefore looks more like standard C++ exception handling, but without the non-deterministic sad path at the cost of a slight impact on happy path runtime performance. LEAF\u0026rsquo;s current design was completed in 2020.\nIf you need an error handling framework which has predictable sad path overhead unlike C++ exceptions, but you otherwise want similar syntax and use experience to C++ exceptions, LEAF is a very solid choice.\nPros:  Very low runtime overhead on the happy path.\n Very low runtime overhead on the sad path.\n Does not cause branchy code to the same extent as Outcome, and the sad path is deterministic unlike with C++ exceptions.\n Very little codegen bloat added to binaries (though there is a fixed absolute overhead for support libraries, most of which can be compiled out using a macro if desired).\n Unlike with any of the preceding options, failures nor successes cannot get unintentionally dropped. This is the same strength of guarantee as with C++ exceptions.\n Works well in most configurations of C++, including C++ exceptions and RTTI globally disabled. Does not dynamically allocate memory.\n  Cons:  Requires out of band storage for state e.g. thread local storage, or a global synchronised ring buffer2.\n If thread local storage is chosen as the out of band storage, transporting LEAF state across threads requires manual intervention.\n If a global ring buffer is chosen as the out of band storage, thread synchronisation with global state is required and the ring buffer can wrap which drops state.\n  Thread local storage can be problematic or even a showstopper in many niche architectures such as HPC, GPUs, DSPs and microcontrollers. Global synchronised state can introduce an unacceptable performance impact on those architectures.\n Current compilers at the time of writing do not react well to use of thread local storage, it would seem that elision of code generation is inhibited if thread local state gets touched due to pessimistic assumptions about escape analysis. Given that this impacts all of C and C++ due to the same problem with errno, it is hoped that future compilers will improve this. Until then, any code which touches thread local storage or magic statics3 will not optimise as well as code which does neither.\n   In Outcome, it is strongly recommended that one chooses a single universal error type for all public APIs such as std::error_code or error from Experimental.Outcome, so if the programmer is disciplined then the function signature does not expose internal error types. Such single universal error types type erase the original error object, but still allow the original error object to be inspected. This avoids \u0026lsquo;exception specifications\u0026rsquo; which are widely known to not scale well. [return] A global synchronised ring buffer implementation does not ship with LEAF, however LEAF exposes customisation points for a bespoke thread local storage implementation which makes implementing one very straightforward. [return] std::error_code construction touches a magic static or calls an extern function, and therefore Outcome when combined with std::error_code also sees a codegen pessimisation. Experimental Outcome\u0026rsquo;s error fixes this historical oversight. [return]   "
},
{
	"uri": "https://ned14.github.io/outcome/motivation/plug_error_code/",
	"title": "Plugging a library into `std::error_code`",
	"tags": [],
	"description": "Illustrates how you can hook into the `std::error_code` system from the Standard Library in order to work with your own set of error codes.",
	"content": "See here for this guide, but for boost::system::error_code.\nThis section illustrates how you can hook into the std::error_code system from the Standard Library in order to work with your own set of error codes. As is usually the case in C++, doing this is straightforward but requires typing boilerplate to tell the C++ STL about your custom error type. This is not part of Outcome library, but we still provide this short guide here, because how to do this is not well documented [1].\nSuppose you want to report all reasons for failure in converting a std::string to a non-negative int. The list is:\n EmptyString \u0026ndash; the input string is empty, IllegalChar \u0026ndash; input contains characters that are not digits, TooLong \u0026ndash; input represents a number, but this number would not fit into a variable of type int.  #include \u0026lt;iostream\u0026gt;#include \u0026lt;string\u0026gt; // for string printing#include \u0026lt;system_error\u0026gt; // bring in std::error_code et al // This is the custom error code enum enum classConversionErrc { Success = 0, // 0 should not represent an error  EmptyString = 1, IllegalChar = 2, TooLong = 3, }; namespace std { // Tell the C++ 11 STL metaprogramming that enum ConversionErrc  // is registered with the standard error code system  template \u0026lt;\u0026gt; struct is_error_code_enum\u0026lt;ConversionErrc\u0026gt; : true_type { }; } namespace detail { // Define a custom error code category derived from std::error_category  classConversionErrc_category : public std::error_category { public: // Return a short descriptive name for the category  virtual const char *name() const noexcept override final { return \u0026#34;ConversionError\u0026#34;; } // Return what each enum means in text  virtual std::string message(int c) const override final { switch (static_cast\u0026lt;ConversionErrc\u0026gt;(c)) { case ConversionErrc::Success: return \u0026#34;conversion successful\u0026#34;; case ConversionErrc::EmptyString: return \u0026#34;converting empty string\u0026#34;; case ConversionErrc::IllegalChar: return \u0026#34;got non-digit char when converting to a number\u0026#34;; case ConversionErrc::TooLong: return \u0026#34;the number would not fit into memory\u0026#34;; default: return \u0026#34;unknown\u0026#34;; } } // OPTIONAL: Allow generic error conditions to be compared to me  virtual std::error_condition default_error_condition(int c) const noexcept override final { switch (static_cast\u0026lt;ConversionErrc\u0026gt;(c)) { case ConversionErrc::EmptyString: return make_error_condition(std::errc::invalid_argument); case ConversionErrc::IllegalChar: return make_error_condition(std::errc::invalid_argument); case ConversionErrc::TooLong: return make_error_condition(std::errc::result_out_of_range); default: // I have no mapping for this code  return std::error_condition(c, *this); } } }; } // Define the linkage for this function to be used by external code. // This would be the usual __declspec(dllexport) or __declspec(dllimport) // if we were in a Windows DLL etc. But for this example use a global // instance but with inline linkage so multiple definitions do not collide. #define THIS_MODULE_API_DECL extern inline  // Declare a global function returning a static instance of the custom category THIS_MODULE_API_DECL const detail::ConversionErrc_category \u0026amp;ConversionErrc_category() { static detail::ConversionErrc_category c; return c; } // Overload the global make_error_code() free function with our // custom enum. It will be found via ADL by the compiler if needed. inline std::error_code make_error_code(ConversionErrc e) { return {static_cast\u0026lt;int\u0026gt;(e), ConversionErrc_category()}; } int main(void) { // Note that we can now supply ConversionErrc directly to error_code  std::error_code ec = ConversionErrc::IllegalChar; std::cout \u0026lt;\u0026lt; \u0026#34;ConversionErrc::IllegalChar is printed by std::error_code as \u0026#34; \u0026lt;\u0026lt; ec \u0026lt;\u0026lt; \u0026#34; with explanatory message \u0026#34; \u0026lt;\u0026lt; ec.message() \u0026lt;\u0026lt; std::endl; // We can compare ConversionErrc containing error codes to generic conditions  std::cout \u0026lt;\u0026lt; \u0026#34;ec is equivalent to std::errc::invalid_argument = \u0026#34; \u0026lt;\u0026lt; (ec == std::errc::invalid_argument) \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;ec is equivalent to std::errc::result_out_of_range = \u0026#34; \u0026lt;\u0026lt; (ec == std::errc::result_out_of_range) \u0026lt;\u0026lt; std::endl; return 0; } View this code on Github This might look like a lot of extra boilerplate over simply using your custom error code enum directly, but look at the advantages:\n Any code which can speak std::error_code can now work with errors from your code, AND without being recompiled. std::system_error can now wrap your custom error codes seamlessly, allowing your custom error code to be converted into a C++ exception and back out again without losing information. std::error_code knows how to print itself, and will print your custom error code without extra work from you. As usually you\u0026rsquo;d need to define a print routine for any custom error code you\u0026rsquo;d write anyway, there is actually very little extra boilerplate here. If you implement the default_error_condition() override, you can allow code exclusively written to understand std::errc alone to examine your custom error code domain for equivalence to the standard error conditions, AND without being recompiled.  This documentation recommends that when you define your custom enum for representing error_codes, you should always make sure that value 0 never represents an actual error: it should either represent a success or should not be provided at all. If you only intend to use your enum inside result\u0026lt;\u0026gt; or outcome\u0026lt;\u0026gt; you can just start your enumerations from 1. If you intend to also return std::error_code directly from functions, you should probably define value 0 as success, so that you are able to inform about function\u0026rsquo;s success by returning MyEnum::Success. This is because error_code\u0026rsquo;s contextual conversion to bool (which some people use to check if there was an error or not) only checks for the numeric value of the error code (without looking at error domain (category)).\n [1]: The only documentation I\u0026rsquo;m aware of is the quite old guide by Chris Kohlhoff, founder of ASIO and the Networking TS:\n http://blog.think-async.com/2010/04/system-error-support-in-c0x-part-1.html http://blog.think-async.com/2010/04/system-error-support-in-c0x-part-2.html http://blog.think-async.com/2010/04/system-error-support-in-c0x-part-3.html http://blog.think-async.com/2010/04/system-error-support-in-c0x-part-4.html http://blog.think-async.com/2010/04/system-error-support-in-c0x-part-5.html  "
},
{
	"uri": "https://ned14.github.io/outcome/experimental/worked-example-long/message/",
	"title": "Redefining `message()`",
	"tags": [],
	"description": "",
	"content": "You may remember that our custom _file_io_error_domain inherits from outcome_e::posix_code::domain_type, and thus does not have to implement the many pure virtual functions required by outcome_e::status_code_domain.\nWhat we do need to do is reimplement _do_message() to append the file and line information to the POSIX error description string returned by outcome_e::posix_code::domain_type. This causes the status code\u0026rsquo;s .message() observer to return a string with the extra payload information represented in text.\n// Return a string describing a specific code. We will return the  // string returned by our POSIX code base domain, with the source  // file and line number appended  virtual _base::string_ref _do_message(const outcome_e::status_code\u0026lt;void\u0026gt; \u0026amp;code) const noexcept override final // NOLINT  { assert(code.domain() == *this); // Fetch message from base domain (POSIX)  auto msg = _base::_do_message(code); const auto \u0026amp;c1 = static_cast\u0026lt;const file_io_error \u0026amp;\u0026gt;(code); // NOLINT  const value_type \u0026amp;v = c1.value(); // Append my source file and line number  if(v.file == nullptr) { return msg; } size_t length = strlen(v.file) + 16 + msg.size(); auto *p = static_cast\u0026lt;char *\u0026gt;(malloc(length)); // NOLINT  if(p == nullptr) { return _base::string_ref(\u0026#34;failed to get message from system\u0026#34;); } sprintf(p, \u0026#34;%s (%s:%d)\u0026#34;, msg.data(), v.file, v.lineno); // Return as atomically reference counted string  return _base::atomic_refcounted_string_ref(p, length); } }; View this code on Github "
},
{
	"uri": "https://ned14.github.io/outcome/tutorial/essential/result/try_ref/",
	"title": "TRY avoiding copy/move",
	"tags": ["try"],
	"description": "",
	"content": "OUTCOME_TRYV(expr)/OUTCOME_TRY(expr) works by creating an internal uniquely named variable which holds the value emitted by the expression. This implies that a copy or move operation shall be performed on the object emitted (unless you are on C++ 17 or later, which has guaranteed copy elision), which may be undesirable for your use case.\nYou can tell OUTCOME_TRY to use a reference rather than a value for the internal uniquely named variable like this:\n// This refers to a Result containing an immovable object outcome::result\u0026lt;Immovable\u0026gt; \u0026amp;\u0026amp;res; // For when you do want to extract the value // This creates an auto \u0026amp;\u0026amp;unique = res, followed by an // auto \u0026amp;\u0026amp;v = std::move(unique).assume_value() OUTCOME_TRY((auto \u0026amp;\u0026amp;, v), res);  If you don\u0026rsquo;t care about extracting the value:\n// For when you don\u0026#39;t want to extract the value // This creates an auto \u0026amp;\u0026amp;unique = res OUTCOME_TRYV2(auto \u0026amp;\u0026amp;, res); "
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/",
	"title": "Types",
	"tags": [],
	"description": "",
	"content": " basic_outcome\u0026lt;T, EC, EP, NoValuePolicy\u0026gt; A type carrying one of (i) a successful T (ii) a disappointment EC (iii) a failure EP (iv) both a disappointment EC and a failure EP, with NoValuePolicy specifying what to do if one tries to read state which isn\u0026rsquo;t there.\n basic_outcome() = delete The default constructor (disabled).\n basic_outcome(basic_outcome \u0026amp;\u0026amp;) Move constructor. Constexpr, triviality and noexcept propagating.\n basic_outcome(const basic_outcome \u0026amp;) Copy constructor. Constexpr, triviality and noexcept propagating.\n basic_outcome \u0026amp;operator=(basic_outcome \u0026amp;\u0026amp;) Move assignment. Constexpr, triviality and noexcept propagating.\n basic_outcome \u0026amp;operator=(const basic_outcome \u0026amp;) Copy assignment. Constexpr, triviality and noexcept propagating.\n ~basic_outcome() Destructor. Constexpr, triviality and noexcept propagating.\n basic_outcome(Args...) = delete Disabling catchall constructor used to give useful diagnostic error when trying to use non-inplace constructors when predicate::constructors_enabled is false.\n basic_outcome(X \u0026amp;\u0026amp;) = delete Disabling implicit constructor used to give useful diagnostic error when trying to use implicit constructors when predicate::implicit_constructors_enabled is false.\n basic_outcome(R \u0026amp;\u0026amp;) Implicit value_type constructor. Available if predicate::enable_value_converting_constructor\u0026lt;R\u0026gt; is true. Constexpr, triviality and noexcept propagating.\n basic_outcome(S \u0026amp;\u0026amp;) Implicit error_type constructor. Available if predicate::enable_error_converting_constructor\u0026lt;S\u0026gt; is true. Constexpr, triviality and noexcept propagating.\n basic_outcome(ErrorCondEnum \u0026amp;\u0026amp;) Implicit error_type from ErrorCondEnum constructor. Available if predicate::enable_error_condition_converting_constructor\u0026lt;ErrorCondEnum\u0026gt; is true. Constexpr, triviality and noexcept propagating.\n basic_outcome(P \u0026amp;\u0026amp;) Implicit exception_type constructor. Available if predicate::enable_exception_converting_constructor\u0026lt;P\u0026gt; is true. Constexpr, triviality and noexcept propagating.\n basic_outcome(S \u0026amp;\u0026amp;, P \u0026amp;\u0026amp;) Implicit error_type + exception_type constructor. Available if predicate::enable_error_exception_converting_constructor\u0026lt;S, P\u0026gt; is true. Constexpr, triviality and noexcept propagating.\n explicit basic_outcome(concepts::value_or_error\u0026lt;T, E\u0026gt; \u0026amp;\u0026amp;) Explicit converting constructor from concepts::value_or_error\u0026lt;T, E\u0026gt; concept matching types. Available if convert::value_or_error\u0026lt;\u0026gt; permits it. Constexpr, triviality and noexcept propagating.\n explicit basic_outcome(const basic_outcome\u0026lt;A, B, C, D\u0026gt; \u0026amp;) Explicit converting copy constructor from compatible basic_outcome. Available if predicate::enable_compatible_conversion\u0026lt;A, B, C, D\u0026gt; is true. Constexpr, triviality and noexcept propagating.\n explicit basic_outcome(basic_outcome\u0026lt;A, B, C, D\u0026gt; \u0026amp;\u0026amp;) Explicit converting move constructor from compatible basic_outcome. Available if predicate::enable_compatible_conversion\u0026lt;A, B, C, D\u0026gt; is true. Constexpr, triviality and noexcept propagating.\n explicit basic_outcome(const basic_result\u0026lt;A, B, C\u0026gt; \u0026amp;) Explicit converting copy constructor from compatible basic_result. Available if predicate::enable_compatible_conversion\u0026lt;A, B, void, C\u0026gt; is true. Constexpr, triviality and noexcept propagating.\n explicit basic_outcome(basic_result\u0026lt;A, B, C\u0026gt; \u0026amp;\u0026amp;) Explicit converting move constructor from compatible basic_result. Available if predicate::enable_compatible_conversion\u0026lt;A, B, void, C\u0026gt; is true. Constexpr, triviality and noexcept propagating.\n explicit basic_outcome(const basic_result\u0026lt;A, B, C\u0026gt; \u0026amp;) Explicit converting copy constructor from compatible basic_result. Available if predicate::enable_make_error_code_compatible_conversion\u0026lt;A, B, void, C\u0026gt; is true. Constexpr, triviality and noexcept propagating.\n explicit basic_outcome(basic_result\u0026lt;A, B, C\u0026gt; \u0026amp;\u0026amp;) Explicit converting move constructor from compatible basic_result. Available if predicate::enable_make_error_code_compatible_conversion\u0026lt;A, B, void, C\u0026gt; is true. Constexpr, triviality and noexcept propagating.\n explicit basic_outcome(in_place_type_t\u0026lt;value_type_if_enabled\u0026gt;, Args ...) Explicit inplace value constructor. Available if predicate::enable_inplace_value_constructor\u0026lt;Args ...\u0026gt; is true. Constexpr, triviality and noexcept propagating.\n explicit basic_outcome(in_place_type_t\u0026lt;value_type_if_enabled\u0026gt;, std::initializer_list\u0026lt;U\u0026gt;, Args ...) Explicit inplace value constructor. Available if predicate::enable_inplace_value_constructor\u0026lt;std::initializer_list\u0026lt;U\u0026gt;, Args ...\u0026gt; is true. Constexpr, triviality and noexcept propagating.\n explicit basic_outcome(in_place_type_t\u0026lt;error_type_if_enabled\u0026gt;, Args ...) Explicit inplace error constructor. Available if predicate::enable_inplace_error_constructor\u0026lt;Args ...\u0026gt; is true. Constexpr, triviality and noexcept propagating.\n explicit basic_outcome(in_place_type_t\u0026lt;error_type_if_enabled\u0026gt;, std::initializer_list\u0026lt;U\u0026gt;, Args ...) Explicit inplace error constructor. Available if predicate::enable_inplace_error_constructor\u0026lt;std::initializer_list\u0026lt;U\u0026gt;, Args ...\u0026gt; is true. Constexpr, triviality and noexcept propagating.\n explicit basic_outcome(in_place_type_t\u0026lt;exception_type_if_enabled\u0026gt;, Args ...) Explicit inplace exception constructor. Available if predicate::enable_inplace_exception_constructor\u0026lt;Args ...\u0026gt; is true. Constexpr, triviality and noexcept propagating.\n explicit basic_outcome(in_place_type_t\u0026lt;exception_type_if_enabled\u0026gt;, std::initializer_list\u0026lt;U\u0026gt;, Args ...) Explicit inplace exception constructor. Available if predicate::enable_inplace_exception_constructor\u0026lt;std::initializer_list\u0026lt;U\u0026gt;, Args ...\u0026gt; is true. Constexpr, triviality and noexcept propagating.\n basic_outcome(A1 \u0026amp;\u0026amp;, A2 \u0026amp;\u0026amp;, Args ...) Implicit inplace value or error or exception constructor. Available if predicate::enable_inplace_value_error_exception_constructor\u0026lt;A1, A2, Args ...\u0026gt; is true. Constexpr, triviality and noexcept propagating.\n basic_outcome(const success_type\u0026lt;T\u0026gt; \u0026amp;) Implicit value-from-success-type-sugar copy constructor. Available if predicate::enable_compatible_conversion\u0026lt;T, void, void\u0026gt; is true, or T is void. Constexpr, triviality and noexcept propagating.\n basic_outcome(success_type\u0026lt;T\u0026gt; \u0026amp;\u0026amp;) Implicit value-from-success-type-sugar move constructor. Available if predicate::enable_compatible_conversion\u0026lt;T, void, void\u0026gt; is true, or T is void. Constexpr, triviality and noexcept propagating.\n basic_outcome(const failure_type\u0026lt;EC\u0026gt; \u0026amp;) Implicit error-from-failure-type-sugar copy constructor. Available if predicate::enable_compatible_conversion\u0026lt;void, EC, void, void\u0026gt; is true. Constexpr, triviality and noexcept propagating.\n basic_outcome(failure_type\u0026lt;EC\u0026gt; \u0026amp;\u0026amp;) Implicit error-from-failure-type-sugar move constructor. Available if predicate::enable_compatible_conversion\u0026lt;void, EC, void, void\u0026gt; is true. Constexpr, triviality and noexcept propagating.\n basic_outcome(const failure_type\u0026lt;EC\u0026gt; \u0026amp;) Implicit error-from-failure-type-sugar copy constructor. Available if predicate::enable_make_error_code_compatible_conversion\u0026lt;void, EC, void, void\u0026gt; is true. Constexpr, triviality and noexcept propagating.\n basic_outcome(failure_type\u0026lt;EC\u0026gt; \u0026amp;\u0026amp;) Implicit error-from-failure-type-sugar move constructor. Available if predicate::enable_make_error_code_compatible_conversion\u0026lt;void, EC, void, void\u0026gt; is true. Constexpr, triviality and noexcept propagating.\n basic_outcome(const failure_type\u0026lt;EP\u0026gt; \u0026amp;) Implicit exception-from-failure-type-sugar copy constructor. Available if predicate::enable_compatible_conversion\u0026lt;void, void, EP, void\u0026gt; is true. Constexpr, triviality and noexcept propagating.\n basic_outcome(failure_type\u0026lt;EP\u0026gt; \u0026amp;\u0026amp;) Implicit exception-from-failure-type-sugar move constructor. Available if predicate::enable_compatible_conversion\u0026lt;void, void, EP, void\u0026gt; is true. Constexpr, triviality and noexcept propagating.\n basic_outcome(const failure_type\u0026lt;EC, EP\u0026gt; \u0026amp;) Implicit error-and-exception-from-failure-type-sugar copy constructor. Available if predicate::enable_compatible_conversion\u0026lt;void, EC, EP, void\u0026gt; is true. Constexpr, triviality and noexcept propagating.\n basic_outcome(failure_type\u0026lt;EC, EP\u0026gt; \u0026amp;\u0026amp;) Implicit error-and-exception-from-failure-type-sugar move constructor. Available if predicate::enable_compatible_conversion\u0026lt;void, EC, EP, void\u0026gt; is true. Constexpr, triviality and noexcept propagating.\n explicit operator bool() const noexcept Returns true if a value is present. Constexpr, never throws.\n bool has_value() const noexcept Returns true if a value is present. Constexpr, never throws.\n bool has_error() const noexcept Returns true if an error is present. Constexpr, never throws.\n bool has_exception() const noexcept Returns true if an exception is present. Constexpr, never throws.\n bool has_failure() const noexcept Returns true if there is either an error or an exception. Constexpr, never throws.\n value_type \u0026amp;assume_value() \u0026amp; noexcept Narrow contract lvalue reference observer of any value present. Constexpr propagating, never throws.\n const value_type \u0026amp;assume_value() const \u0026amp; noexcept Narrow contract const lvalue reference observer of any value present. Constexpr propagating, never throws.\n value_type \u0026amp;\u0026amp;assume_value() \u0026amp;\u0026amp; noexcept Narrow contract rvalue reference observer of any value present. Constexpr propagating, never throws.\n const value_type \u0026amp;\u0026amp;assume_value() const \u0026amp;\u0026amp; noexcept Narrow contract const rvalue reference observer of any value present. Constexpr propagating, never throws.\n value_type \u0026amp;value() \u0026amp; Wide contract lvalue reference observer of any value present. Constexpr propagating.\n const value_type \u0026amp;value() const \u0026amp; Wide contract const lvalue reference observer of any value present. Constexpr propagating.\n value_type \u0026amp;\u0026amp;value() \u0026amp;\u0026amp; Wide contract rvalue reference observer of any value present. Constexpr propagating.\n const value_type \u0026amp;\u0026amp;value() const \u0026amp;\u0026amp; Wide contract const rvalue reference observer of any value present. Constexpr propagating.\n error_type \u0026amp;assume_error() \u0026amp; noexcept Narrow contract lvalue reference observer of the stored error. Constexpr propagating, never throws.\n const error_type \u0026amp;assume_error() const \u0026amp; noexcept Narrow contract const lvalue reference observer of the stored error. Constexpr propagating, never throws.\n error_type \u0026amp;\u0026amp;assume_error() \u0026amp;\u0026amp; noexcept Narrow contract rvalue reference observer of the stored error. Constexpr propagating, never throws.\n const error_type \u0026amp;\u0026amp;assume_error() const \u0026amp;\u0026amp; noexcept Narrow contract const rvalue reference observer of the stored error. Constexpr propagating, never throws.\n error_type \u0026amp;error() \u0026amp; Wide contract lvalue reference observer of the stored error. Constexpr propagating.\n const error_type \u0026amp;error() const \u0026amp; Wide contract const lvalue reference observer of the stored error. Constexpr propagating.\n error_type \u0026amp;\u0026amp;error() \u0026amp;\u0026amp; Wide contract rvalue reference observer of the stored error. Constexpr propagating.\n const error_type \u0026amp;\u0026amp;error() const \u0026amp;\u0026amp; Wide contract const rvalue reference observer of the stored error. Constexpr propagating.\n exception_type \u0026amp;assume_exception() \u0026amp; noexcept Narrow contract lvalue reference observer of the stored exception. Constexpr propagating, never throws.\n const exception_type \u0026amp;assume_exception() const \u0026amp; noexcept Narrow contract const lvalue reference observer of the stored exception. Constexpr propagating, never throws.\n const exception_type \u0026amp;\u0026amp;assume_exception() const \u0026amp;\u0026amp; noexcept Narrow contract const rvalue reference observer of the stored exception. Constexpr propagating, never throws.\n exception_type \u0026amp;\u0026amp;assume_exception() \u0026amp;\u0026amp; noexcept Narrow contract rvalue reference observer of the stored exception. Constexpr propagating, never throws.\n exception_type \u0026amp;exception() \u0026amp; Wide contract lvalue reference observer of the stored exception. Constexpr propagating.\n const exception_type \u0026amp;exception() const \u0026amp; Wide contract const lvalue reference observer of the stored exception. Constexpr propagating.\n exception_type \u0026amp;\u0026amp;exception() \u0026amp;\u0026amp; Wide contract rvalue reference observer of the stored exception. Constexpr propagating.\n const exception_type \u0026amp;\u0026amp;exception() const \u0026amp;\u0026amp; Wide contract const rvalue reference observer of the stored exception. Constexpr propagating.\n exception_type failure() const noexcept Synthesising observer of the stored exception or error. Available if the traits is_error_code_available\u0026lt;T\u0026gt; and is_exception_ptr_available\u0026lt;T\u0026gt; are both true. Never throws.\n bool operator==(const basic_result\u0026lt;A, B, C\u0026gt; \u0026amp;) const Returns true if this outcome compares equal to the other result. Constexpr and noexcept propagating.\n bool operator==(const basic_outcome\u0026lt;A, B, C, D\u0026gt; \u0026amp;) const Returns true if this outcome compares equal to the other outcome. Constexpr and noexcept propagating.\n bool operator==(const success_type\u0026lt;A\u0026gt; \u0026amp;) const Returns true if this result compares equal to the success type sugar. Constexpr and noexcept propagating.\n bool operator==(const failure_type\u0026lt;A, B\u0026gt; \u0026amp;) const Returns true if this outcome compares equal to the failure type sugar. Constexpr and noexcept propagating.\n bool operator!=(const basic_result\u0026lt;A, B, C\u0026gt; \u0026amp;) const Returns true if this outcome does not compare equal to the other result. Constexpr and noexcept propagating.\n bool operator!=(const basic_outcome\u0026lt;A, B, C, D\u0026gt; \u0026amp;) const Returns true if this outcome does not compare equal to the other outcome. Constexpr and noexcept propagating.\n bool operator!=(const success_type\u0026lt;A\u0026gt; \u0026amp;) const Returns true if this outcome does not compare equal to the success type sugar. Constexpr and noexcept propagating.\n bool operator!=(const failure_type\u0026lt;A, B\u0026gt; \u0026amp;) const Returns true if this outcome does not compare equal to the failure type sugar. Constexpr and noexcept propagating.\n void swap(basic_outcome \u0026amp;) Swap one basic_outcome with another, with the strong guarantee. Noexcept propagating.\n failure_type\u0026lt;error_type, exception_type\u0026gt; as_failure() const \u0026amp; Return the output from free function failure() containing a copy of any errored and/or excepted state.\n failure_type\u0026lt;error_type, exception_type\u0026gt; as_failure() \u0026amp;\u0026amp; Return the output from free function failure() containing a move of any errored and/or excepted state.\n basic_result\u0026lt;T, E, NoValuePolicy\u0026gt; A sum type carrying either a successful T, or a disappointment E, with NoValuePolicy specifying what to do if one tries to read state which isn\u0026rsquo;t there.\n basic_result() = delete The default constructor (disabled).\n basic_result(basic_result \u0026amp;\u0026amp;) Move constructor. Constexpr, triviality and noexcept propagating.\n basic_result(const basic_result \u0026amp;) Copy constructor. Constexpr, triviality and noexcept propagating.\n basic_result \u0026amp;operator=(basic_result \u0026amp;\u0026amp;) Move assignment. Constexpr, triviality and noexcept propagating.\n basic_result \u0026amp;operator=(const basic_result \u0026amp;) Copy assignment. Constexpr, triviality and noexcept propagating.\n ~basic_result() Destructor. Constexpr, triviality and noexcept propagating.\n basic_result(Args...) = delete Disabling catchall constructor used to give useful diagnostic error when trying to use non-inplace constructors when predicate::constructors_enabled is false.\n basic_result(X \u0026amp;\u0026amp;) = delete Disabling implicit constructor used to give useful diagnostic error when trying to use implicit constructors when predicate::implicit_constructors_enabled is false.\n basic_result(R \u0026amp;\u0026amp;) Implicit value_type constructor. Available if predicate::enable_value_converting_constructor\u0026lt;R\u0026gt; is true. Constexpr, triviality and noexcept propagating.\n basic_result(S \u0026amp;\u0026amp;) Implicit error_type constructor. Available if predicate::enable_error_converting_constructor\u0026lt;S\u0026gt; is true. Constexpr, triviality and noexcept propagating.\n basic_result(ErrorCondEnum \u0026amp;\u0026amp;) Implicit error_type from ErrorCondEnum constructor. Available if predicate::enable_error_condition_converting_constructor\u0026lt;ErrorCondEnum\u0026gt; is true. Constexpr, triviality and noexcept propagating.\n explicit basic_result(concepts::value_or_error\u0026lt;T, E\u0026gt; \u0026amp;\u0026amp;) Explicit converting constructor from concepts::value_or_error\u0026lt;T, E\u0026gt; concept matching types. Available if convert::value_or_error\u0026lt;\u0026gt; permits it. Constexpr, triviality and noexcept propagating.\n explicit basic_result(const basic_result\u0026lt;R, S, P\u0026gt; \u0026amp;) Explicit converting copy constructor from compatible basic_result. Available if predicate::enable_compatible_conversion\u0026lt;R, S, P\u0026gt; is true. Constexpr, triviality and noexcept propagating.\n explicit basic_result(basic_result\u0026lt;R, S, P\u0026gt; \u0026amp;\u0026amp;) Explicit converting move constructor from compatible basic_result. Available if predicate::enable_compatible_conversion\u0026lt;R, S, P\u0026gt; is true. Constexpr, triviality and noexcept propagating.\n explicit basic_result(const basic_result\u0026lt;R, S, P\u0026gt; \u0026amp;) Explicit converting copy constructor from compatible basic_result. Available if predicate::enable_make_error_code_compatible_conversion\u0026lt;R, S, P\u0026gt; is true. Constexpr, triviality and noexcept propagating.\n explicit basic_result(basic_result\u0026lt;R, S, P\u0026gt; \u0026amp;\u0026amp;) Explicit converting move constructor from compatible basic_result. Available if predicate::enable_make_error_code_compatible_conversion\u0026lt;R, S, P\u0026gt; is true. Constexpr, triviality and noexcept propagating.\n explicit basic_result(const basic_result\u0026lt;R, S, P\u0026gt; \u0026amp;) Explicit converting copy constructor from compatible basic_result. Available if predicate::enable_make_exception_ptr_compatible_conversion\u0026lt;R, S, P\u0026gt; is true. Constexpr, triviality and noexcept propagating.\n explicit basic_result(basic_result\u0026lt;R, S, P\u0026gt; \u0026amp;\u0026amp;) Explicit converting move constructor from compatible basic_result. Available if predicate::enable_make_exception_ptr_compatible_conversion\u0026lt;R, S, P\u0026gt; is true. Constexpr, triviality and noexcept propagating.\n explicit basic_result(in_place_type_t\u0026lt;value_type_if_enabled\u0026gt;, Args ...) Explicit inplace value constructor. Available if predicate::enable_inplace_value_constructor\u0026lt;Args ...\u0026gt; is true. Constexpr, triviality and noexcept propagating.\n explicit basic_result(in_place_type_t\u0026lt;value_type_if_enabled\u0026gt;, std::initializer_list\u0026lt;U\u0026gt;, Args ...) Explicit inplace value constructor. Available if predicate::enable_inplace_value_constructor\u0026lt;std::initializer_list\u0026lt;U\u0026gt;, Args ...\u0026gt; is true. Constexpr, triviality and noexcept propagating.\n explicit basic_result(in_place_type_t\u0026lt;error_type_if_enabled\u0026gt;, Args ...) Explicit inplace error constructor. Available if predicate::enable_inplace_error_constructor\u0026lt;Args ...\u0026gt; is true. Constexpr, triviality and noexcept propagating.\n explicit basic_result(in_place_type_t\u0026lt;error_type_if_enabled\u0026gt;, std::initializer_list\u0026lt;U\u0026gt;, Args ...) Explicit inplace error constructor. Available if predicate::enable_inplace_error_constructor\u0026lt;std::initializer_list\u0026lt;U\u0026gt;, Args ...\u0026gt; is true. Constexpr, triviality and noexcept propagating.\n basic_result(A1 \u0026amp;\u0026amp;, A2 \u0026amp;\u0026amp;, Args ...) Implicit inplace value or error constructor. Available if predicate::enable_inplace_value_error_constructor\u0026lt;A1, A2, Args ...\u0026gt; is true. Constexpr, triviality and noexcept propagating.\n basic_result(const success_type\u0026lt;T\u0026gt; \u0026amp;) Implicit value-from-success-type-sugar copy constructor. Available if predicate::enable_compatible_conversion\u0026lt;T, void, void\u0026gt; is true, or T is void. Constexpr, triviality and noexcept propagating.\n basic_result(success_type\u0026lt;T\u0026gt; \u0026amp;\u0026amp;) Implicit value-from-success-type-sugar move constructor. Available if predicate::enable_compatible_conversion\u0026lt;T, void, void\u0026gt; is true, or T is void. Constexpr, triviality and noexcept propagating.\n basic_result(const failure_type\u0026lt;T\u0026gt; \u0026amp;) Implicit error-from-failure-type-sugar copy constructor. Available if predicate::enable_compatible_conversion\u0026lt;void, T, void\u0026gt; is true, or T is void. Constexpr, triviality and noexcept propagating.\n basic_result(failure_type\u0026lt;T\u0026gt; \u0026amp;\u0026amp;) Implicit error-from-failure-type-sugar move constructor. Available if predicate::enable_compatible_conversion\u0026lt;void, T, void\u0026gt; is true, or T is void. Constexpr, triviality and noexcept propagating.\n basic_result(const failure_type\u0026lt;T\u0026gt; \u0026amp;) Implicit error-from-failure-type-sugar copy constructor. Available if predicate::enable_make_error_code_compatible_conversion\u0026lt;void, T, void\u0026gt; is true, or T is void. Constexpr, triviality and noexcept propagating.\n basic_result(failure_type\u0026lt;T\u0026gt; \u0026amp;\u0026amp;) Implicit error-from-failure-type-sugar move constructor. Available if predicate::enable_make_error_code_compatible_conversion\u0026lt;void, T, void\u0026gt; is true, or T is void. Constexpr, triviality and noexcept propagating.\n basic_result(const failure_type\u0026lt;T\u0026gt; \u0026amp;) Implicit error-from-failure-type-sugar copy constructor. Available if predicate::enable_make_exception_ptr_compatible_conversion\u0026lt;void, T, void\u0026gt; is true, or T is void. Constexpr, triviality and noexcept propagating.\n basic_result(failure_type\u0026lt;T\u0026gt; \u0026amp;\u0026amp;) Implicit error-from-failure-type-sugar move constructor. Available if predicate::enable_make_exception_ptr_compatible_conversion\u0026lt;void, T, void\u0026gt; is true, or T is void. Constexpr, triviality and noexcept propagating.\n explicit operator bool() const noexcept Returns true if a value is present. Constexpr, never throws.\n bool has_value() const noexcept Returns true if a value is present. Constexpr, never throws.\n bool has_error() const noexcept Returns true if an error is present. Constexpr, never throws.\n bool has_exception() const noexcept Always returns false for basic_result. Constexpr, never throws.\n bool has_failure() const noexcept Returns true if there is either an error or an exception. Constexpr, never throws.\n bool has_lost_consistency() const noexcept Returns true if a preceding swap involving this object failed to preserve the strong guarantee. Constexpr, never throws.\n value_type \u0026amp;assume_value() \u0026amp; noexcept Narrow contract lvalue reference observer of any value present. Constexpr propagating, never throws.\n const value_type \u0026amp;assume_value() const \u0026amp; noexcept Narrow contract const lvalue reference observer of any value present. Constexpr propagating, never throws.\n value_type \u0026amp;\u0026amp;assume_value() \u0026amp;\u0026amp; noexcept Narrow contract rvalue reference observer of any value present. Constexpr propagating, never throws.\n const value_type \u0026amp;\u0026amp;assume_value() const \u0026amp;\u0026amp; noexcept Narrow contract const rvalue reference observer of any value present. Constexpr propagating, never throws.\n value_type \u0026amp;value() \u0026amp; Wide contract lvalue reference observer of any value present. Constexpr propagating.\n const value_type \u0026amp;value() const \u0026amp; Wide contract const lvalue reference observer of any value present. Constexpr propagating.\n value_type \u0026amp;\u0026amp;value() \u0026amp;\u0026amp; Wide contract rvalue reference observer of any value present. Constexpr propagating.\n const value_type \u0026amp;\u0026amp;value() const \u0026amp;\u0026amp; Wide contract const rvalue reference observer of any value present. Constexpr propagating.\n error_type \u0026amp;assume_error() \u0026amp; noexcept Narrow contract lvalue reference observer of the stored error. Constexpr propagating, never throws.\n const error_type \u0026amp;assume_error() const \u0026amp; noexcept Narrow contract const lvalue reference observer of the stored error. Constexpr propagating, never throws.\n error_type \u0026amp;\u0026amp;assume_error() \u0026amp;\u0026amp; noexcept Narrow contract rvalue reference observer of the stored error. Constexpr propagating, never throws.\n const error_type \u0026amp;\u0026amp;assume_error() const \u0026amp;\u0026amp; noexcept Narrow contract const rvalue reference observer of the stored error. Constexpr propagating, never throws.\n error_type \u0026amp;error() \u0026amp; Wide contract lvalue reference observer of the stored error. Constexpr propagating.\n const error_type \u0026amp;error() const \u0026amp; Wide contract const lvalue reference observer of the stored error. Constexpr propagating.\n error_type \u0026amp;\u0026amp;error() \u0026amp;\u0026amp; Wide contract rvalue reference observer of the stored error. Constexpr propagating.\n const error_type \u0026amp;\u0026amp;error() const \u0026amp;\u0026amp; Wide contract const rvalue reference observer of the stored error. Constexpr propagating.\n bool operator==(const basic_result\u0026lt;A, B, C\u0026gt; \u0026amp;) const Returns true if this result compares equal to the other result. Constexpr and noexcept propagating.\n bool operator==(const success_type\u0026lt;A\u0026gt; \u0026amp;) const Returns true if this result compares equal to the success type sugar. Constexpr and noexcept propagating.\n bool operator==(const failure_type\u0026lt;A, void\u0026gt; \u0026amp;) const Returns true if this result compares equal to the failure type sugar. Constexpr and noexcept propagating.\n bool operator!=(const basic_result\u0026lt;A, B, C\u0026gt; \u0026amp;) const Returns true if this result does not compare equal to the other result. Constexpr and noexcept propagating.\n bool operator!=(const success_type\u0026lt;A\u0026gt; \u0026amp;) const Returns true if this result does not compare equal to the success type sugar. Constexpr and noexcept propagating.\n bool operator!=(const failure_type\u0026lt;A, void\u0026gt; \u0026amp;) const Returns true if this result does not compare equal to the failure type sugar. Constexpr and noexcept propagating.\n void swap(basic_result \u0026amp;) Swap one basic_result with another, with the strong guarantee. Noexcept propagating.\n auto as_failure() const \u0026amp; Return the output from free function failure() containing a copy of any errored state.\n auto as_failure() \u0026amp;\u0026amp; Return the output from free function failure() containing a move of any errored state.\n bad_outcome_access Exception type publicly inheriting from std::logic_error indicating an incorrect observation of value or error or exception occurred.\n bad_result_access_with\u0026lt;EC\u0026gt; Exception type publicly inheriting from bad_result_access indicating an incorrect observation of value occurred, supplying the error value.\n bad_result_access Exception type publicly inheriting from std::logic_error indicating an incorrect observation of value or error occurred.\n eager\u0026lt;T, Executor = void\u0026gt;/atomic_eager\u0026lt;T, Executor = void\u0026gt; An eagerly evaluated coroutine awaitable with Outcome customisation.\n failure_type\u0026lt;EC, EP = void\u0026gt; Type sugar for constructing an unsuccessful result or outcome.\n generator\u0026lt;T, Executor = void\u0026gt; A lazily evaluated coroutine generator with Outcome customisation.\n in_place_type_t\u0026lt;T\u0026gt; Either std::in_place_type_t\u0026lt;T\u0026gt; or a local emulation, depending on the OUTCOME_USE_STD_IN_PLACE_TYPE macro.\n lazy\u0026lt;T, Executor = void\u0026gt;/atomic_lazy\u0026lt;T, Executor = void\u0026gt; A lazily evaluated coroutine awaitable with Outcome customisation.\n success_type\u0026lt;T\u0026gt; Type sugar for constructing a successful result or outcome.\n "
},
{
	"uri": "https://ned14.github.io/outcome/tutorial/advanced/constructors/metaprogrammg2/",
	"title": "construct&lt;T&gt;",
	"tags": [],
	"description": "",
	"content": "First, we need a base definition for make\u0026lt;T\u0026gt;:\ntemplate \u0026lt;classT\u0026gt; struct make { outcome::result\u0026lt;T\u0026gt; operator()() const noexcept { //  static_assert(!std::is_same\u0026lt;T, T\u0026gt;::value, //  \u0026#34;make\u0026lt;T\u0026gt;() was not specialised for the type T supplied\u0026#34;); } }; View this code on Github This fails a static assert if the type is ever instantiated unspecialised.\nWe then specialise for make\u0026lt;file_handle\u0026gt;:\ntemplate \u0026lt;\u0026gt; struct make\u0026lt;file_handle\u0026gt; { file_handle::path_type _path; file_handle::mode _mode{file_handle::mode::read}; // Any other args, default initialised if necessary, follow here ...  outcome::result\u0026lt;file_handle\u0026gt; operator()() const noexcept //  { return file_handle::file(std::move(_path)); } }; View this code on Github Because this is a struct, we can list initialise make, and use default member initialisers to implement default arguments. This can get you surprisingly far before you need to start writing custom constructors.\nBut in more complex code, you will usually provide all the initialisation overloads that you would for the constructors of your main type. You then implement a single phase 2 constructing function which accepts make\u0026lt;YOURTYPE\u0026gt; as input, and construct solely from that source.\n"
},
{
	"uri": "https://ned14.github.io/outcome/tutorial/advanced/interop/conclusion/",
	"title": "Conclusion",
	"tags": [],
	"description": "",
	"content": "This worked example was in fact excessively complex: a quicker route to achieving the same thing would be to add explicit converting constructors to app::error_code for each of the third party library E types. One then could have saved oneself with having to bother injecting custom converters into the OUTCOME_V2_NAMESPACE::convert namespace. If you control your application\u0026rsquo;s E type, then that is probably a better, and certainly simpler, approach.\nHowever there are occasions when you don\u0026rsquo;t have control over the implementation of the destination E type e.g. in callbacks. Outcome\u0026rsquo;s value_or_error infrastructure lets you inject custom interop code for any pair of incommensurate third party E types, without needing to modify either\u0026rsquo;s source code.\nThis is without doubt a \u0026ldquo;power users\u0026rdquo; feature, but one which will prove useful as T|E based C++ code proliferates.\n"
},
{
	"uri": "https://ned14.github.io/outcome/motivation/plug_error_code2/",
	"title": "Plugging a library into `boost::system::error_code`",
	"tags": [],
	"description": "Illustrates how you can hook into the `boost::system::error_code` system from Boost in order to work with your own set of error codes.",
	"content": "See here for this guide, but for std::error_code.\nThis section illustrates how you can hook into the boost::system::error_code system from the Boost in order to work with your own set of error codes. As is usually the case in C++, doing this is straightforward but requires typing boilerplate to tell Boost.System about your custom error type. This is not part of Outcome library, but we still provide this short guide here, because how to do this is not well documented [1].\nSuppose you want to report all reasons for failure in converting a std::string to a non-negative int. The list is:\n EmptyString \u0026ndash; the input string is empty, IllegalChar \u0026ndash; input contains characters that are not digits, TooLong \u0026ndash; input represents a number, but this number would not fit into a variable of type int.  #include \u0026lt;boost/system/error_code.hpp\u0026gt; // bring in boost::system::error_code et al#include \u0026lt;iostream\u0026gt;#include \u0026lt;string\u0026gt; // for string printing // This is the custom error code enum enum classConversionErrc { Success = 0, // 0 should not represent an error  EmptyString = 1, IllegalChar = 2, TooLong = 3, }; namespace boost { namespace system { // Tell the C++ 11 STL metaprogramming that enum ConversionErrc  // is registered with the standard error code system  template \u0026lt;\u0026gt; struct is_error_code_enum\u0026lt;ConversionErrc\u0026gt; : std::true_type { }; } // namespace system } // namespace boost  namespace detail { // Define a custom error code category derived from boost::system::error_category  classConversionErrc_category : public boost::system::error_category { public: // Return a short descriptive name for the category  virtual const char *name() const noexcept override final { return \u0026#34;ConversionError\u0026#34;; } // Return what each enum means in text  virtual std::string message(int c) const override final { switch(static_cast\u0026lt;ConversionErrc\u0026gt;(c)) { case ConversionErrc::Success: return \u0026#34;conversion successful\u0026#34;; case ConversionErrc::EmptyString: return \u0026#34;converting empty string\u0026#34;; case ConversionErrc::IllegalChar: return \u0026#34;got non-digit char when converting to a number\u0026#34;; case ConversionErrc::TooLong: return \u0026#34;the number would not fit into memory\u0026#34;; default: return \u0026#34;unknown\u0026#34;; } } // OPTIONAL: Allow generic error conditions to be compared to me  virtual boost::system::error_condition default_error_condition(int c) const noexcept override final { switch(static_cast\u0026lt;ConversionErrc\u0026gt;(c)) { case ConversionErrc::EmptyString: return make_error_condition(boost::system::errc::invalid_argument); case ConversionErrc::IllegalChar: return make_error_condition(boost::system::errc::invalid_argument); case ConversionErrc::TooLong: return make_error_condition(boost::system::errc::result_out_of_range); default: // I have no mapping for this code  return boost::system::error_condition(c, *this); } } }; } // namespace detail  // Define the linkage for this function to be used by external code. // This would be the usual __declspec(dllexport) or __declspec(dllimport) // if we were in a Windows DLL etc. But for this example use a global // instance but with inline linkage so multiple definitions do not collide. #define THIS_MODULE_API_DECL extern inline  // Declare a global function returning a static instance of the custom category THIS_MODULE_API_DECL const detail::ConversionErrc_category \u0026amp;ConversionErrc_category() { static detail::ConversionErrc_category c; return c; } // Overload the global make_error_code() free function with our // custom enum. It will be found via ADL by the compiler if needed. inline boost::system::error_code make_error_code(ConversionErrc e) { return {static_cast\u0026lt;int\u0026gt;(e), ConversionErrc_category()}; } int main(void) { // Note that we can now supply ConversionErrc directly to error_code  boost::system::error_code ec = ConversionErrc::IllegalChar; std::cout \u0026lt;\u0026lt; \u0026#34;ConversionErrc::IllegalChar is printed by boost::system::error_code as \u0026#34; \u0026lt;\u0026lt; ec \u0026lt;\u0026lt; \u0026#34; with explanatory message \u0026#34; \u0026lt;\u0026lt; ec.message() \u0026lt;\u0026lt; std::endl; // We can compare ConversionErrc containing error codes to generic conditions  std::cout \u0026lt;\u0026lt; \u0026#34;ec is equivalent to boost::system::errc::invalid_argument = \u0026#34; \u0026lt;\u0026lt; (ec == std::errc::invalid_argument) \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;ec is equivalent to boost::system::errc::result_out_of_range = \u0026#34; \u0026lt;\u0026lt; (ec == std::errc::result_out_of_range) \u0026lt;\u0026lt; std::endl; return 0; } View this code on Github This might look like a lot of extra boilerplate over simply using your custom error code enum directly, but look at the advantages:\n Any code which can speak boost::system::error_code can now work with errors from your code, AND without being recompiled. boost::system::system_error can now wrap your custom error codes seamlessly, allowing your custom error code to be converted into a C++ exception and back out again without losing information. boost::system::error_code knows how to print itself, and will print your custom error code without extra work from you. As usually you\u0026rsquo;d need to define a print routine for any custom error code you\u0026rsquo;d write anyway, there is actually very little extra boilerplate here. If you implement the default_error_condition() override, you can allow code exclusively written to understand boost::system::errc alone to examine your custom error code domain for equivalence to the standard error conditions, AND without being recompiled.  This documentation recommends that when you define your custom enum for representing error_codes, you should always make sure that value 0 never represents an actual error: it should either represent a success or should not be provided at all. If you only intend to use your enum inside result\u0026lt;\u0026gt; or outcome\u0026lt;\u0026gt; you can just start your enumerations from 1. If you intend to also return boost::system::error_code directly from functions, you should probably define value 0 as success, so that you are able to inform about function\u0026rsquo;s success by returning MyEnum::Success. This is because error_code\u0026rsquo;s contextual conversion to bool (which some people use to check if there was an error or not) only checks for the numeric value of the error code (without looking at error domain (category)).\n [1]: The only documentation I\u0026rsquo;m aware of is the quite old guide by Chris Kohlhoff, founder of ASIO and the Networking TS:\n http://blog.think-async.com/2010/04/system-error-support-in-c0x-part-1.html http://blog.think-async.com/2010/04/system-error-support-in-c0x-part-2.html http://blog.think-async.com/2010/04/system-error-support-in-c0x-part-3.html http://blog.think-async.com/2010/04/system-error-support-in-c0x-part-4.html http://blog.think-async.com/2010/04/system-error-support-in-c0x-part-5.html  "
},
{
	"uri": "https://ned14.github.io/outcome/reference/aliases/",
	"title": "Aliases",
	"tags": [],
	"description": "",
	"content": " boost_checked\u0026lt;T, E = boost::system::error_code\u0026gt; A type alias to a basic_result configured with boost::system::error_code and policy::throw_bad_result_access\u0026lt;EC\u0026gt;.\n boost_outcome\u0026lt;T, EC = boost::system::error_code, EP = boost::exception_ptr, NoValuePolicy = policy::default_policy\u0026lt;T, EC, EP\u0026gt;\u0026gt; A type alias to a basic_outcome configured with boost::system::error_code, boost::exception_ptr and policy::default_policy.\n boost_result\u0026lt;T, E = boost::system::error_code, NoValuePolicy = policy::default_policy\u0026lt;T, E, void\u0026gt;\u0026gt; A type alias to a basic_result configured with boost::system::error_code and policy::default_policy.\n boost_unchecked\u0026lt;T, E = boost::system::error_code\u0026gt; A type alias to a basic_result configured with boost::system::error_code and policy::all_narrow.\n checked\u0026lt;T, E = varies\u0026gt; A type alias to a std_checked\u0026lt;T, E\u0026gt; (standalone edition) or boost_checked\u0026lt;T, E\u0026gt; (Boost edition).\n default_policy\u0026lt;T, EC, EP\u0026gt; A type alias to a no-value policy selected based on traits matching of T, EC and EP.\n outcome\u0026lt;T, EC = varies, EP = varies, NoValuePolicy = policy::default_policy\u0026lt;T, EC, EP\u0026gt;\u0026gt; A type alias to a std_outcome\u0026lt;T, EC, EP, NoValuePolicy\u0026gt; (standalone edition) or boost_outcome\u0026lt;T, EC, EP, NoValuePolicy\u0026gt; (Boost edition).\n result\u0026lt;T, E = varies, NoValuePolicy = policy::default_policy\u0026lt;T, E, void\u0026gt;\u0026gt; A type alias to a std_result\u0026lt;T, E, NoValuePolicy\u0026gt; (standalone edition) or boost_result\u0026lt;T, E, NoValuePolicy\u0026gt; (Boost edition).\n std_checked\u0026lt;T, E = std::error_code\u0026gt; A type alias to a basic_result configured with std::error_code and policy::throw_bad_result_access\u0026lt;EC\u0026gt;.\n std_outcome\u0026lt;T, EC = std::error_code, EP = std::exception_ptr, NoValuePolicy = policy::default_policy\u0026lt;T, EC, EP\u0026gt;\u0026gt; A type alias to a basic_outcome configured with std::error_code, std::exception_ptr and policy::default_policy.\n std_result\u0026lt;T, E = std::error_code, NoValuePolicy = policy::default_policy\u0026lt;T, E, void\u0026gt;\u0026gt; A type alias to a basic_result configured with std::error_code and policy::default_policy.\n std_unchecked\u0026lt;T, E = std::error_code\u0026gt; A type alias to a basic_result configured with std::error_code and policy::all_narrow.\n unchecked\u0026lt;T, E = varies\u0026gt; A type alias to a std_unchecked\u0026lt;T, E\u0026gt; (standalone edition) or boost_unchecked\u0026lt;T, E\u0026gt; (Boost edition).\n "
},
{
	"uri": "https://ned14.github.io/outcome/tutorial/advanced/constructors/metaprogrammg3/",
	"title": "Alternatives",
	"tags": [],
	"description": "",
	"content": "No doubt many will dislike the two-stage invocation pattern i.e.\nmake\u0026lt;file_handle\u0026gt;{\u0026#34;hello\u0026#34;}();  So let us examine the most obvious alternative: a templated free function make\u0026lt;T\u0026gt;.\nDue to the inability to partially specialise templated functions in C++, you need to use tagged overloading e.g.\ntemplate\u0026lt;class... Args\u0026gt; inline outcome::result\u0026lt;file_handle\u0026gt; make(std::in_place_type_t\u0026lt;file_handle\u0026gt;, Args\u0026amp;\u0026amp; ... args) { return file_handle::file(std::forward\u0026lt;Args\u0026gt;(args)...); } ... // Now you must always write this: make(std::in_place_type\u0026lt;file_handle\u0026gt;, \u0026#34;hello\u0026#34;);  Tagged overloading is fine for smaller projects, but for larger code bases:\n It takes longer to type make(std::in_place_type\u0026lt;file_handle\u0026gt;, \u0026quot;hello\u0026quot;), and is possibly less intuitive to write, than it does make\u0026lt;file_handle\u0026gt;{\u0026quot;hello\u0026quot;}(). Compiler error messages are enormously clearer if you encode the permitted overloads for construction into the make\u0026lt;file_handle\u0026gt; type rather than letting a variadic free function fail to resolve an appropriate overload. Resolving variadic free function overloads is not constant time for the compiler, whereas resolving the type specialisation for make\u0026lt;file_handle\u0026gt; is constant time. In other words, free functions are expensive on build times, whereas fully specialised types are not. It actually turns out to be quite useful when writing generic code to pass around object constructing factory objects all of which have no parameters for their call operator. It becomes, effectively, a lazy construction mechanism.  "
},
{
	"uri": "https://ned14.github.io/outcome/experimental/worked-example-long/source/",
	"title": "Constexpr domain source",
	"tags": [],
	"description": "",
	"content": "Back in The constructor, we declared but did not implement a .get() function which returns a constexpr static instance of the domain. We implement this now:\n// 100% constexpr instantiation constexpr _file_io_error_domain file_io_error_domain; inline constexpr const _file_io_error_domain \u0026amp;_file_io_error_domain::get() { return file_io_error_domain; } View this code on Github As this is 100% constexpr, it can be (and is under optimisation) implemented entirely in the mind of the compiler with no run time representation.\n"
},
{
	"uri": "https://ned14.github.io/outcome/motivation/narrow_contract/",
	"title": "Narrow contracts",
	"tags": [],
	"description": "Describes narrow-contract functions that do not work for all input values, and advantage of using them.",
	"content": "A program\u0026rsquo;s thread of execution can enter a \u0026ldquo;disappointing\u0026rdquo; state for two reasons:\n due to disappointing situation in the environment (operating system, external input), or due to a bug in the program.  The key to handling these disappointments correctly is to identify to which category they belong, and use the tools adequate for a given category. In this tutorial when we say \u0026ldquo;error\u0026rdquo; or \u0026ldquo;failure\u0026rdquo; we only refer to the first category. A bug is not an error.\nA bug is when a program is something else than what it is supposed to be. The correct action in that case is to change the program so that it is exactly what it is supposed to be. Unfortunately, sometimes the symptoms of a bug are only detected when the system is running and at this point no code changes are possible.\nIn contrast, a failure is when a correct function in a correct program reflects some disappointing behavior in the environment. The correct action in that case is for the program to take a control path different than usual, which will likely cancel some operations and will likely result in different communication with the outside world.\nSymptoms of bugs can sometimes be detected during compilation or static program analysis or at run-time when observing certain values of objects that are declared never to be valid at certain points. One classical example is passing a null pointer to functions that expect a pointer to a valid object:\nint f(int * pi) // expects: pi != nullptr { return *pi + 1; }  Passing a null pointer where it is not expected is so common a bug that tools are very good at finding them. For instance, static analyzers will usually detect it without even executing your code. Similarly, tools like undefined behavior sanitizers will compile a code as the one above so that a safety check is performed to check if the pointer is null, and an error message will be logged and program optionally terminated.\nMore, compilers can perform optimizations based on undefined behavior caused by dereferencing a null pointer. In the following code:\npair\u0026lt;int, int\u0026gt; g(int * pi) // expects: pi != nullptr { int i = *pi + 1; int j = (pi == nullptr) ? 1 : 0; return {i, j}; }  The compiler can see that if pi is null, the program would have undefined behavior. Since undefined behavior is required by the C++ standard to never be the programmer\u0026rsquo;s intention, the compiler assumes that apparently this function is never called with pi == nullptr. If so, j is always 0 and the code can be transformed to a faster one:\npair\u0026lt;int, int\u0026gt; g(int * pi) // expects: pi != nullptr { int i = *pi + 1; int j = 0; return {i, j}; }  Functions like the one above that declare that certain values of input parameters must not be passed to them are said to have a narrow contract.\nCompilers give you non-standard tools to tell them about narrow contracts, so that they can detect it and make use of it the same way as they are detecting invalid null pointers. For instance, if a function in your library takes an int and declares that the value of this int must never be negative. You can use __builtin_trap() available in GCC and clang:\nvoid h(int i) // expects: i \u0026gt;= 0 { if (i \u0026lt; 0) __builtin_trap(); // normal program logic follows ... }  This instruction when hit, causes the program to exit abnormally, which means:\n a debugger can be launched, static analyzer can warn you if it can detect a program flow that reaches this point, UB-sanitizer can log error message when it hits it.  Another tool you could use is __builtin_unreachable(), also available in GCC and clang:\nvoid h(int i) // expects: i \u0026gt;= 0 { if (i \u0026lt; 0) __builtin_unreachable(); // normal program logic follows ... }  This gives a hint to the tools: the programmer guarantees that the program flow will never reach to the point of executing it. In other words, it is undefined behavior if control reaches this point. Compiler and other tools can take this for granted. This way they can deduce that expression i \u0026lt; 0 will never be true, and they can further use this assumption to issue warnings or to optimize the code. UB-sanitizers can use it to inject a log message and terminate if this point is nonetheless reached.\nAllowing for some input values to be invalid works similarly to cyclic redundancy checks. It allows for the possibility to observe the symptoms of the bugs (not the bugs themselves), and if the symptom is revealed the hunt for the bug can start. This is not only tools that can now easily detect symptoms of bugs, but also humans during the code review. A reviewer can now say, \u0026ldquo;hey, function h() is expecting a non-negative value, but this i is actually -1; maybe you wanted to pass j instead?\u0026ldquo;.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/functions/",
	"title": "Functions",
	"tags": [],
	"description": "",
	"content": " Hooks Functions used to hook into the functionality of basic_result and basic_outcome.\n uint16_t spare_storage(const basic_result|basic_outcome *) noexcept Returns the sixteen bits of spare storage in the specified result or outcome.\n void hook_outcome_construction(T *, U \u0026amp;\u0026amp;) noexcept (Until v2.2.0) ADL discovered free function hook invoked by the implicit constructors of basic_outcome.\n void hook_outcome_construction(T *, U \u0026amp;\u0026amp;, V \u0026amp;\u0026amp;) noexcept (Until v2.2.0) ADL discovered free function hook invoked by the implicit constructors of basic_outcome.\n void hook_outcome_copy_construction(T *, U \u0026amp;\u0026amp;) noexcept (Until v2.2.0) ADL discovered free function hook invoked by the converting copy constructors of basic_outcome.\n void hook_outcome_copy_construction(T *, U \u0026amp;\u0026amp;, V \u0026amp;\u0026amp;) noexcept (Until v2.2.0) ADL discovered free function hook invoked by the converting copy constructors of basic_outcome.\n void hook_outcome_in_place_construction(T *, in_place_type_t\u0026lt;U\u0026gt;, Args \u0026amp;\u0026amp;...) noexcept (Until v2.2.0) ADL discovered free function hook invoked by the in-place constructors of basic_outcome.\n void hook_outcome_move_construction(T *, U \u0026amp;\u0026amp;) noexcept (Until v2.2.0) ADL discovered free function hook invoked by the converting move constructors of basic_outcome.\n void hook_outcome_move_construction(T *, U \u0026amp;\u0026amp;, V \u0026amp;\u0026amp;) noexcept (Until v2.2.0) ADL discovered free function hook invoked by the converting move constructors of basic_outcome.\n void hook_result_construction(T *, U \u0026amp;\u0026amp;) noexcept (Until v2.2.0) ADL discovered free function hook invoked by the implicit constructors of basic_result.\n void hook_result_copy_construction(T *, U \u0026amp;\u0026amp;) noexcept (Until v2.2.0) ADL discovered free function hook invoked by the converting copy constructors of basic_result.\n void hook_result_in_place_construction(T *, in_place_type_t\u0026lt;U\u0026gt;, Args \u0026amp;\u0026amp;...) noexcept (Until v2.2.0) ADL discovered free function hook invoked by the in-place constructors of basic_result.\n void hook_result_move_construction(T *, U \u0026amp;\u0026amp;) noexcept (Until v2.2.0) ADL discovered free function hook invoked by the converting move constructors of basic_result.\n void override_outcome_exception(basic_outcome\u0026lt;T, EC, EP, NoValuePolicy\u0026gt; *, U \u0026amp;\u0026amp;) noexcept Overrides the exception to something other than what was constructed.\n void set_spare_storage(basic_result|basic_outcome *, uint16_t) noexcept Sets the sixteen bits of spare storage in the specified result or outcome.\n Iostream Functions used to print, serialise and deserialise basic_result and basic_outcome.\n std::istream \u0026amp;operator\u0026gt;\u0026gt;(std::istream \u0026amp;, basic_outcome\u0026lt;T, EC, EP, NoValuePolicy\u0026gt; \u0026amp;) Deserialises a basic_outcome from a std::istream.\n std::istream \u0026amp;operator\u0026gt;\u0026gt;(std::istream \u0026amp;, basic_result\u0026lt;T, E, NoValuePolicy\u0026gt; \u0026amp;) Deserialises a basic_result from a std::istream.\n std::ostream \u0026amp;operator\u0026lt;\u0026lt;(std::ostream \u0026amp;, const basic_outcome\u0026lt;T, EC, EP, NoValuePolicy\u0026gt; \u0026amp;) Serialises a basic_outcome to a std::ostream.\n std::ostream \u0026amp;operator\u0026lt;\u0026lt;(std::ostream \u0026amp;, const basic_result\u0026lt;T, E, NoValuePolicy\u0026gt; \u0026amp;) Serialises a basic_result to a std::ostream.\n std::string print(const basic_outcome\u0026lt;T, EC, EP, NoValuePolicy\u0026gt; \u0026amp;) Returns a string containing a human readable rendition of the basic_outcome.\n std::string print(const basic_result\u0026lt;T, E, NoValuePolicy\u0026gt; \u0026amp;) Returns a string containing a human readable rendition of the basic_result.\n Policy Functions used to customise how the policy classes operate.\n auto basic_outcome_failure_exception_from_error(const EC \u0026amp;) ADL discovered free function synthesising an exception type from an error type, used by the .failure() observers.\n decltype(auto) error_code(T \u0026amp;\u0026amp;) Extracts a boost::system::error_code or std::error_code from the input via ADL discovery of a suitable make_error_code(T) function.\n decltype(auto) exception_ptr(T \u0026amp;\u0026amp;) Extracts a boost::exception_ptr or std::exception_ptr from the input via ADL discovery of a suitable make_exception_ptr(T) function.\n void outcome_throw_as_system_error_with_payload(BoostErrorCodeEnum \u0026amp;\u0026amp;) Specialisation of outcome_throw_as_system_error_with_payload() for input types where boost::system::is_error_code_enum\u0026lt;BoostErrorCodeEnum\u0026gt; or boost::system::is_error_condition_enum\u0026lt;BoostErrorCodeEnum\u0026gt; is true.\n void outcome_throw_as_system_error_with_payload(ErrorCodeEnum \u0026amp;\u0026amp;) Specialisation of outcome_throw_as_system_error_with_payload() for input types where std::is_error_code_enum\u0026lt;ErrorCodeEnum\u0026gt; or std::is_error_condition_enum\u0026lt;ErrorCodeEnum\u0026gt; is true.\n void outcome_throw_as_system_error_with_payload(const boost::system::error_code \u0026amp;) Specialisation of outcome_throw_as_system_error_with_payload() for boost::system::error_code.\n void outcome_throw_as_system_error_with_payload(const std::error_code \u0026amp;) Specialisation of outcome_throw_as_system_error_with_payload() for std::error_code.\n auto failure(T \u0026amp;\u0026amp;, ...) Returns appropriate type sugar for constructing an unsuccessful result or outcome.\n auto success(T \u0026amp;\u0026amp;, ...) Returns appropriate type sugar for constructing a successful result or outcome.\n bool try_operation_has_value(X) Default implementation of try_operation_has_value(X) ADL customisation point for OUTCOME_TRY.\n decltype(auto) try_operation_extract_value(X) Default implementation of try_operation_extract_value(X) ADL customisation point for OUTCOME_TRY.\n decltype(auto) try_operation_return_as(X) Default implementation of try_operation_return_as(X) ADL customisation point for OUTCOME_TRY.\n std::error_code error_from_exception(std::exception_ptr \u0026amp;\u0026amp;ep = std::current_exception(), std::error_code not_matched = std::make_error_code(std::errc::resource_unavailable_try_again)) noexcept Returns an error code matching a thrown standard library exception.\n void strong_swap(bool \u0026amp;all_good, T \u0026amp;a, T \u0026amp;b) Tries to perform a strong guarantee swap.\n void try_throw_std_exception_from_error(std::error_code ec, const std::string \u0026amp;msg = std::string{}) Try to throw a standard library exception type matching an error code.\n "
},
{
	"uri": "https://ned14.github.io/outcome/experimental/worked-example-long/implicit_conversion/",
	"title": "Implicit conversion",
	"tags": [],
	"description": "",
	"content": "Back in The payload, we mentioned that there was no default implicit conversion of file_io_error (status_code\u0026lt;_file_io_error_domain\u0026gt;) to error, as error is too small to hold _file_io_error_domain::value_type.\nWe can tell the framework about available implicit conversions by defining an ADL discovered free function make_status_code() which takes our custom status code as input, and returns an error:\n// Now tell `error` how it can implicitly construct from `file_io_error`. // This is done by us defining a free function called `make_status_code()` // which is discovered using ADL. `error` is an alias to the refinement // `status_code\u0026lt;erased\u0026lt;intptr_t\u0026gt;\u0026gt;` which is a status code whose value type // has been erased into an `intptr_t`. `status_code\u0026lt;erased\u0026lt;intptr_t\u0026gt;\u0026gt;` // (i.e. `error`) are move bitcopying (P1029) i.e. they are move-only // types whose move operation is defined to leave the source in the same // representation as a default constructed instance, and for whose // non-trivial destructor when called upon a default constructed instance // is guaranteed to do nothing. inline outcome_e::system_code make_status_code(file_io_error v) { // `make_nested_status_code()` dynamically allocates memory to store an  // instance of `file_io_error`, then returns a status code whose domain  // specifies that its value type is a pointer to `file_io_error`. The  // domain is a templated instance which indirects all observers of the  // status code to the pointed-to status code.  //  // Note that the status code returned\u0026#39;s value type is a pointer, which  // by definition fits into `intptr_t` and is trivially copyable.  // Therefore `system_code` (which is also a type alias to  // `status_code\u0026lt;erased\u0026lt;intptr_t\u0026gt;\u0026gt;`) is happy to implicitly construct  // from the status code returned by `make_nested_status_code()`.  return make_nested_status_code(std::move(v)); } View this code on Github We are now ready to use Experimental Outcome!\n"
},
{
	"uri": "https://ned14.github.io/outcome/experimental/outcome/",
	"title": "Tying it all together",
	"tags": [],
	"description": "",
	"content": " Firstly let\u0026rsquo;s alias a more convenient form of status_result:\ntemplate \u0026lt;classT, classE = outcome_e::error\u0026gt; using result = // outcome_e::status_result\u0026lt;T, E, outcome_e::policy::default_status_result_policy\u0026lt;T, E\u0026gt;\u0026gt;; View this code on Github (The defaulting of default_result_policy is superfluous, it\u0026rsquo;s already the default)\nWhat follows now is very standard Outcome code. Indeed, it would compile just fine under standard Outcome with only a few typedefs.\nresult\u0026lt;file_handle, file_io_error\u0026gt; open_file(const char *path) // models throws(file_io_error) { file_handle ret(::fopen(path, \u0026#34;r\u0026#34;)); if(ret) return ret; return file_io_error({errno, __LINE__, __FILE__}); } result\u0026lt;void\u0026gt; open_resource() // models throws(std::error) { for(;;) { result\u0026lt;file_handle, file_io_error\u0026gt; r = open_file(\u0026#34;some file\u0026#34;); if(r) break; file_io_error e = r.error(); if(e != outcome_e::errc::resource_unavailable_try_again) { // NOTE this implicitly converts from `file_io_error` to `error` via the  // `make_status_code()` free function customisation point defined above.  return e; } } // success continues here ...  return outcome_e::success(); } int main(void) { result\u0026lt;void\u0026gt; r = open_resource(); if(r) printf(\u0026#34;Success!\\n\u0026#34;); else { auto e = std::move(r).error(); // A quick demonstration that the indirection works as indicated  printf(\u0026#34;Returned error has a code domain of \u0026#39;%s\u0026#39;, a message of \u0026#39;%s\u0026#39;\\n\u0026#34;, e.domain().name().c_str(), e.message().c_str()); printf(\u0026#34;\\nAnd semantically comparing it to \u0026#39;errc::no_such_file_or_directory\u0026#39; = %d\\n\u0026#34;, e == outcome_e::errc::no_such_file_or_directory); } } View this code on Github And running this program yields:\nReturned error has a code domain of 'file i/o error domain', a message of 'No such file or directory (c:\\users\\ned\\documents\\boostish\\outcome\\doc\\src\\snippets\\experimental_status_code.cpp:195)' And semantically comparing it to 'errc::no_such_file_or_directory' = 1  Conclusion Once you get used to \u0026lt;system_error2\u0026gt; and the fact that any result with E = error is always move-only, using experimental Outcome is just like using normal Outcome. Except that codegen will be better, custom domains are safe to use in headers, semantic comparisons have guaranteed complexity bounds, and build times are much reduced.\nWhat\u0026rsquo;s not to like? :)\nFinally, if you have feedback on using experimental Outcome which you think would be of use to the standards committee when evaluating possible implementations of P0709 Zero overhead exceptions: Throwing values, please do get in touch! This especially includes successful experiences!!!\n"
},
{
	"uri": "https://ned14.github.io/outcome/changelog/",
	"title": "Changelog",
	"tags": [],
	"description": "",
	"content": " v2.2.12 ? (Boost 1.88) [release] Enhancements: Bug fixes:  The Android build had become broken, fixed.  v2.2.11 12th December 2024 (Boost 1.87) [release] Enhancements:  Outcome.Experimental has had C representation support since the beginning, however it had been mainly intended that C++ would originate Results, they would pass through C, and back into C++. It hadn\u0026rsquo;t really been expected that C would want to do much with Results other than inspect them for happy or sad path.  It turns out there is more demand than expected for a more functional Result from within C, so this release adds the power to create Results in success and two types of failure, semantic comparison of Results, and printing of Result messages. You can also wrap a C enum into a quick status code from enum, allowing easy custom C error coding from 100% within C.\nThe documentation for the C support has been updated to reflect the new facilities.\nBug fixes:  This was fixed in Standalone Outcome in the last release, but the fix came too late for Boost.Outcome which ended up shipping with inline GDB pretty printers with the wrong escaping which caused failure to load.  v2.2.10 14th August 2024 (Boost 1.86) [release] Enhancements:  Something I\u0026rsquo;ve been meaning to do for far too long now is make the GDB pretty printers auto-loading so you don\u0026rsquo;t have to set up .gdbinit. This is now done. I also improved the pretty printers to also pretty print the C result type which can be very useful if working with that type, as it will print the error message in GDB.  Experimental Outcome\u0026rsquo;s status_code has also gained its own auto-loading GDB pretty printer with display of strerror() if the code domain is POSIX or generic.\nBug fixes:  The status enumeration used to track state internally did not list all possible enum values. This caused static analysers to complain.  v2.2.9 15th April 2024 (Boost 1.85) [release] Enhancements: #293 - Some users wished that Outcome would be clean with -Wpedantic, this is now turned on for the test suite.\n#294 - All use of assert() has been replaced with OUTCOME_ASSERT, which can be user overridden at compile time.\n#295 - In git commit 12b14e1533848e9a0f7f3c38e41da0ee4e819770 (Aug 11 2022) status code had its paths changed due to its headers not previously having the right path convention. It was not realised at the time that in Boost.Outcome this resulted in \u0026lt;boost/outcome/experimental/status-code/status-code/headers.hpp\u0026gt; which is not desirable. This has now been remedied to remove the double status-code, which will obviously break any Boost.Outcome code which relies on the double status-code. Standalone Outcome is unaffected.\nv2.2.8 13th December 2023 (Boost 1.84) [release] Enhancements:  cmake 3.9 is now the minimum required for standalone Outcome. This fixes a long standing cmake issue with probing for standard library facilities. cmake 3.9 is what RHEL7 ships with, when RHEL7 EOLs we may raise the minimum cmake version at that point.  Bug fixes:  There was a bug in the Outcome C++ coroutine awaitables whereby we were over eagerly resuming execution of coroutines which return one of our awaitables. It is surprising how many years have passed before this was noticed, but it is now fixed. It is believed that this has been fixed without affecting ABI stability, however mixing old Outcome and new Outcome in the same binary without recompiling all the C++ coroutine code to use new Outcome will not fix the bug.  #291 - A Result or Outcome with void value type and move-only non-value type was only usable in const use cases, due to the lack of provision of non-const member functions in relevant observers injection layers for the void specialisation. The missing non-const member functions have now been added.\nv2.2.7 13th August 2023 (Boost 1.83) [release] Enhancements:  Update the list of known compiler issues in the docs.\n Update Outcome.Experimental to match latest changes requested of status_code by WG21. This as usual will cause minor breakage due to LEWG renaming of things.\n Outcome previously took addresses of things not using std::addressof(), and until now nobody complained because custom operator\u0026amp; which doesn\u0026rsquo;t return an address is an abomination not used in much modern C++. But finally someone did complain, so for both normal Outcome and Experimental.Outcome, if you set OUTCOME_USE_STD_ADDRESSOF = 1, Outcome will use std::addressof()\n  Bug fixes: #273 - Changes to other Boost libraries had caused Boost.Outcome\u0026rsquo;s test suite to fail to compile for some compiler and C++ language configurations in recent releases. Thanks to work contributed by @alandefreitas and @pdimov, Boost.Outcome now CI tests a wide range of compilers and configurations and it is believed all those corner case issues have been fixed or worked around, for the compilers and configurations within that CI matrix.\nStandalone Outcome\u0026rsquo;s test suite was never affected, as it did not have Boost changing underneath it. Nevertheless, a few of the compiler parse bug workarounds will have improved compatibility there too for atyical toolchain choices.\n Experimental.Outcome now supports big endian architectures. Implementation for them simply wasn\u0026rsquo;t done before under the assumption that nobody would be using Experimental.Outcome on big endian architectures. Turns out that was a wrong assumption!  v2.2.6 24th March 2023 (Boost 1.82) [release] Enhancements:  Update to latest status-code in Experimental.Outcome, which relocates its header files and may cause some end user inclusions to need path changes.  Bug fixes:  Latest status-code fixes a number of nasty bugs, some mild build breakage in Experimental.Outcome may occur as a result. See its commit log for more information.  v2.2.4 11th August 2022 (Boost 1.80) [release] Enhancements:  Update to latest status-code in Experimental.Outcome, which has some breaking changes and important bug fixes.\n Add generator\u0026lt;T, Executor = void\u0026gt; to coroutine awaitables.\n Add optional Executor template parameter to all Outcome awaitable types for improved compatibility with third party software such as ASIO.\n To Experimental.Outcome add clone() for basic_result and basic_outcome types whose EC is a status_code. Erased status codes are move-only which makes the Result/Outcome type move-only, but they provide a cloning function, so this convenience function both clones the status code and propagates the spare storage so stack backtraces etc are also cloned.\n Add type constraints to success() and failure() to disable them if they aren\u0026rsquo;t available.\n Work around a bug in GCC\u0026rsquo;s C++ Coroutines implementation whereby one gets an ICE from gimplify_expr in any OUTCOME_CO_TRY taking even a mildly complex expression, which obviously is a showstopper. The work around assigns the failure type to a stack temporary before co_return-ing that temporary. Thanks to RVO pre-17 and copy elision since, this should add no runtime overhead.\n  Bug fixes:  #261 Move assignable with move constructible not available did not work with void.  v2.2.3 17th March 2022 (Boost 1.79) [release] Enhancements:  Standalone Outcome permanently locks ABI to v2.2.3 release From this release onwards, you are guaranteed that any code compiled with v2.2.3 Outcome or newer will link without issue with any code compiled with a different version of Outcome after v2.2.3. As a result, OUTCOME_UNSTABLE_VERSION is no longer defined by default, and therefore OUTCOME_V2_NAMESPACE is now hard coded to outcome_v2 rather than a namespace which permutes per commit.  Bug fixes:  #255 Fix enabling of move assignable was not calculated correctly.  v2.2.2 8th December 2021 (Boost 1.78) [release] Enhancements:  #255 Restore Experimental Outcome constexpr compatibility in C++ 20 which was an undocumented property of the Outcome v2.1 series, and which had been dropped in the v2.2 series. GCC Coroutines support Coroutine support in GCCs after 10 is now correctly detected.  Bug fixes:  None.  v2.2.1 13th August 2021 (Boost 1.77) [release] Bug fixes:  #251 Fix failure to compile Boost.Outcome when the compiler declares support for C++ modules.\n Don\u0026rsquo;t use [[likely]] in GCCs before 9.\n #251 Make support for C++ modules opt-in.\n  v2.2.0 16th April 2021 (Boost 1.76) [release]  BREAKING CHANGE As announced for a year and three Boost releases, Outcome v2.2 became the default, replacing v2.1. All v2.1 Outcome code will need to be upgraded as described in the v2.1 =\u0026gt; v2.2 upgrade guide. This branch has a number of major breaking changes to Outcome v2.1, see the list of v2.2 major changes.  Enhancements:  VS2019.8 compatibility VS2019.8 changed how to enable Coroutines, which caused Outcome to not compile on that compiler. #237 If on C++ 20, we now use C++ 20 [[likely]] instead of compiler-specific markup to indicate when TRY has likely success or failure. BREAKING CHANGE #247 Previously the value of spare_storage(const basic_result|basic_outcome *) noexcept was not propagated over OUTCOME_TRY, which causes things like stack backtraces captured at the point of construction of an errored result to get dropped at every TRY point. This has been fixed by adding an optional spare_storage to success_type\u0026lt;T\u0026gt; and failure_type\u0026lt;T\u0026gt; , as well as to auto success(T \u0026amp;\u0026amp;, ...) and auto failure(T \u0026amp;\u0026amp;, ...) .\nYou should not notice this in your code, except that where before spare storage values did not propagate through TRY, now they do, which is a breaking change.\n  Bug fixes:  BREAKING CHANGE #244 It came as a shock to learn that OUTCOME_TRY had been broken since the inception of this library for certain corner case code:\noutcome::result\u0026lt;Foo\u0026gt; get_foo(); outcome::result\u0026lt;Foo\u0026gt; filter1(outcome::result\u0026lt;Foo\u0026gt; \u0026amp;\u0026amp;); outcome::result\u0026lt;Foo\u0026gt; \u0026amp;\u0026amp; filter2(outcome::result\u0026lt;Foo\u0026gt; \u0026amp;\u0026amp;); // This works fine, and always has OUTCOME_TRY(auto v, filter1(get_foo())) // This causes UB due to result\u0026lt;Foo\u0026gt; being destructed before move of value into v OUTCOME_TRY(auto v, filter2(get_foo()))  Whilst reference passthrough filter functions are not common, they can turn up in highly generic code, where destruction before copy/move is not helpful.\nThe cause is that TRY used to work by binding the result of the expression to an auto \u0026amp;\u0026amp;unique, testing if that unique if successful or not, and if successful then moving from unique.value() into the user\u0026rsquo;s output variable. If the expression returned is a prvalue, the Result\u0026rsquo;s lifetime is extended by the bound reference to outside of the statement, and all is good. If the expression returned is an xvalue or lvalue, then the lifetime extension does not exceed that of the statement, and the Result is destructed after the semicolon succeeding the assignment to auto \u0026amp;\u0026amp;unique.\nThis bug has been fixed by TRY deducing the value category of its input expression as follows:\n prvalues =\u0026gt; auto unique = (expr) (breaking change) xvalue =\u0026gt; auto unique = (expr) (breaking change) lvalue =\u0026gt; auto unique = (expr) (breaking change)  This ensures that xvalue and lvalue inputs do not cause unhelpfully early lifetime end, though it does silently change the behaviour of existing code which relied on rvalues and lvalues being passed through, as a new construct-move-destruct or construct-copy-destruct cycle is introduced to where there was none before. Also, before C++ 17, there is now an added copy/move for prvalue inputs, which does not affect runtime codegen due to Return Value Optimisation (RVO), but does cause Results containing non-copying non-moving types to fail to compile, which is a breaking change from beforehand.\nIf one wishes rvalues or lvalues to be passed through, one can avail of a new TRY syntax based on preprocessor overloading:\n OUTCOME_TRY((refspec, varname), expr) OUTCOME_TRYV2(refspec, expr)  Here refspec is the storage to be used for both the internal temporary unique, AND varname. So if you write:\nFoo \u0026amp;\u0026amp;foo; OUTCOME_TRY((auto \u0026amp;\u0026amp;, v), filter2(foo))  \u0026hellip; then the internal unique is declared as auto \u0026amp;\u0026amp;unique = (filter2(foo)), and the output variable is declared as auto \u0026amp;\u0026amp;v = std::move(unique).assume_value(). This passes through the rvalue referencing, and completely avoids copies and moves of Foo. If you wish to not extract the value but also specify unique storage, there is a new OUTCOME_TRYV2(refspec, expr).\nMy thanks to KamilCuk from https://stackoverflow.com/questions/66069152/token-detection-within-a-c-preprocessor-macro-argument for all their help in designing the new overloaded TRY syntax. My thanks also to vasama for reporting this issue and working through how best to fix it with me.\n #249 The preprocessor logic for choosing when to use bool with concept on GCC was yet again refactored. This should fix those choices of GCC configuration which caused failure due to the wrong combination being chosen.\n  v2.1.5 11th December 2020 (Boost 1.75) [release] Enhancements:  The ADL discovered event hooks have been replaced with policy-specified event hooks instead This is due to brittleness (where hooks would quietly self-disable if somebody changed something), compiler bugs (a difference in compiler settings causes the wrong hooks, or some but not all hooks, to get discovered), and end user difficulty in using them at all. The policy-specified event hooks can be told to default to ADL discovered hooks for backwards compatibility: set OUTCOME_ENABLE_LEGACY_SUPPORT_FOR to less than 220 to enable emulation. Improve configuring OUTCOME_GCC6_CONCEPT_BOOL Older GCCs had boolean based concepts syntax, whereas newer GCCs are standards conforming. However the precise logic of when to use legacy and conforming syntax was not well understood, which caused Outcome to fail to compile depending on what options you pass to GCC. The new logic always uses the legacy syntax if on GCC 8 or older, otherwise we use conforming syntax if and only if GCC is in C++ 20 mode or later. This hopefully will resolve the corner case build failures on GCC.  Bug fixes:  Boost.Outcome should now compile with BOOST_NO_EXCEPTIONS defined Thanks to Emil, maintainer of Boost.Exception, making a change for me, Boost.Outcome should now compile with C++ exceptions globally disabled. You won\u0026rsquo;t be able to use boost::exception_ptr as it can\u0026rsquo;t be included if C++ exceptions are globally disabled. #236 In the Coroutine support the final_suspend() was not noexcept, despite being required to be so in the C++ 20 standard. This has been fixed, but only if your compiler implements noop_coroutine. Additionally, if noop_coroutine is available, we use the much more efficient coroutine handle returning variant of await_suspend() which should significantly improve codegen and context switching performance.  v2.1.4 14th August 2020 (Boost 1.74) [release] Enhancements:  BREAKING CHANGE void results and outcomes no longer default construct types during explicit construction Previously if you explicitly constructed a result\u0026lt;T\u0026gt; from a non-errored result\u0026lt;void\u0026gt;, it default constructed T. This was found to cause unhelpful surprise, so it has been disabled. New macro OUTCOME_ENABLE_LEGACY_SUPPORT_FOR The macro OUTCOME_ENABLE_LEGACY_SUPPORT_FOR can be used to enable aliasing of older naming and features to newer naming and features when using a newer version of Outcome. Concepts now have snake case style naming instead of camel case style When Outcome was first implemented, it was thought that C++ 20 concepts were going to have camel case style. This was changed before the C++ 20 release, and Outcome\u0026rsquo;s concepts have been renamed similarly. This won\u0026rsquo;t break any code in Outcome v2.1, as compatibility aliases are provided. However code compiled against Outcome v2.2 will need to be upgraded, unless OUTCOME_ENABLE_LEGACY_SUPPORT_FOR is set to less than 220. Concepts now live in OUTCOME_V2_NAMESPACE::concepts namespace Previously concepts lived in the convert namespace, now they live in their own namespace. New concepts basic_result\u0026lt;T\u0026gt; and basic_outcome\u0026lt;T\u0026gt; added End users were finding an unhelpful gap in between is_basic_result\u0026lt;T\u0026gt; and value_or_error\u0026lt;T\u0026gt; where they wanted a concept that matched types which were basic_result, but not exactly one of those. Concepts filling that gap were added. Operation TRY works differently from Outcome v2.2 onwards This is a severely code breaking change which change the syntax of how one uses OUTCOME_TRY(). A regular expression suitable for upgrading code can be found in the list of changes between Outcome v2.1 and v2.2.  Bug fixes:  #224 The clang Apple ships in Xcode 11.4 (currently the latest) has not been patched with the fixes to LLVM clang that fix noexcept(std::is_constructible\u0026lt;T, void\u0026gt;) failing to compile which I originally submitted years ago. So give up waiting on Apple to fix their clang, add a workaround to Outcome. Use of void in T or E caused noexcept(false) Direct traits examination of void was causing nothrow detection to return false, fixed. Spare storage could not be used from within no-value policy classes Due to an obvious brain fart when writing the code at the time, the spare storage APIs had the wrong prototype which prevented them working from within policy classes. Sorry.  v2.1.3 29th April 2020 (Boost 1.73) [release] Enhancements:  Performance of Outcome-based code compiled by clang has been greatly improved The previous implementation of Outcome\u0026rsquo;s status bitfield confused clang\u0026rsquo;s optimiser, which caused low quality codegen. Unlike most codegen issues, this was noticeably in empirical benchmarks of real world code, as was shown by P1886 Error speed benchmarking.\nThe safe part of the better_optimisation Outcome v2.2.0 future branch was merged to Outcome v2.1.3 which includes a new status bitfield implementation. This appears to not confuse clang\u0026rsquo;s optimiser, and clang 9 produces code which routinely beats GCC 9\u0026rsquo;s code for various canned use cases.\n Precompiled headers are automatically enabled on new enough cmake\u0026rsquo;s for standalone Outcome If on cmake 3.16 or later, its new precompiled headers build support is used to tell consumers of the outcome::hl cmake target to precompile Outcome, if and only if outcome_IS_DEPENDENCY is false. outcome_IS_DEPENDENCY is set by Outcome\u0026rsquo;s CMakeLists.txt if it detects that it was included using add_subdirectory(), so for the vast majority of Outcome end users, the use of precompiled headers will NOT be enabled.\nExported targets do NOT request precompilation of headers, as it is assumed that importers of the Outcome cmake targets will configure their own precompiled headers which incorporate Outcome.\n Installability is now CI tested per commit Due to installability of standalone Outcome (e.g. make install) breaking itself rather more frequently than is ideal, installability is now tested on CI per commit.\n Coroutines support has been documented The coroutines support added in v2.1.2 has now been properly documented.\n  Bug fixes:  #214 Newer Concepts implementing compilers were unhappy with the early check for destructibility of T and E, so removed template constraints, falling back to static assert which runs later in the type instantiation sequence. #215 For standalone Outcome, CMAKE_TOOLCHAIN_FILE is now passed through during dependency superbuild. This should solve build issues for some embedded toolchain users. #220 A false positive undefined behaviour sanitiser failure in some use cases of Experimental Outcome was worked around to avoid the failure message. #221 Restored compatibility with x86 on Windows, which was failing with link errors. It was quite surprising that this bug was not reported sooner, but obviously almost nobody is using Outcome with x86 on Windows. #223 Fix a segfault in Debug builds only when cloning a status_code_ptr in Experimental.Outcome only.  v2.1.2 11th December 2019 (Boost 1.72) [release] Enhancements:  Improved compatibility with cmake tooling Standalone outcome is now make install-able, and cmake find_package() can find it. Note that you must separately install and find_package() Outcome\u0026rsquo;s dependency, quickcpplib, else find_package() of Outcome will fail. Non-permissive parsing is now default in Visual Studio The default targets in standalone Outcome\u0026rsquo;s cmake now enable non-permissive parsing. This was required partially because VS2019 16.3\u0026rsquo;s quite buggy Concepts implementation is unusuable in permissive parsing mode. Even then, lazy ADL two phase lookup is broken in VS2019 16.3 with /std:latest, you may wish to use an earlier language standard. Breaking change! The git submodule mechanism used by standalone Outcome of specifying dependent libraries has been replaced with a cmake superbuild of dependencies mechanism instead. Upon cmake configure, an internal copy of quickcpplib will be git cloned, built and installed into the build directory from where an internal find_package() uses it. This breaks the use of the unconfigured Outcome repo as an implementation of Outcome, one must now do one of:  Add Outcome as subdirectory to cmake build. Use cmake superbuild (i.e. ExternalProject_Add()) to build and install Outcome into a local installation. Use one of the single header editions.  Breaking change! For standalone Outcome, the current compiler is now checked for whether it will compile code containing C++ Concepts, and if it does, all cmake consumers of Outcome will enable C++ Concepts. Set the cmake variable CXX_CONCEPTS_FLAGS to an empty string to prevent auto detection and enabling of C++ Concepts support occurring. OUTCOME_TRY operation now hints to the compiler that operation will be successful P1886 Error speed benchmarking showed that there is considerable gain in very small functions by hinting to the compiler whether the expression is expected to be successful or not. OUTCOME_TRY previously did not hint to the compiler at all, but now it does. A new suite of macros OUTCOME_TRY_FAILURE_LIKELY hint to the compiler that failure is expected. If you wish to return to the previously unhinted behaviour, define OUTCOME_TRY_LIKELY(expr) to (!!expr). #199 Support for C++ Coroutines has been added. This comes in two parts, firstly there is now an OUTCOME_CO_TRY() operation suitable for performing the TRY operation from within a C++ Coroutine. Secondly, in the header outcome/coroutine_support.hpp there are implementations of eager\u0026lt;OutcomeType\u0026gt; and lazy\u0026lt;OutcomeType\u0026gt; which let you more naturally and efficiently use basic_result or basic_outcome from within C++ Coroutines \u0026ndash; specifically, if the result or outcome will construct from an exception pointer, exceptions thrown in the coroutine return an errored or excepted result with the thrown exception instead of throwing the exception through the coroutine machinery (which in current compilers, has a high likelihood of blowing up the program). Both eager\u0026lt;T\u0026gt; and lazy\u0026lt;T\u0026gt; can accept any T as well. Both have been tested and found working on VS2019 and clang 9. #210 make_error_code() and make_exception_ptr() are now additionally considered for compatible copy and move conversions for basic_result\u0026lt;\u0026gt;. This lets you construct a basic_result\u0026lt;T, E\u0026gt; into a basic_result\u0026lt;T, error_code\u0026gt;, where E is a custom type which has implemented the ADL discovered free function error_code make_error_code(E), but is otherwise unrelated to error_code. The same availability applies for exception_ptr with make_exception_ptr() being the ADL discovered free function. basic_outcome\u0026lt;\u0026gt; has less support for this than basic_result\u0026lt;\u0026gt; in order to keep constructor count down, but it will accept via this mechanism conversions from basic_result\u0026lt;\u0026gt; and failure_type\u0026lt;\u0026gt;.  Bug fixes:  #184 The detection of [[nodiscard]] support in the compiler was very mildly broken.  v2.1.1 19th August 2019 (Boost 1.71) [release] Enhancements:  #184 As per request from Boost release managers, relocated version.hpp and revision.hpp into detail, and added the Boost licence boilerplate to the top of every source file which was missing one (I think). Also took the opportunity to run the licence restamping script over all Outcome, so copyright dates are now up to date. #185 Add FAQ item explaining issue #185, and why we will do nothing to fix it right now. #189 Refactored the OUTCOME_TRY implementation to use more clarified customisation points capable of accepting very foreign inputs. Removed the std::experimental::expected\u0026lt;T, E\u0026gt; specialisations, as those are no longer necessary. Fixed the documentation for the customisation points which previously claimed that they are ADL discovered, which they are not. Added a recipe describing how to add in support for foreign input types. #183 Added a separate motivation/plug_error_code specifically for Boost.  Bug fixes:  - OUTCOME_VERSION_MINOR hadn\u0026rsquo;t been updated to 1. #181 Fix issue #181 where Outcome didn\u0026rsquo;t actually implement the strong swap guarantee, despite being documented as doing so. #190 Fix issue #190 in Boost edition where unit test suite was not runnable from the Boost release distro. #182 Fix issue #182 where trait::is_exception_ptr_available\u0026lt;T\u0026gt; was always true, thus causing much weirdness, like not printing diagnostics and trying to feed everything to make_exception_ptr(). #194 Fix issue #192 where the std::basic_outcome_failure_exception_from_error() was being defined twice for translation units which combine standalone and Boost Outcome\u0026rsquo;s.  v2.1 12th Apr 2019 (Boost 1.70) [release]  #180\n success() and failure() now produce types marked [[nodiscard]].  include/outcome/outcome.natvis is now namespace permuted like the rest of Outcome, so debugging Outcome based code in Visual Studio should look much prettier than before.\n #162\n .has_failure() was returning false at times when it should have returned true.  #152\n GCC 5 no longer can compile Outcome at all due to https://stackoverflow.com/questions/45607450/gcc5-nested-variable-template-is-not-a-function-template. Added explicit version trap for GCC 5 to say it can not work. Note this is not a breaking change, GCC 5 was never supported officially in any v2 Outcome.  #150\n BREAKING CHANGE result\u0026lt;T, E\u0026gt;, boost_result\u0026lt;T, E\u0026gt; and std_result\u0026lt;T, E\u0026gt; no longer implement hard UB on fetching a value from a valueless instance if E is a UDT, they now fail to compile with a useful error message. If you wish hard UB, use unchecked\u0026lt;T, E\u0026gt;, boost_unchecked\u0026lt;T, E\u0026gt; or std_unchecked\u0026lt;T, E\u0026gt; instead.  #140\n Fixed a nasty corner case bug where value type\u0026rsquo;s without a copy constructor but with a move constructor would indicate via traits that copy construction was available. Thanks to Microsoft\u0026rsquo;s compiler team for reporting this issue.  Added experimental status_result and status_outcome based on experimental status_code.\n Boost edition is now 100% Boost, so defaults for result and outcome are boost::system::error_code::errc_t and boost::exception_ptr. Moreover, the test suite in the Boost edition now exclusively tests the Boost edition. One can, of course, freely use the standalone edition with Boost, and the Boost edition with std types.\n Renamed ADL discovered customisation point throw_as_system_error_with_payload() to outcome_throw_as_system_error_with_payload().\n #135\n Added much clearer compile failure when user tries result\u0026lt;T, T\u0026gt; or outcome where two or more types are identical. Thanks to Andrzej Krzemie≈Ñski for suggesting a technique which combines SFINAE correctness with the remaining ability for result\u0026lt;T, T\u0026gt; etc to be a valid type, but not constructible.  #67\n Fixed one of the oldest long open bugs in Outcome, that the noexcept unit tests failed on OS X for an unknown reason.  #115\n Outcome did not construct correctly from failure_type.  Inexplicably outcome\u0026rsquo;s error + exception constructor had been removed. Nobody noticed during the Boost peer review, which is worrying seeing as that constructor is needed for one of the main advertised features to Boost!\n #107 and #116\n operator== and operator!= now become disabled if the value, error and exception types do not implement the same operator. Relatedly, both comparison operators simply didn\u0026rsquo;t work right. Fixed.  #109\n swap() now has correct noexcept calculation and now correctly orders the swaps to be whichever is the throwing swap first.  Added reference dump of v2.1 ABI so we can check if ABI breakage detection works in the next set of changes, plus Travis job to check ABI and API compatibility per commit.\n #124\n OUTCOME_TRY is now overloaded and selects void or auto edition according to input parameter count.  #120\n Fix generation of double underscored temporary variables in OUTCOME_UNIQUE_NAME, which is UB.  #110\n Separated result from its hard coded dependency on the \u0026lt;system_error\u0026gt; header. Renamed result and outcome to basic_result and basic_outcome. Renamed result.hpp into basic_result.hpp. Moved \u0026lt;system_error\u0026gt; and \u0026lt;exception\u0026gt; dependent code into new std_result.hpp and std_outcome.hpp header files. Added boost_result.hpp and boost_outcome.hpp which use Boost.System and Boost.Exception (these are result.hpp and outcome.hpp in the Boost edition).   v2.0 18th Jan 2018 [release]  Boost peer review edition. This is what was reviewed. Changelog from v1 can be found in the release notes for this release.  "
},
{
	"uri": "https://ned14.github.io/outcome/tutorial/essential/conventions/",
	"title": "Conventions",
	"tags": ["best-practice", "conventions", "idioms"],
	"description": "Why you should avoid custom `E` types in public APIs.",
	"content": " You now know everything you need to get started with using Outcome immediately.\nThe initial temptation for most beginners will be to use a bespoke strongly typed enumeration on a case by case basis i.e. a \u0026ldquo;once off\u0026rdquo; custom E type. This is usually due to experience in other languages with sum types e.g. Rust, Haskell, Swift etc.\nHowever this is C++! Not Rust, not Swift, not Haskell! I must caution you to always avoid using custom E types in public APIs. The reason is that every time library A using custom E1 type must interface with library B using custom E2 type, you must map between those E1 and E2 types.\nThis is information lossy, i.e. fidelity of failure gets lost after multiple translations. It involves writing, and then maintaining, a lot of annoying boilerplate. It leaks internal implementation detail, and fails to separate concerns. And one cannot use OUTCOME_TRYV(expr)/OUTCOME_TRY(expr) if there is no convertibility between E types.\nThe C++ 11 standard library, and Boost, specifically ships \u0026lt;system_error\u0026gt; for the purpose of wrapping up individual custom E types into a generic framework, where disparate custom E types can discover and interact with one another. That ships with every C++ compiler.\nFor all these reasons, this is why result and outcome default the EC type to error code. You should leave that default alone where possible.\ntl;dr; Please plug your library into std::error_code, or equivalent, and do not expose custom E types in ANY public API. result and outcome default EC to an error code for good reason.\n"
},
{
	"uri": "https://ned14.github.io/outcome/tutorial/advanced/interop/",
	"title": "Interoperation",
	"tags": [],
	"description": "Interoperating with std::expected&lt;T, E&gt; and other ValueOrError concept matching types.",
	"content": "This is the final section of the tutorial, and it is unavoidably quite lengthy as we are going to tie together all of the material covered in the tutorial so far into a single, unified, application of Outcome\u0026rsquo;s facilities.\nOne thing which Outcome solves \u0026ndash; and which alternatives do not \u0026ndash; is how to non-intrusively tie together multiple third party libraries, each using Outcome \u0026ndash; or some other T|E implementatation like  P0323 std::expected\u0026lt;T, E\u0026gt; \u0026ndash; with custom incommensurate E types, or indeed arbitrary return types which are \u0026ldquo;split\u0026rdquo; T|E return types. Solving this well is the coup de gr√¢ce of Outcome against alternative approaches to this problem domain, including std::expected\u0026lt;T, E\u0026gt;. It is the major reason why you should consider using Outcome over alternatives, including Expected.\nFirstly we shall explore some of the problems faced by the software developer when T|E return type based code proliferates at scale, where dozens of libraries may be using completely incompatible T|E return types.\nSecondly we shall introduce the ValueOrError concept support in Outcome, which implements a subset of the proposed WG21 ValueOrError concept framework.\nFinally, we shall then step through a worked example which mocks up a realistic situation that the software developer may find themselves in: tying together disparate third party libraries, whose source code cannot be modified, into an application-wide, mixed-mode T|E and exception throwing universal error handling system which is capable of accurately representing the original failure, but also propagating it in a way that the application can deal with universally.\n"
},
{
	"uri": "https://ned14.github.io/outcome/experimental/worked-example/",
	"title": "Worked example: Custom domain (the short way)",
	"tags": [],
	"description": "",
	"content": "The section after this one will take the long way through defining a custom domain which sometimes is necessary if you have particularly bespoke requirements. If however you just want to wrap a custom enum type of yours into its own custom code domain, the boilerplate can be automated away by filling in a few simple fields like this:\n// My custom enum type enum classcustom_failure { not_found, bad_argument }; // Tell `status_code` to stamp out a custom code domain for this enum type SYSTEM_ERROR2_NAMESPACE_BEGIN template \u0026lt;\u0026gt; struct quick_status_code_from_enum\u0026lt;custom_failure\u0026gt; : quick_status_code_from_enum_defaults\u0026lt;custom_failure\u0026gt; { // Text name of the enum  static constexpr const auto domain_name = \u0026#34;My custom failure\u0026#34;; // Unique UUID for the enum. PLEASE use https://www.random.org/cgi-bin/randbyte?nbytes=16\u0026amp;format=h  static constexpr const auto domain_uuid = \u0026#34;{be201f65-3962-dd0e-1266-a72e63776a42}\u0026#34;; // Map of each enum value to its text string, and list of semantically equivalent errc\u0026#39;s  static const std::initializer_list\u0026lt;mapping\u0026gt; \u0026amp;value_mappings() { static const std::initializer_list\u0026lt;mapping\u0026gt; v = { // Format is: { enum value, \u0026#34;string representation\u0026#34;, { list of errc mappings ... } }  {custom_failure::not_found, \u0026#34;item not found\u0026#34;, {errc::no_such_file_or_directory}}, //  {custom_failure::bad_argument, \u0026#34;invoked wrong\u0026#34;, {errc::invalid_argument}}, //  }; return v; } // Completely optional definition of mixin for the status code synthesised from `Enum`. It can be omitted.  template \u0026lt;classBase\u0026gt; struct mixin : Base { using Base::Base; constexpr int custom_method() const { return 42; } }; }; SYSTEM_ERROR2_NAMESPACE_END View this code on Github Here we supply the bare minimum requirements for a status code domain:\n The name in text, so it can be printed. The unique UUID to identify when multiple copies of the domain are the same. PLEASE use https://www.random.org/cgi-bin/randbyte?nbytes=16\u0026amp;format=h to generate this, do not twiddle a few bits. For each enum value, its printable text and a sequence of errc:: enumerations which you think it is semantically equivalent to i.e. its mapping onto generic_code which is how status code defines the common mapping between status codes. If you later compare the status code to one of those values (or to another status code which also provides a mapping), if the generic codes are equivalent then the comparison will return true. This means code like if(sc == errc::no_such_file_or_directory) ... would match all custom error codes which mean \u0026lsquo;something was not found\u0026rsquo;. OPTIONAL: if you would like the custom status code type generated by this to have additional member functions or additional payload, you can define a mixin here to inject either data or functions or both. If you omit this, nothing gets injected.  "
},
{
	"uri": "https://ned14.github.io/outcome/experimental/worked-example-long/",
	"title": "Worked example: Custom domain (the long way)",
	"tags": [],
	"description": "",
	"content": " Here follows a longer worked example of use of Experimental Outcome. It presents the same sample program I sent to the San Diego 2018 WG21 standards meeting after I was asked by the committee to demonstrate how P1095 implements P0709 in a working code example they could study and discuss.\nWe will walk through this worked example, step by step, explaining how each part works in detail. This will help you implement your own code based on Experimental Outcome.\nMost users will not need this level of customisation, and for them the preceding quick and easy approach will be much easier.\nYou may find it useful to open now in a separate browser tab the reference API documentation for proposed \u0026lt;system_error2\u0026gt; at https://ned14.github.io/status-code/ (scroll half way down). The references in the comments to P1028 are to P1028 SG14 status_code and standard error object for P0709 Zero-overhead deterministic exceptions, which is the WG21 proposal paper for potential \u0026lt;system_error2\u0026gt;.\nGoal of this section We are going to define a simple custom code domain which defines that the status code\u0026rsquo;s payload will consist of a POSIX error code, and the __FILE__ and __LINE__ where the failure occurred. This custom status code will have an implicit conversion to type erased error defined, which dynamically allocates memory for the original status code, and outputs an error which manages that dynamic allocation, indirecting all queries etc to the erased custom status code type such that the error instance quacks as if just like the original. This demonstrates that error could just as equally convey a std::exception_ptr, for example, or indeed manage the lifetime of any pointer.\n"
},
{
	"uri": "https://ned14.github.io/outcome/history/",
	"title": "History",
	"tags": [],
	"description": "",
	"content": " Outcome has had an interesting history, and it is worth summarising it here to show how a Boost library comes to life. The following recollections are by Niall Douglas, and may be faulty due to his aging memory.\nmermaid.initialize({startOnLoad:true}); gantt dateFormat YYYY-MM title History of the Outcome library Outcome v1: done, des1, 2014-06,2017-05 Boost peer review of v1: done, des2, after des1, 30d Outcome v2 (complete redesign based on first review feedback): done, des3, after des2, 2018-01 Boost peer review of v2: done, des4, after des3, 30d Outcome v2.1 (changes from second review): active, des5, 2018-03, 2021-04 Outcome v2.2 (changes from user feedback on v2.1): des6, after des5, 2023-04 section Events Separated from AFIO v1: crit, done, 2014-06,4d Boost.Expected added: crit, done, 2014-10,4d Boost.Expected replaced with feature complete basic_monad: crit, done, 2015-08,4d Non-allocating future-promise implementation dropped: crit, done, 2016-05,4d C++ 11 support dropped: crit, done, 2016-06,4d Implemented LEWG expected\u0026lt;T, E\u0026gt; using basic_monad: crit, done, 2017-02,4d Outcome v1 replaced with prototype v2 in git repo: crit, done, 2017-07,4d Boost.Outcome generated by script from Outcome repo: crit, done, 2017-10,4d New tutorial finally complete: crit, done, 2017-12,4d Outcome v2.1 feature complete, maturation begins: crit, done, 2018-04,4d Boost.Outcome docs gain BoostDoc theming: crit, done, 2018-12,4d Release of v2.1 into Boost 1.70: crit, active, 2019-04,4d Release of v2.2 into Boost 1.76: crit, active, 2021-04,4d Outcome goes ABI stable: crit, active, 2022-04,4d   The genesis of Outcome v1 (2014 - 2017) The git repo began life as a \u0026ldquo;Boost.Spinlock\u0026rdquo; in June 2014 hived out of Boost.AFIO v1 where it had existed for some time as an internal library. In October 2014 I added in the original prototype Boost.Expected reference library as a git submodule, and began developing a non-allocating future\u0026lt;T\u0026gt;/promise\u0026lt;T\u0026gt; as an extension of expected\u0026lt;T, std::exception_ptr\u0026gt; as a faster, monadic future-promise was something which AFIO v1 sorely needed.\nThe original prototype Boost.Expected library was a large and very complex beastie. I was fortunate to be employed on a contract in late 2014 early 2015 where I saw it deployed at scale into an existing large C++ codebase. Expected was really great and powerful, but it absolutely murdered compile times in a large C++ codebase, and made LTO effectively infeasible. I also found its implementation non-conducive to implementing future-promise with it, and so I resolved to implement a much more powerful policy driven monad factory which could stamp out everything from an option\u0026lt;T\u0026gt; right through to a future-promise pair, all using the exact same basic_monad\u0026lt;\u0026gt; and therefore all with a full monadic programming API, C++ 17 continuations/monadic bind and intelligently convertible into one another. Moreover, all this needed to have an absolute minimum impact on compile times and runtime overheads, neither of which were strengths of the original prototype Boost.Expected library.\nBy August 2015 \u0026ldquo;Boost.Monad\u0026rdquo; was delivering on all those requirements and then some, but it lacked maturity through use in other code. Summer 2015 saw the Boost peer review of AFIO v1 which was roundly rejected. After considering the ample review feedback, it was realised that AFIO v2 would be a very different design, one no longer using futures, memory allocation nor C++ exceptions. As AFIO v2 was started from scratch and using Outcome heavily from the very beginning (every AFIO v2 API returns a result\u0026lt;T\u0026gt;), Outcome began to gain bug fixes and shed features, with the non-allocating future-promise implementation being dropped in May 2016 and a large chunk of type based metaprogramming being replaced with cleaner variable template metaprogramming in June. After CppCon 2016 in September, then began the long process of getting Outcome ready for Boost peer review in Q1 2017 which involved a repeated sequence of complete rewrites of the tutorial in response to multiple rounds of feedback from the C++ community, with at least four complete rewrites currently at the time of writing.\nIn parallel to all this development on Outcome, Expected went before the LEWG and entered the C++ standards track. As the WG21 meetings went by, Expected experienced a period of being stripped back and much of the complexity which had so murdered compile and link times in 2014-2015 fell away, thus the Expected proposed in P0323R1 ended up landing so close to Outcome that in January 2017 it was just a few hours work to implement Expected using the core basic_monad infrastructure in Outcome. That highly flexible policy based design which made monadic future-promise possible made it similarly easy to implement a highly conforming Expected, indeed in early 2017 Outcome\u0026rsquo;s Expected was much closer to P0323R1 than any other implementation including the LEWG reference implementation. And unlike the LEWG reference implementation, Outcome has had eighteen months of that finely tuned patina you only get when a library is in use by other code bases.\nIn February 2017 it became realised that the userbase really wanted a high quality expected\u0026lt;T, E\u0026gt; implementation rather than anything similar but not the same which Outcome had invented. The only just implemented Expected implementation based on basic_monad therefore took primacy. The final rewrite of the documentation before peer review submission was one which made it look like Outcome was primarily an expected\u0026lt;T, E\u0026gt; implementation with a few useful extensions like outcome\u0026lt;T\u0026gt; and result\u0026lt;T\u0026gt;. I was sad to so pivot, but it was obvious that Outcome would see far wider popularity and usage as primarily an Expected implementation.\nAlmost three years after its beginning, Outcome v1 finally went before Boost peer review in May 2017 which turned into one of the longest and most detailed peer reviews Boost has done in recent years, with over 800 pieces of review feedback submitted. It was by consensus rejected, with substantial feedback on what to do instead.\nOutcome v2 (2018) During the very lengthy peer review, roughly three groups of opinion emerged as to what a value|error transporting class ought to look like:\n 1. Lightweight A simple-as-possible T and/or E transport without any implementation complexity. 2. Medium A variant stored T or E1 ... En where T is the expected value and E1 ... are the potential unexpected values. This implemention really ought to be implemented using C++ 17's std::variant except with stronger never-empty guarantees.  3. Heavy A full fat Either monad participating fully in a wider monadic programming framework for C++.  Peter Dimov was very quickly able to implement an expected\u0026lt;T, E1, ...\u0026gt; using his variant2 library, and thus there seemed little point in replicating his work in an Outcome v2. The lightweight choice seemed to be the best path forwards, so in June 2017 the bare minimum result\u0026lt;T, E\u0026gt; and outcome\u0026lt;T, EC, P\u0026gt; as presented in this library was built, using the same constructor design as std::variant\u0026lt;...\u0026gt;. Significant backwards compatibility with v1 Outcome code was retained, as the review had felt the basic proposed design fine.\nA period of maturation then followed by porting a large existing codebase using Outcome v1 to v2, and writing a significant amount of new code using v2 to test it for unanticipated surprises and bugs. Quite a few corner cases were found and fixed. At the end of September 2017, Outcome v2 was deemed to be \u0026ldquo;mature\u0026rdquo;, and a script generated \u0026ldquo;Boost edition\u0026rdquo; made available.\nAll that remained before it was ready for a second Boost peer review was the documentation. This took four months to write (same time as to write the library itself!), and in January 2018 Outcome had its second Boost peer review, which it passed!\nOutcome v2.1 (2019 - 2020) The changes requsted during the review of v2.0 were fairly modest: result and outcome would be renamed to basic_result and basic_outcome, and a clean separation of concerns between the basic_* layer and the \u0026ldquo;convenience\u0026rdquo; layer would be created. That suited Outcome nicely, as the basic_* layer could have minimum possible header dependencies and thus minimum possible build times impact, which was great for big iron users with multi-million line C++ codebases. This also had the nice side effect of permitting both Boost and std implementations to be supported concurrently in both Outcome and Boost.Outcome.\nBy April 2018, v2.1 was feature complete and entered a six month period of maturation and battle hardening under its already extensive userbase. However Outcome passing its review in January 2018 had much more consequence than I could have ever expected. Unbeknownst to me, some of the WG21 leadership had interpreted the success of Outcome, and especially its divergences from WG21 Expected into a more complete substitute for C++ exception handling, as a sign that the C++ exception handling mechanism was no longer fit for purpose. It was thus proposed to remedy the standard exception handling mechanism into something much more efficient, thus rendering Outcome obsolete in future C++ standards (P0709 Zero overhead exceptions).\nConcurrently to that, just before the review of Outcome 2.0, I had mooted a number of semantic and compile time performance improvements to \u0026lt;system_error\u0026gt; with the proposal that we mildly break Boost.System with improvements and see how badly real world code broke in response. This was not widely accepted at that time (though they have been since incorporated into Boost.System, and proposed defect remedies for \u0026lt;system_error\u0026gt; for C++ 23). I therefore wrote an improved \u0026lt;system_error2\u0026gt; which fixed all the problems listed at P0824 (Summary of SG14 discussion on \u0026lt;system_error\u0026gt;) and fixed up Outcome so one could use it without any system error implementation, or with the STL one or with the proposed improved one. This improved \u0026lt;system_error2\u0026gt; was then proposed as the standard library support for Zero overhead exceptions as proposed std::error.\nA flurry of papers and discussion then resulted, running up to the Prague 2020 WG21 meeting where WG21 liked the library part of deterministic exceptions i.e. std::error, and wanted to see a working implementation of a compiler implementing the language part before moving further. The covid pandemic then ceased face to face meetings which deeply impacted WG21 productivity, so everything large which was not yet approved for entry into C++ 23 went on pause.\nOutcome v2.2 (2021) Outcome was sufficiently popular, and widely known as the closest simulacrum of deterministic exceptions currently available in C++, that it was regularly benchmarked as such on an \u0026lsquo;as if\u0026rsquo; basis by a number of people in the wider C++ ecosystem, including comparing their \u0026lsquo;better Outcome alternatives\u0026rsquo; to Outcome, where invariably Outcome appeared to lose badly in various synthetic tests. Whilst any empirical measurements in the real world code never showed a statistically significant difference, it was certainly true that v2.1\u0026rsquo;s codegen in assembler was not ideal.\nOn the behalf of WG21, Ben Craig did some benchmarking work on Outcome v2.1 in P1886 Error speed benchmarking, where it did not perform as well as expected compared to alternatives such as returning a simple integer from a function. This led to a better_optimisation branch. The changes were felt worth merging into Outcome as v2.2.0, the first major version release since Outcome entered Boost in early 2019. To give enough time to sign post to users that these source incompatible changes were coming, all of 2020 was given over to announcement of the upcoming merge of the breaking v2.2 branch into master branch in early 2021.\nIn terms of codegen benefits for proposed std::error based code (i.e. code using Outcome experimental), v2.2 implements a library-based emulation of P1029 move = bitcopies, a proposed compiler enhancement which can treat some move-only types as bags of bits. This very significantly improves the appearance in assembler of experimental Outcome based code.\nOutcome v2.2.3 (2022) Outcome v2.2 saw much popularity and very few issues reported after a year in the wild, so the decision was taken to write the v2.2.3 Outcome ABI into stone going forward. This is the guarantee that binaries compiled with the v2.2.3 release will link and work without issue with binaries compiled with any later version of Outcome.\nThis pretty much draws a line under further significant development of Outcome \u0026ndash; it has now effectively entered \u0026lsquo;sustaining\u0026rsquo;, as big multinationals would term it i.e. only small bug fixes and maintenance for future toolchains and languages etc would be expected going forth from now.\n"
},
{
	"uri": "https://ned14.github.io/outcome/experimental/c-api/",
	"title": "Using Outcome from C code",
	"tags": [],
	"description": "Interacting with `result` returning C++ functions from C code.",
	"content": "A long standing problem for C code (or more usually nowadays, the many other programming languages which can speak the C ABI but not the C++ ABI) is how to interpret C++ exception throws. The answer is of course that they cannot, thus requiring one to write C shim code on the C++ side of things of the form:\n// The API we wish to expose to C const char *get_value(double v); // The C shim function for the C++ get_value() function. extern \u0026#34;C\u0026#34; int c_get_value(const char **ret, double v) { try { *ret = get_value(v); return 0; // success  } catch(const std::range_error \u0026amp;) { return ERANGE; } // More catch clauses may go in here ...  catch(...) { return EAGAIN; } }  This is sufficiently painful that most reach for a bindings generator tool like SWIG to automate this sort of tedious boilerplate generation. And this is fine for larger projects, but for smaller projects the cost of setting up and configuring SWIG is also non-trivial.\nWhat would be really great is if result\u0026lt;T\u0026gt; returning noexcept C++ functions could be used straight from C. And indeed Experimental Outcome provides just that facility which this section covers next.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/basic_outcome/default/",
	"title": "`basic_outcome() = delete`",
	"tags": [],
	"description": "The default constructor (disabled).",
	"content": "The default constructor for basic outcome is always disabled.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/basic_result/default/",
	"title": "`basic_result() = delete`",
	"tags": [],
	"description": "The default constructor (disabled).",
	"content": "The default constructor for basic result is always disabled.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/policies/base/ub/",
	"title": "`static void _ub(Impl &amp;&amp;)`",
	"tags": [],
	"description": "Special function which causes noticeable hard undefined behaviour.",
	"content": "This is a special function which does compiler-specific stuff to tell the compiler that this function can never, ever, ever be executed. The compiler\u0026rsquo;s optimiser will hard assume that this function can never be executed, and will prune the possibility of it being executed completely. Generally this means that the code path stops dead, and if execution does proceed down this path, it will run off the end of a branch which doesn\u0026rsquo;t go anywhere. Your program will have lost known state, and usually it will trash memory and registers and crash.\nThis may seem highly undesirable. However, it also means that the optimiser can optimise more strongly, and so long as you never actually do execute this branch, you do get higher quality code generation.\nIf the NDEBUG macro is not defined, an OUTCOME_ASSERT(false) is present. This will cause attempts to execute this function to fail in a very obvious way, but it also generates runtime code to trigger the obvious failure.\nIf the NDEBUG macro is defined, and the program is compiled with the undefined behaviour sanitiser, attempts to execute this function will trigger an undefined behaviour sanitiser action.\nRequires: Always available.\nComplexity: Zero runtime overhead if NDEBUG is defined, guaranteed. If this function returns, your program is now in hard loss of known program state. Usually, but not always, it will crash at some point later. Rarely it will corrupt registers and memory, and keep going.\nGuarantees: An exception is never thrown.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/basic_outcome/move_constructor/",
	"title": "`basic_outcome(basic_outcome &amp;&amp;)`",
	"tags": [],
	"description": "Move constructor. Constexpr, triviality and noexcept propagating.",
	"content": "Move constructor.\nRequires: that value_type, error_type and exception_type all implement a move constructor.\nComplexity: Same as for value_type\u0026rsquo;s, error_type\u0026rsquo;s and exception_type\u0026rsquo;s move constructors. Constexpr, triviality and noexcept of underlying operations is propagated.\nGuarantees: If an exception is thrown during the operation, the object is left in a partially completed state, as per the normal rules for the same operation on a struct.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/basic_result/move_constructor/",
	"title": "`basic_result(basic_result &amp;&amp;)`",
	"tags": [],
	"description": "Move constructor. Constexpr, triviality and noexcept propagating.",
	"content": "Move constructor.\nRequires: that value_type and error_type both implement a move constructor.\nComplexity: Same as for value_type\u0026rsquo;s and error_type\u0026rsquo;s move constructors. Constexpr, triviality and noexcept of underlying operations is propagated.\nGuarantees: If an exception is thrown during the operation, the object is left in a partially completed state, as per the normal rules for the same operation on a struct.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/basic_outcome/copy_constructor/",
	"title": "`basic_outcome(const basic_outcome &amp;)`",
	"tags": [],
	"description": "Copy constructor. Constexpr, triviality and noexcept propagating.",
	"content": "Copy constructor.\nRequires: that value_type, error_type and exception_type all implement a copy constructor.\nComplexity: Same as for value_type\u0026rsquo;s, error_type\u0026rsquo;s and exception_type\u0026rsquo;s copy constructors. Constexpr, triviality and noexcept of underlying operations is propagated.\nGuarantees: If an exception is thrown during the operation, the object is left in a partially completed state, as per the normal rules for the same operation on a struct.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/basic_result/copy_constructor/",
	"title": "`basic_result(const basic_result &amp;)`",
	"tags": [],
	"description": "Copy constructor. Constexpr, triviality and noexcept propagating.",
	"content": "Copy constructor.\nRequires: that value_type and error_type both implement a copy constructor.\nComplexity: Same as for value_type\u0026rsquo;s and error_type\u0026rsquo;s copy constructors. Constexpr, triviality and noexcept of underlying operations is propagated.\nGuarantees: If an exception is thrown during the operation, the object is left in a partially completed state, as per the normal rules for the same operation on a struct.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/basic_outcome/move_assignment/",
	"title": "`basic_outcome &amp;operator=(basic_outcome &amp;&amp;)`",
	"tags": [],
	"description": "Move assignment. Constexpr, triviality and noexcept propagating.",
	"content": "Move assignment.\nRequires: that value_type, error_type and exception_type all implement move assignment.\nComplexity: If the value_type for both is present, uses value_type\u0026rsquo;s move assignment operator, else either destructs or move constructs value_type as appropriate. error_type\u0026rsquo;s and exception_type\u0026rsquo;s move assignment operator are always used. Constexpr, triviality and noexcept of underlying operations is propagated.\nGuarantees: If an exception is thrown during the operation, the object is left in a partially completed state, as per the normal rules for the same operation on a struct.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/basic_result/move_assignment/",
	"title": "`basic_result &amp;operator=(basic_result &amp;&amp;)`",
	"tags": [],
	"description": "Move assignment. Constexpr, triviality and noexcept propagating.",
	"content": "Move assignment.\nRequires: that value_type and error_type both implement move assignment.\nComplexity: If the value_type for both is present, uses value_type\u0026rsquo;s move assignment operator, else either destructs or move constructs value_type as appropriate. error_type\u0026rsquo;s move assignment operator is always used. Constexpr, triviality and noexcept of underlying operations is propagated.\nGuarantees: If an exception is thrown during the operation, the object is left in a partially completed state, as per the normal rules for the same operation on a struct.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/basic_outcome/copy_assignment/",
	"title": "`basic_outcome &amp;operator=(const basic_outcome &amp;)`",
	"tags": [],
	"description": "Copy assignment. Constexpr, triviality and noexcept propagating.",
	"content": "Copy assignment.\nRequires: that value_type, error_type and exception_type all implement copy assignment.\nComplexity: If the value_type for both is present, uses value_type\u0026rsquo;s copy assignment operator, else either destructs or copy constructs value_type as appropriate. error_type\u0026rsquo;s and exception_type\u0026rsquo;s copy assignment operator is always used. Constexpr, triviality and noexcept of underlying operations is propagated.\nGuarantees: If an exception is thrown during the operation, the object is left in a partially completed state, as per the normal rules for the same operation on a struct.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/basic_result/copy_assignment/",
	"title": "`basic_result &amp;operator=(const basic_result &amp;)`",
	"tags": [],
	"description": "Copy assignment. Constexpr, triviality and noexcept propagating.",
	"content": "Copy assignment.\nRequires: that value_type and error_type both implement copy assignment.\nComplexity: If the value_type for both is present, uses value_type\u0026rsquo;s copy assignment operator, else either destructs or copy constructs value_type as appropriate. error_type\u0026rsquo;s copy assignment operator is always used. Constexpr, triviality and noexcept of underlying operations is propagated.\nGuarantees: If an exception is thrown during the operation, the object is left in a partially completed state, as per the normal rules for the same operation on a struct.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/basic_outcome/destructor/",
	"title": "`~basic_outcome()`",
	"tags": [],
	"description": "Destructor. Constexpr, triviality and noexcept propagating.",
	"content": "Destructor.\nRequires: Always available.\nComplexity: Same as for value_type\u0026rsquo;s, error_type\u0026rsquo;s and exception_type\u0026rsquo;s destructors. Constexpr, triviality and noexcept of underlying operations is propagated.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/basic_result/destructor/",
	"title": "`~basic_result()`",
	"tags": [],
	"description": "Destructor. Constexpr, triviality and noexcept propagating.",
	"content": "Destructor.\nRequires: Always available.\nComplexity: Same as for value_type\u0026rsquo;s and error_type\u0026rsquo;s destructors. Constexpr, triviality and noexcept of underlying operations is propagated.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/basic_outcome/disabling_catchall/",
	"title": "`basic_outcome(Args...) = delete`",
	"tags": [],
	"description": "Disabling catchall constructor used to give useful diagnostic error when trying to use non-inplace constructors when `predicate::constructors_enabled` is false.",
	"content": "Disabling catchall constructor used to give useful diagnostic error when trying to use non-inplace constructors when predicate::constructors_enabled is false.\nRequires: predicate::constructors_enabled is false.\nComplexity: N/A.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/basic_result/disabling_catchall/",
	"title": "`basic_result(Args...) = delete`",
	"tags": [],
	"description": "Disabling catchall constructor used to give useful diagnostic error when trying to use non-inplace constructors when `predicate::constructors_enabled` is false.",
	"content": "Disabling catchall constructor used to give useful diagnostic error when trying to use non-inplace constructors when predicate::constructors_enabled is false.\nRequires: predicate::constructors_enabled is false.\nComplexity: N/A.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/basic_outcome/disabling_implicit_constructor/",
	"title": "`basic_outcome(X &amp;&amp;) = delete`",
	"tags": [],
	"description": "Disabling implicit constructor used to give useful diagnostic error when trying to use implicit constructors when `predicate::implicit_constructors_enabled` is false.",
	"content": "Disabling implicit constructor used to give useful diagnostic error when trying to use implicit constructors when predicate::implicit_constructors_enabled is false.\nRequires: predicate::implicit_constructors_enabled is false.\nComplexity: N/A.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/basic_result/disabling_implicit_constructor/",
	"title": "`basic_result(X &amp;&amp;) = delete`",
	"tags": [],
	"description": "Disabling implicit constructor used to give useful diagnostic error when trying to use implicit constructors when `predicate::implicit_constructors_enabled` is false.",
	"content": "Disabling implicit constructor used to give useful diagnostic error when trying to use implicit constructors when predicate::implicit_constructors_enabled is false.\nRequires: predicate::implicit_constructors_enabled is false.\nComplexity: N/A.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/basic_outcome/implicit_value_converting_constructor/",
	"title": "`basic_outcome(R &amp;&amp;)`",
	"tags": [],
	"description": "Implicit `value_type` constructor. Available if `predicate::enable_value_converting_constructor&lt;R&gt;` is true. Constexpr, triviality and noexcept propagating.",
	"content": "Implicit value_type constructor. Calls void on_outcome_construction(T *, U \u0026amp;\u0026amp;) noexcept with this and R.\nRequires: predicate::enable_value_converting_constructor\u0026lt;R\u0026gt; is true.\nComplexity: Same as for value_type\u0026rsquo;s copy or move constructor. Constexpr, triviality and noexcept of underlying operations is propagated.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/basic_result/implicit_value_converting_constructor/",
	"title": "`basic_result(R &amp;&amp;)`",
	"tags": [],
	"description": "Implicit `value_type` constructor. Available if `predicate::enable_value_converting_constructor&lt;R&gt;` is true. Constexpr, triviality and noexcept propagating.",
	"content": "Implicit value_type constructor. Calls void on_result_construction(T *, U \u0026amp;\u0026amp;) noexcept with this and R.\nRequires: predicate::enable_value_converting_constructor\u0026lt;R\u0026gt; is true.\nComplexity: Same as for value_type\u0026rsquo;s copy or move constructor. Constexpr, triviality and noexcept of underlying operations is propagated.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/basic_outcome/implicit_error_converting_constructor/",
	"title": "`basic_outcome(S &amp;&amp;)`",
	"tags": [],
	"description": "Implicit `error_type` constructor. Available if `predicate::enable_error_converting_constructor&lt;S&gt;` is true. Constexpr, triviality and noexcept propagating.",
	"content": "Implicit error_type constructor. Calls void on_outcome_construction(T *, U \u0026amp;\u0026amp;) noexcept with this and S.\nRequires: predicate::enable_error_converting_constructor\u0026lt;S\u0026gt; is true.\nComplexity: Same as for error_type\u0026rsquo;s copy or move constructor. Constexpr, triviality and noexcept of underlying operations is propagated.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/basic_result/implicit_error_converting_constructor/",
	"title": "`basic_result(S &amp;&amp;)`",
	"tags": [],
	"description": "Implicit `error_type` constructor. Available if `predicate::enable_error_converting_constructor&lt;S&gt;` is true. Constexpr, triviality and noexcept propagating.",
	"content": "Implicit error_type constructor. Calls void on_result_construction(T *, U \u0026amp;\u0026amp;) noexcept with this and S.\nRequires: predicate::enable_error_converting_constructor\u0026lt;S\u0026gt; is true.\nComplexity: Same as for error_type\u0026rsquo;s copy or move constructor. Constexpr, triviality and noexcept of underlying operations is propagated.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/basic_outcome/implicit_error_condition_converting_constructor/",
	"title": "`basic_outcome(ErrorCondEnum &amp;&amp;)`",
	"tags": [],
	"description": "Implicit `error_type` from `ErrorCondEnum` constructor. Available if `predicate::enable_error_condition_converting_constructor&lt;ErrorCondEnum&gt;` is true. Constexpr, triviality and noexcept propagating.",
	"content": "Implicit error_type from ErrorCondEnum constructor. Calls void on_outcome_construction(T *, U \u0026amp;\u0026amp;) noexcept with this and ErrorCondEnum.\nRequires: predicate::enable_error_condition_converting_constructor\u0026lt;R\u0026gt; is true.\nComplexity: Same as for error_type\u0026rsquo;s copy or move constructor from the result of make_error_code(ErrorCondEnum). Constexpr, triviality and noexcept of underlying operations is propagated.\nGuarantees: If an exception is thrown during the operation, the state of the input is left indeterminate.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/basic_result/implicit_error_condition_converting_constructor/",
	"title": "`basic_result(ErrorCondEnum &amp;&amp;)`",
	"tags": [],
	"description": "Implicit `error_type` from `ErrorCondEnum` constructor. Available if `predicate::enable_error_condition_converting_constructor&lt;ErrorCondEnum&gt;` is true. Constexpr, triviality and noexcept propagating.",
	"content": "Implicit error_type from ErrorCondEnum constructor. Calls void on_result_construction(T *, U \u0026amp;\u0026amp;) noexcept with this and ErrorCondEnum.\nRequires: predicate::enable_error_condition_converting_constructor\u0026lt;R\u0026gt; is true.\nComplexity: Same as for error_type\u0026rsquo;s copy or move constructor from the result of make_error_code(ErrorCondEnum). Constexpr, triviality and noexcept of underlying operations is propagated.\nGuarantees: If an exception is thrown during the operation, the state of the input is left indeterminate.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/policies/base/has_value/",
	"title": "`static bool _has_value(Impl &amp;&amp;) noexcept`",
	"tags": [],
	"description": "Returns true if a value is present in the implementation passed in. Constexpr, never throws.",
	"content": "Returns true if a value is present in the implementation passed in. Constexpr where possible.\nRequires: Always available.\nComplexity: Constant time.\nGuarantees: Never throws an exception.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/basic_outcome/implicit_exception_converting_constructor/",
	"title": "`basic_outcome(P &amp;&amp;)`",
	"tags": [],
	"description": "Implicit `exception_type` constructor. Available if `predicate::enable_exception_converting_constructor&lt;P&gt;` is true. Constexpr, triviality and noexcept propagating.",
	"content": "Implicit exception_type constructor. Calls void on_outcome_construction(T *, U \u0026amp;\u0026amp;) noexcept with this and P.\nRequires: predicate::enable_exception_converting_constructor\u0026lt;P\u0026gt; is true.\nComplexity: Same as for exception_type\u0026rsquo;s copy or move constructor. Constexpr, triviality and noexcept of underlying operations is propagated.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/basic_outcome/implicit_error_exception_converting_constructor/",
	"title": "`basic_outcome(S &amp;&amp;, P &amp;&amp;)`",
	"tags": [],
	"description": "Implicit `error_type` + `exception_type` constructor. Available if `predicate::enable_error_exception_converting_constructor&lt;S, P&gt;` is true. Constexpr, triviality and noexcept propagating.",
	"content": "Implicit error_type + exception_type constructor. Calls void on_outcome_construction(T *, U \u0026amp;\u0026amp;, V \u0026amp;\u0026amp;) noexcept with this, S and P.\nRequires: predicate::enable_error_exception_converting_constructor\u0026lt;S, P\u0026gt; is true.\nComplexity: Same as for error_type\u0026rsquo;s and exception_type\u0026rsquo;s copy or move constructor. Constexpr, triviality and noexcept of underlying operations is propagated.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/policies/base/has_error/",
	"title": "`static bool _has_error(Impl &amp;&amp;) noexcept`",
	"tags": [],
	"description": "Returns true if an error is present in the implementation passed in. Constexpr, never throws.",
	"content": "Returns true if an error is present in the implementation passed in. Constexpr where possible.\nRequires: Always available.\nComplexity: Constant time.\nGuarantees: Never throws an exception.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/policies/base/has_exception/",
	"title": "`static bool _has_exception(Impl &amp;&amp;) noexcept`",
	"tags": [],
	"description": "Returns true if an exception is present in the implementation passed in. Constexpr, never throws.",
	"content": "Returns true if an exception is present in the implementation passed in. Constexpr where possible.\nRequires: Always available.\nComplexity: Constant time.\nGuarantees: Never throws an exception.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/policies/base/has_error_is_errno/",
	"title": "`static bool _has_error_is_errno(Impl &amp;&amp;) noexcept`",
	"tags": [],
	"description": "Returns true if the error code in the implementation passed in has a domain or category matching that of POSIX `errno`. Constexpr, never throws.",
	"content": "Returns true if the error code in the implementation passed in has a domain or category matching that of POSIX errno. Constexpr where possible.\nRequires: Always available.\nComplexity: Constant time.\nGuarantees: Never throws an exception.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/policies/base/value/",
	"title": "`static auto &amp;&amp;_value(Impl &amp;&amp;) noexcept`",
	"tags": [],
	"description": "Returns a reference to the value in the implementation passed in. Constexpr, never throws.",
	"content": "Returns a reference to the value in the implementation passed in. No checking is done to ensure there is a value. Constexpr where possible.\nRequires: Always available.\nComplexity: Constant time.\nGuarantees: Never throws an exception.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/policies/base/error/",
	"title": "`static auto &amp;&amp;_error(Impl &amp;&amp;) noexcept`",
	"tags": [],
	"description": "Returns a reference to the error in the implementation passed in. Constexpr, never throws.",
	"content": "Returns a reference to the error in the implementation passed in. No checking is done to ensure there is an error. Constexpr where possible.\nRequires: Always available.\nComplexity: Constant time.\nGuarantees: Never throws an exception.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/policies/base/exception/",
	"title": "`static auto &amp;&amp;_exception(Impl &amp;&amp;) noexcept`",
	"tags": [],
	"description": "Returns a reference to the exception in the implementation passed in. Constexpr, never throws.",
	"content": "Returns a reference to the exception in the implementation passed in. No checking is done to ensure there is an error. Constexpr where possible.\nRequires: Always available.\nComplexity: Constant time.\nGuarantees: Never throws an exception.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/basic_outcome/explicit_valueorerror_converting_constructor/",
	"title": "`explicit basic_outcome(concepts::value_or_error&lt;T, E&gt; &amp;&amp;)`",
	"tags": [],
	"description": "Explicit converting constructor from `concepts::value_or_error&lt;T, E&gt;` concept matching types. Available if `convert::value_or_error&lt;&gt;` permits it. Constexpr, triviality and noexcept propagating.",
	"content": "Explicit converting constructor from concepts::value_or_error\u0026lt;T, E\u0026gt; concept matching types. Delegates to the basic_result move constructor explicit basic_outcome(basic_result\u0026lt;A, B, C\u0026gt; \u0026amp;\u0026amp;) .\nRequires: convert::value_or_error\u0026lt;T, U\u0026gt; has an available call operator, and if the input is a basic_result or basic_outcome, then convert::value_or_error\u0026lt;\u0026gt; has enabled those inputs for that convert::value_or_error\u0026lt;\u0026gt; specialisation.\nComplexity: Same as for the copy or move constructor from the input\u0026rsquo;s .value() or .error() respectively. Constexpr, triviality and noexcept of underlying operations is propagated.\nGuarantees: If an exception is thrown during the operation, the object is left in a partially completed state, as per the normal rules for the same operation on a struct.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/basic_result/explicit_valueorerror_converting_constructor/",
	"title": "`explicit basic_result(concepts::value_or_error&lt;T, E&gt; &amp;&amp;)`",
	"tags": [],
	"description": "Explicit converting constructor from `concepts::value_or_error&lt;T, E&gt;` concept matching types. Available if `convert::value_or_error&lt;&gt;` permits it. Constexpr, triviality and noexcept propagating.",
	"content": "Explicit converting constructor from concepts::value_or_error\u0026lt;T, E\u0026gt; concept matching types. Delegates to the basic_result move constructor.\nRequires: convert::value_or_error\u0026lt;T, U\u0026gt; has an available call operator, and if the input is a basic_result or basic_outcome, then convert::value_or_error\u0026lt;\u0026gt; has enabled those inputs for that convert::value_or_error\u0026lt;\u0026gt; specialisation.\nComplexity: Same as for the copy or move constructor from the input\u0026rsquo;s .value() or .error() respectively. Constexpr, triviality and noexcept of underlying operations is propagated.\nGuarantees: If an exception is thrown during the operation, the object is left in a partially completed state, as per the normal rules for the same operation on a struct.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/policies/base/set_has_value/",
	"title": "`static void _set_has_value(Impl &amp;&amp;, bool) noexcept`",
	"tags": [],
	"description": "Sets whether the implementation has a value. Constexpr, never throws.",
	"content": "Sets whether the implementation has a value by setting or clearing the relevant bit in the flags. Constexpr where possible.\nRequires: Always available.\nComplexity: Constant time.\nGuarantees: Never throws an exception.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/basic_outcome/explicit_copy_converting_constructor/",
	"title": "`explicit basic_outcome(const basic_outcome&lt;A, B, C, D&gt; &amp;)`",
	"tags": [],
	"description": "Explicit converting copy constructor from compatible `basic_outcome`. Available if `predicate::enable_compatible_conversion&lt;A, B, C, D&gt;` is true. Constexpr, triviality and noexcept propagating.",
	"content": "Explicit converting copy constructor from compatible basic_outcome. Calls void on_outcome_copy_construction(T *, U \u0026amp;\u0026amp;) noexcept with this and the input.\nRequires: predicate::enable_compatible_conversion\u0026lt;A, B, C, D\u0026gt; is true.\nComplexity: Same as for the copy constructors of the underlying types. Constexpr, triviality and noexcept of underlying operations is propagated.\nGuarantees: If an exception is thrown during the operation, the object is left in a partially completed state, as per the normal rules for the same operation on a struct.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/basic_result/explicit_copy_converting_constructor/",
	"title": "`explicit basic_result(const basic_result&lt;R, S, P&gt; &amp;)`",
	"tags": [],
	"description": "Explicit converting copy constructor from compatible `basic_result`. Available if `predicate::enable_compatible_conversion&lt;R, S, P&gt;` is true. Constexpr, triviality and noexcept propagating.",
	"content": "Explicit converting copy constructor from compatible basic_result. Calls void on_result_copy_construction(T *, U \u0026amp;\u0026amp;) noexcept with this and the input.\nRequires: predicate::enable_compatible_conversion\u0026lt;R, S, P\u0026gt; is true.\nComplexity: Same as for the copy constructors of the underlying types. Constexpr, triviality and noexcept of underlying operations is propagated.\nGuarantees: If an exception is thrown during the operation, the object is left in a partially completed state, as per the normal rules for the same operation on a struct.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/policies/base/set_has_error/",
	"title": "`static void _set_has_error(Impl &amp;&amp;, bool) noexcept`",
	"tags": [],
	"description": "Sets whether the implementation has an error. Constexpr, never throws.",
	"content": "Sets whether the implementation has an error by setting or clearing the relevant bit in the flags. Constexpr where possible.\nRequires: Always available.\nComplexity: Constant time.\nGuarantees: Never throws an exception.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/basic_outcome/explicit_move_converting_constructor/",
	"title": "`explicit basic_outcome(basic_outcome&lt;A, B, C, D&gt; &amp;&amp;)`",
	"tags": [],
	"description": "Explicit converting move constructor from compatible `basic_outcome`. Available if `predicate::enable_compatible_conversion&lt;A, B, C, D&gt;` is true. Constexpr, triviality and noexcept propagating.",
	"content": "Explicit converting move constructor from compatible basic_outcome. Calls void on_outcome_move_construction(T *, U \u0026amp;\u0026amp;) noexcept with this and the input.\nRequires: predicate::enable_compatible_conversion\u0026lt;A, B, C, D\u0026gt; is true.\nComplexity: Same as for the move constructors of the underlying types. Constexpr, triviality and noexcept of underlying operations is propagated.\nGuarantees: If an exception is thrown during the operation, the object is left in a partially completed state, as per the normal rules for the same operation on a struct.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/basic_result/explicit_move_converting_constructor/",
	"title": "`explicit basic_result(basic_result&lt;R, S, P&gt; &amp;&amp;)`",
	"tags": [],
	"description": "Explicit converting move constructor from compatible `basic_result`. Available if `predicate::enable_compatible_conversion&lt;R, S, P&gt;` is true. Constexpr, triviality and noexcept propagating.",
	"content": "Explicit converting move constructor from compatible basic_result. Calls void on_result_move_construction(T *, U \u0026amp;\u0026amp;) noexcept with this and the input.\nRequires: predicate::enable_compatible_conversion\u0026lt;R, S, P\u0026gt; is true.\nComplexity: Same as for the move constructors of the underlying types. Constexpr, triviality and noexcept of underlying operations is propagated.\nGuarantees: If an exception is thrown during the operation, the object is left in a partially completed state, as per the normal rules for the same operation on a struct.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/basic_result/explicit_make_error_code_copy_converting_constructor/",
	"title": "`explicit basic_result(const basic_result&lt;R, S, P&gt; &amp;)`",
	"tags": [],
	"description": "Explicit converting copy constructor from compatible `basic_result`. Available if `predicate::enable_make_error_code_compatible_conversion&lt;R, S, P&gt;` is true. Constexpr, triviality and noexcept propagating.",
	"content": "Explicit converting copy constructor from compatible basic_result. Calls void on_result_copy_construction(T *, U \u0026amp;\u0026amp;) noexcept with this and the input.\nRequires: predicate::enable_make_error_code_compatible_conversion\u0026lt;R, S, P\u0026gt; is true.\nComplexity: Same as for the copy constructors of the underlying types. Constexpr, triviality and noexcept of underlying operations is propagated.\nGuarantees: If an exception is thrown during the operation, the object is left in a partially completed state, as per the normal rules for the same operation on a struct.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/basic_result/explicit_make_error_code_move_converting_constructor/",
	"title": "`explicit basic_result(basic_result&lt;R, S, P&gt; &amp;&amp;)`",
	"tags": [],
	"description": "Explicit converting move constructor from compatible `basic_result`. Available if `predicate::enable_make_error_code_compatible_conversion&lt;R, S, P&gt;` is true. Constexpr, triviality and noexcept propagating.",
	"content": "Explicit converting move constructor from compatible basic_result. Calls void on_result_move_construction(T *, U \u0026amp;\u0026amp;) noexcept with this and the input.\nRequires: predicate::enable_make_error_code_compatible_conversion\u0026lt;R, S, P\u0026gt; is true.\nComplexity: Same as for the move constructors of the underlying types. Constexpr, triviality and noexcept of underlying operations is propagated.\nGuarantees: If an exception is thrown during the operation, the object is left in a partially completed state, as per the normal rules for the same operation on a struct.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/basic_result/explicit_make_exception_ptr_copy_converting_constructor/",
	"title": "`explicit basic_result(const basic_result&lt;R, S, P&gt; &amp;)`",
	"tags": [],
	"description": "Explicit converting copy constructor from compatible `basic_result`. Available if `predicate::enable_make_exception_ptr_compatible_conversion&lt;R, S, P&gt;` is true. Constexpr, triviality and noexcept propagating.",
	"content": "Explicit converting copy constructor from compatible basic_result. Calls void on_result_copy_construction(T *, U \u0026amp;\u0026amp;) noexcept with this and the input.\nRequires: predicate::enable_make_exception_ptr_compatible_conversion\u0026lt;R, S, P\u0026gt; is true.\nComplexity: Same as for the copy constructors of the underlying types. Constexpr, triviality and noexcept of underlying operations is propagated.\nGuarantees: If an exception is thrown during the operation, the object is left in a partially completed state, as per the normal rules for the same operation on a struct.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/basic_result/explicit_make_exception_ptr_move_converting_constructor/",
	"title": "`explicit basic_result(basic_result&lt;R, S, P&gt; &amp;&amp;)`",
	"tags": [],
	"description": "Explicit converting move constructor from compatible `basic_result`. Available if `predicate::enable_make_exception_ptr_compatible_conversion&lt;R, S, P&gt;` is true. Constexpr, triviality and noexcept propagating.",
	"content": "Explicit converting move constructor from compatible basic_result. Calls void on_result_move_construction(T *, U \u0026amp;\u0026amp;) noexcept with this and the input.\nRequires: predicate::enable_make_exception_ptr_compatible_conversion\u0026lt;R, S, P\u0026gt; is true.\nComplexity: Same as for the move constructors of the underlying types. Constexpr, triviality and noexcept of underlying operations is propagated.\nGuarantees: If an exception is thrown during the operation, the object is left in a partially completed state, as per the normal rules for the same operation on a struct.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/basic_outcome/explicit_result_copy_converting_constructor/",
	"title": "`explicit basic_outcome(const basic_result&lt;A, B, C&gt; &amp;)`",
	"tags": [],
	"description": "Explicit converting copy constructor from compatible `basic_result`. Available if `predicate::enable_compatible_conversion&lt;A, B, void, C&gt;` is true. Constexpr, triviality and noexcept propagating.",
	"content": "Explicit converting copy constructor from compatible basic_result. Calls void on_outcome_copy_construction(T *, U \u0026amp;\u0026amp;) noexcept with this and the input.\nRequires: predicate::enable_compatible_conversion\u0026lt;A, B, void, C\u0026gt; is true.\nComplexity: Same as for the copy constructors of the underlying types. Constexpr, triviality and noexcept of underlying operations is propagated.\nGuarantees: If an exception is thrown during the operation, the object is left in a partially completed state, as per the normal rules for the same operation on a struct.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/policies/base/set_has_exception/",
	"title": "`static void _set_has_exception(Impl &amp;&amp;, bool) noexcept`",
	"tags": [],
	"description": "Sets whether the implementation has an exception. Constexpr, never throws.",
	"content": "Sets whether the implementation has an exception by setting or clearing the relevant bit in the flags. Constexpr where possible.\nRequires: Always available.\nComplexity: Constant time.\nGuarantees: Never throws an exception.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/basic_outcome/explicit_result_move_converting_constructor/",
	"title": "`explicit basic_outcome(basic_result&lt;A, B, C&gt; &amp;&amp;)`",
	"tags": [],
	"description": "Explicit converting move constructor from compatible `basic_result`. Available if `predicate::enable_compatible_conversion&lt;A, B, void, C&gt;` is true. Constexpr, triviality and noexcept propagating.",
	"content": "Explicit converting move constructor from compatible basic_result. Calls void on_outcome_move_construction(T *, U \u0026amp;\u0026amp;) noexcept with this and the input.\nRequires: predicate::enable_compatible_conversion\u0026lt;A, B, void, C\u0026gt; is true.\nComplexity: Same as for the move constructors of the underlying types. Constexpr, triviality and noexcept of underlying operations is propagated.\nGuarantees: If an exception is thrown during the operation, the object is left in a partially completed state, as per the normal rules for the same operation on a struct.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/policies/base/set_has_error_is_errno/",
	"title": "`static void _set_has_exception(Impl &amp;&amp;, bool) noexcept`",
	"tags": [],
	"description": "Sets whether the implementation&#39;s error code has a domain or category matching that of POSIX `errno`. Constexpr, never throws.",
	"content": "Sets whether the implementation\u0026rsquo;s error code has a domain or category matching that of POSIX errno by setting or clearing the relevant bit in the flags. Constexpr where possible.\nRequires: Always available.\nComplexity: Constant time.\nGuarantees: Never throws an exception.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/basic_outcome/explicit_result_make_error_code_copy_converting_constructor/",
	"title": "`explicit basic_outcome(const basic_result&lt;A, B, C&gt; &amp;)`",
	"tags": [],
	"description": "Explicit converting copy constructor from compatible `basic_result`. Available if `predicate::enable_make_error_code_compatible_conversion&lt;A, B, void, C&gt;` is true. Constexpr, triviality and noexcept propagating.",
	"content": "Explicit converting copy constructor from compatible basic_result. Calls void on_outcome_copy_construction(T *, U \u0026amp;\u0026amp;) noexcept with this and the input.\nRequires: predicate::enable_make_error_code_compatible_conversion\u0026lt;A, B, void, C\u0026gt; is true.\nComplexity: Same as for the copy constructors of the underlying types. Constexpr, triviality and noexcept of underlying operations is propagated.\nGuarantees: If an exception is thrown during the operation, the object is left in a partially completed state, as per the normal rules for the same operation on a struct.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/basic_outcome/explicit_result_make_error_code_move_converting_constructor/",
	"title": "`explicit basic_outcome(basic_result&lt;A, B, C&gt; &amp;&amp;)`",
	"tags": [],
	"description": "Explicit converting move constructor from compatible `basic_result`. Available if `predicate::enable_make_error_code_compatible_conversion&lt;A, B, void, C&gt;` is true. Constexpr, triviality and noexcept propagating.",
	"content": "Explicit converting move constructor from compatible basic_result. Calls void on_outcome_move_construction(T *, U \u0026amp;\u0026amp;) noexcept with this and the input.\nRequires: predicate::enable_make_error_code_compatible_conversion\u0026lt;A, B, void, C\u0026gt; is true.\nComplexity: Same as for the move constructors of the underlying types. Constexpr, triviality and noexcept of underlying operations is propagated.\nGuarantees: If an exception is thrown during the operation, the object is left in a partially completed state, as per the normal rules for the same operation on a struct.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/basic_outcome/explicit_inplace_value_constructor/",
	"title": "`explicit basic_outcome(in_place_type_t&lt;value_type_if_enabled&gt;, Args ...)`",
	"tags": [],
	"description": "Explicit inplace value constructor. Available if `predicate::enable_inplace_value_constructor&lt;Args ...&gt;` is true. Constexpr, triviality and noexcept propagating.",
	"content": "Explicit inplace value constructor. Calls void on_outcome_in_place_construction(T *, in_place_type_t\u0026lt;U\u0026gt;, Args \u0026amp;\u0026amp;...) noexcept with this, in_place_type\u0026lt;value_type\u0026gt; and Args ....\nRequires: predicate::enable_inplace_value_constructor\u0026lt;Args ...\u0026gt; is true.\nComplexity: Same as for the value_type constructor which accepts Args .... Constexpr, triviality and noexcept of underlying operations is propagated.\nGuarantees: If an exception is thrown during the operation, the state of the Args is left indeterminate.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/basic_result/explicit_inplace_value_constructor/",
	"title": "`explicit basic_result(in_place_type_t&lt;value_type_if_enabled&gt;, Args ...)`",
	"tags": [],
	"description": "Explicit inplace value constructor. Available if `predicate::enable_inplace_value_constructor&lt;Args ...&gt;` is true. Constexpr, triviality and noexcept propagating.",
	"content": "Explicit inplace value constructor. Calls void on_result_in_place_construction(T *, in_place_type_t\u0026lt;U\u0026gt;, Args \u0026amp;\u0026amp;...) noexcept with this, in_place_type\u0026lt;value_type\u0026gt; and Args ....\nRequires: predicate::enable_inplace_value_constructor\u0026lt;Args ...\u0026gt; is true.\nComplexity: Same as for the value_type constructor which accepts Args .... Constexpr, triviality and noexcept of underlying operations is propagated.\nGuarantees: If an exception is thrown during the operation, the state of the Args is left indeterminate.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/policies/base/narrow_value_check/",
	"title": "`static void narrow_value_check(Impl &amp;&amp;) noexcept`",
	"tags": [],
	"description": "Observer policy performing hard UB if no value is present. Constexpr, never throws.",
	"content": "Observer policy performing hard UB if no value is present, by calling static void _ub(Impl \u0026amp;\u0026amp;) . Constexpr where possible.\nRequires: Always available.\nComplexity: Constant time.\nGuarantees: Never throws an exception.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/basic_outcome/explicit_inplace_value_constructor_il/",
	"title": "`explicit basic_outcome(in_place_type_t&lt;value_type_if_enabled&gt;, std::initializer_list&lt;U&gt;, Args ...)`",
	"tags": [],
	"description": "Explicit inplace value constructor. Available if `predicate::enable_inplace_value_constructor&lt;std::initializer_list&lt;U&gt;, Args ...&gt;` is true. Constexpr, triviality and noexcept propagating.",
	"content": "Explicit inplace value constructor. Calls void on_outcome_in_place_construction(T *, in_place_type_t\u0026lt;U\u0026gt;, Args \u0026amp;\u0026amp;...) noexcept with this, in_place_type\u0026lt;value_type\u0026gt;, \u0026lsquo;std::initializer_list\u0026rsquo; and Args ....\nRequires: predicate::enable_inplace_value_constructor\u0026lt;std::initializer_list\u0026lt;U\u0026gt;, Args ...\u0026gt; is true.\nComplexity: Same as for the value_type constructor which accepts std::initializer_list\u0026lt;U\u0026gt;, Args .... Constexpr, triviality and noexcept of underlying operations is propagated.\nGuarantees: If an exception is thrown during the operation, the state of the Args is left indeterminate.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/basic_result/explicit_inplace_value_constructor_il/",
	"title": "`explicit basic_result(in_place_type_t&lt;value_type_if_enabled&gt;, std::initializer_list&lt;U&gt;, Args ...)`",
	"tags": [],
	"description": "Explicit inplace value constructor. Available if `predicate::enable_inplace_value_constructor&lt;std::initializer_list&lt;U&gt;, Args ...&gt;` is true. Constexpr, triviality and noexcept propagating.",
	"content": "Explicit inplace value constructor. Calls void on_result_in_place_construction(T *, in_place_type_t\u0026lt;U\u0026gt;, Args \u0026amp;\u0026amp;...) noexcept with this, in_place_type\u0026lt;value_type\u0026gt;, \u0026lsquo;std::initializer_list\u0026rsquo; and Args ....\nRequires: predicate::enable_inplace_value_constructor\u0026lt;std::initializer_list\u0026lt;U\u0026gt;, Args ...\u0026gt; is true.\nComplexity: Same as for the value_type constructor which accepts std::initializer_list\u0026lt;U\u0026gt;, Args .... Constexpr, triviality and noexcept of underlying operations is propagated.\nGuarantees: If an exception is thrown during the operation, the state of the Args is left indeterminate.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/policies/base/narrow_error_check/",
	"title": "`static void narrow_error_check(Impl &amp;&amp;) noexcept`",
	"tags": [],
	"description": "Observer policy performing hard UB if no error is present. Constexpr, never throws.",
	"content": "Observer policy performing hard UB if no error is present, by calling static void _ub(Impl \u0026amp;\u0026amp;) . Constexpr where possible.\nRequires: Always available.\nComplexity: Constant time.\nGuarantees: Never throws an exception.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/basic_outcome/explicit_inplace_error_constructor/",
	"title": "`explicit basic_outcome(in_place_type_t&lt;error_type_if_enabled&gt;, Args ...)`",
	"tags": [],
	"description": "Explicit inplace error constructor. Available if `predicate::enable_inplace_error_constructor&lt;Args ...&gt;` is true. Constexpr, triviality and noexcept propagating.",
	"content": "Explicit inplace error constructor. Calls void on_outcome_in_place_construction(T *, in_place_type_t\u0026lt;U\u0026gt;, Args \u0026amp;\u0026amp;...) noexcept with this, in_place_type\u0026lt;error_type\u0026gt; and Args ....\nRequires: predicate::enable_inplace_error_constructor\u0026lt;Args ...\u0026gt; is true.\nComplexity: Same as for the error_type constructor which accepts Args .... Constexpr, triviality and noexcept of underlying operations is propagated.\nGuarantees: If an exception is thrown during the operation, the state of the Args is left indeterminate.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/basic_result/explicit_inplace_error_constructor/",
	"title": "`explicit basic_result(in_place_type_t&lt;error_type_if_enabled&gt;, Args ...)`",
	"tags": [],
	"description": "Explicit inplace error constructor. Available if `predicate::enable_inplace_error_constructor&lt;Args ...&gt;` is true. Constexpr, triviality and noexcept propagating.",
	"content": "Explicit inplace error constructor. Calls void on_result_in_place_construction(T *, in_place_type_t\u0026lt;U\u0026gt;, Args \u0026amp;\u0026amp;...) noexcept with this, in_place_type\u0026lt;error_type\u0026gt; and Args ....\nRequires: predicate::enable_inplace_error_constructor\u0026lt;Args ...\u0026gt; is true.\nComplexity: Same as for the error_type constructor which accepts Args .... Constexpr, triviality and noexcept of underlying operations is propagated.\nGuarantees: If an exception is thrown during the operation, the state of the Args is left indeterminate.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/policies/base/narrow_exception_check/",
	"title": "`static void narrow_exception_check(Impl &amp;&amp;) noexcept`",
	"tags": [],
	"description": "Observer policy performing hard UB if no exception is present. Constexpr, never throws.",
	"content": "Observer policy performing hard UB if no exception is present, by calling static void _ub(Impl \u0026amp;\u0026amp;) . Constexpr where possible.\nRequires: Always available.\nComplexity: Constant time.\nGuarantees: Never throws an exception.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/basic_outcome/explicit_inplace_error_constructor_il/",
	"title": "`explicit basic_outcome(in_place_type_t&lt;error_type_if_enabled&gt;, std::initializer_list&lt;U&gt;, Args ...)`",
	"tags": [],
	"description": "Explicit inplace error constructor. Available if `predicate::enable_inplace_error_constructor&lt;std::initializer_list&lt;U&gt;, Args ...&gt;` is true. Constexpr, triviality and noexcept propagating.",
	"content": "Explicit inplace error constructor. Calls void on_outcome_in_place_construction(T *, in_place_type_t\u0026lt;U\u0026gt;, Args \u0026amp;\u0026amp;...) noexcept with this, in_place_type\u0026lt;error_type\u0026gt;, std::initializer_list\u0026lt;U\u0026gt; and Args ....\nRequires: predicate::enable_inplace_error_constructor\u0026lt;std::initializer_list\u0026lt;U\u0026gt;, Args ...\u0026gt; is true.\nComplexity: Same as for the error_type constructor which accepts std::initializer_list\u0026lt;U\u0026gt;, Args .... Constexpr, triviality and noexcept of underlying operations is propagated.\nGuarantees: If an exception is thrown during the operation, the state of the Args is left indeterminate.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/basic_result/explicit_inplace_error_constructor_il/",
	"title": "`explicit basic_result(in_place_type_t&lt;error_type_if_enabled&gt;, std::initializer_list&lt;U&gt;, Args ...)`",
	"tags": [],
	"description": "Explicit inplace error constructor. Available if `predicate::enable_inplace_error_constructor&lt;std::initializer_list&lt;U&gt;, Args ...&gt;` is true. Constexpr, triviality and noexcept propagating.",
	"content": "Explicit inplace error constructor. Calls void on_result_in_place_construction(T *, in_place_type_t\u0026lt;U\u0026gt;, Args \u0026amp;\u0026amp;...) noexcept with this, in_place_type\u0026lt;error_type\u0026gt;, std::initializer_list\u0026lt;U\u0026gt; and Args ....\nRequires: predicate::enable_inplace_error_constructor\u0026lt;std::initializer_list\u0026lt;U\u0026gt;, Args ...\u0026gt; is true.\nComplexity: Same as for the error_type constructor which accepts std::initializer_list\u0026lt;U\u0026gt;, Args .... Constexpr, triviality and noexcept of underlying operations is propagated.\nGuarantees: If an exception is thrown during the operation, the state of the Args is left indeterminate.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/basic_outcome/explicit_inplace_exception_constructor/",
	"title": "`explicit basic_outcome(in_place_type_t&lt;exception_type_if_enabled&gt;, Args ...)`",
	"tags": [],
	"description": "Explicit inplace exception constructor. Available if `predicate::enable_inplace_exception_constructor&lt;Args ...&gt;` is true. Constexpr, triviality and noexcept propagating.",
	"content": "Explicit inplace exception constructor. Calls void on_outcome_in_place_construction(T *, in_place_type_t\u0026lt;U\u0026gt;, Args \u0026amp;\u0026amp;...) noexcept with this, in_place_type\u0026lt;exception_type\u0026gt; and Args ....\nRequires: predicate::enable_inplace_exception_constructor\u0026lt;Args ...\u0026gt; is true.\nComplexity: Same as for the exception_type constructor which accepts Args .... Constexpr, triviality and noexcept of underlying operations is propagated.\nGuarantees: If an exception is thrown during the operation, the state of the Args is left indeterminate.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/basic_outcome/explicit_inplace_exception_constructor_il/",
	"title": "`explicit basic_outcome(in_place_type_t&lt;exception_type_if_enabled&gt;, std::initializer_list&lt;U&gt;, Args ...)`",
	"tags": [],
	"description": "Explicit inplace exception constructor. Available if `predicate::enable_inplace_exception_constructor&lt;std::initializer_list&lt;U&gt;, Args ...&gt;` is true. Constexpr, triviality and noexcept propagating.",
	"content": "Explicit inplace exception constructor. Calls void on_outcome_in_place_construction(T *, in_place_type_t\u0026lt;U\u0026gt;, Args \u0026amp;\u0026amp;...) noexcept with this, in_place_type\u0026lt;exception_type\u0026gt;, std::initializer_list\u0026lt;U\u0026gt; and Args ....\nRequires: predicate::enable_inplace_exception_constructor\u0026lt;std::initializer_list\u0026lt;U\u0026gt;, Args ...\u0026gt; is true.\nComplexity: Same as for the exception_type constructor which accepts std::initializer_list\u0026lt;U\u0026gt;, Args .... Constexpr, triviality and noexcept of underlying operations is propagated.\nGuarantees: If an exception is thrown during the operation, the state of the Args is left indeterminate.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/basic_outcome/implicit_inplace_value_error_exception_constructor/",
	"title": "`basic_outcome(A1 &amp;&amp;, A2 &amp;&amp;, Args ...)`",
	"tags": [],
	"description": "Implicit inplace value or error or exception constructor. Available if `predicate::enable_inplace_value_error_exception_constructor&lt;A1, A2, Args ...&gt;` is true. Constexpr, triviality and noexcept propagating.",
	"content": "Implicit inplace value or error or exception constructor. Delegates to an appropriate explicit inplace constructor depending on input.\nRequires: predicate::enable_inplace_value_error_exception_constructor` is true.\nComplexity: Same as for the value_type or error_type or exception_type constructor which accepts A1, A2, Args .... Constexpr, triviality and noexcept of underlying operations is propagated.\nGuarantees: If an exception is thrown during the operation, the state of the Args is left indeterminate.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/basic_result/implicit_inplace_value_error_constructor/",
	"title": "`basic_result(A1 &amp;&amp;, A2 &amp;&amp;, Args ...)`",
	"tags": [],
	"description": "Implicit inplace value or error constructor. Available if `predicate::enable_inplace_value_error_constructor&lt;A1, A2, Args ...&gt;` is true. Constexpr, triviality and noexcept propagating.",
	"content": "Implicit inplace value or error constructor. Delegates to an appropriate explicit inplace constructor depending on input.\nRequires: predicate::enable_inplace_value_error_constructor` is true.\nComplexity: Same as for the value_type or error_type constructor which accepts A1, A2, Args .... Constexpr, triviality and noexcept of underlying operations is propagated.\nGuarantees: If an exception is thrown during the operation, the state of the Args is left indeterminate.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/policies/base/on_outcome_construction/",
	"title": "`static void on_outcome_construction(T *, U &amp;&amp;) noexcept`",
	"tags": [],
	"description": "(&gt;= Outcome v2.2.0) Hook invoked by the implicit constructors of `basic_outcome`.",
	"content": "One of the constructor hooks for basic_outcome\u0026lt;T, EC, EP, NoValuePolicy\u0026gt; , generally invoked by the implicit constructors of basic_outcome. See each constructor\u0026rsquo;s documentation to see which specific hook it invokes.\nRequires: Always available.\nGuarantees: Never throws an exception.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/policies/base/on_outcome_construction2/",
	"title": "`static void on_outcome_construction(T *, U &amp;&amp;, V &amp;&amp;) noexcept`",
	"tags": [],
	"description": "(&gt;= Outcome v2.2.0) Hook invoked by the implicit constructors of `basic_outcome`.",
	"content": "One of the constructor hooks for basic_outcome\u0026lt;T, EC, EP, NoValuePolicy\u0026gt; , generally invoked by the implicit constructors of basic_outcome which consume two arguments. See each constructor\u0026rsquo;s documentation to see which specific hook it invokes.\nRequires: Always available.\nGuarantees: Never throws an exception.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/policies/base/on_outcome_copy_construction/",
	"title": "`static void on_outcome_copy_construction(T *, U &amp;&amp;) noexcept`",
	"tags": [],
	"description": "(&gt;= Outcome v2.2.0) Hook invoked by the converting copy constructors of `basic_outcome`.",
	"content": "One of the constructor hooks for basic_outcome\u0026lt;T, EC, EP, NoValuePolicy\u0026gt; , generally invoked by the converting copy constructors of basic_outcome (NOT the standard copy constructor). See each constructor\u0026rsquo;s documentation to see which specific hook it invokes.\nRequires: Always available.\nGuarantees: Never throws an exception.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/policies/base/on_outcome_copy_construction2/",
	"title": "`static void on_outcome_copy_construction(T *, U &amp;&amp;, V &amp;&amp;) noexcept`",
	"tags": [],
	"description": "(&gt;= Outcome v2.2.0) Hook invoked by the converting copy constructors of `basic_outcome`.",
	"content": "One of the constructor hooks for basic_outcome\u0026lt;T, EC, EP, NoValuePolicy\u0026gt; , generally invoked by the converting copy constructors of basic_outcome (NOT the standard copy constructor) which consume two arguments. See each constructor\u0026rsquo;s documentation to see which specific hook it invokes.\nRequires: Always available.\nGuarantees: Never throws an exception.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/policies/base/on_outcome_in_place_construction/",
	"title": "`static void on_outcome_in_place_construction(T *, in_place_type_t&lt;U&gt;, Args &amp;&amp;...) noexcept`",
	"tags": [],
	"description": "(&gt;= Outcome v2.2.0) Hook invoked by the in-place constructors of `basic_outcome`.",
	"content": "One of the constructor hooks for basic_outcome\u0026lt;T, EC, EP, NoValuePolicy\u0026gt; , generally invoked by the in-place constructors of basic_outcome. See each constructor\u0026rsquo;s documentation to see which specific hook it invokes.\nRequires: Always available.\nGuarantees: Never throws an exception.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/policies/base/on_outcome_move_construction/",
	"title": "`static void on_outcome_move_construction(T *, U &amp;&amp;) noexcept`",
	"tags": [],
	"description": "(&gt;= Outcome v2.2.0) Hook invoked by the converting move constructors of `basic_outcome`.",
	"content": "One of the constructor hooks for basic_outcome\u0026lt;T, EC, EP, NoValuePolicy\u0026gt; , generally invoked by the converting move constructors of basic_outcome (NOT the standard move constructor). See each constructor\u0026rsquo;s documentation to see which specific hook it invokes.\nRequires: Always available.\nGuarantees: Never throws an exception.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/policies/base/on_outcome_move_construction2/",
	"title": "`static void on_outcome_move_construction(T *, U &amp;&amp;, V &amp;&amp;) noexcept`",
	"tags": [],
	"description": "(&gt;= Outcome v2.2.0) Hook invoked by the converting move constructors of `basic_outcome`.",
	"content": "One of the constructor hooks for basic_outcome\u0026lt;T, EC, EP, NoValuePolicy\u0026gt; , generally invoked by the converting move constructors of basic_outcome (NOT the standard move constructor) which consume two arguments. See each constructor\u0026rsquo;s documentation to see which specific hook it invokes.\nRequires: Always available.\nGuarantees: Never throws an exception.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/policies/base/on_result_construction/",
	"title": "`static void on_result_construction(T *, U &amp;&amp;) noexcept`",
	"tags": [],
	"description": "(&gt;= Outcome v2.2.0) Hook invoked by the implicit constructors of `basic_result`.",
	"content": "One of the constructor hooks for basic_result\u0026lt;T, E, NoValuePolicy\u0026gt; , generally invoked by the implicit constructors of basic_result. See each constructor\u0026rsquo;s documentation to see which specific hook it invokes.\nRequires: Always available.\nGuarantees: Never throws an exception.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/policies/base/on_result_copy_construction/",
	"title": "`static void on_result_copy_construction(T *, U &amp;&amp;) noexcept`",
	"tags": [],
	"description": "(&gt;= Outcome v2.2.0) Hook invoked by the converting copy constructors of `basic_result`.",
	"content": "One of the constructor hooks for basic_result\u0026lt;T, E, NoValuePolicy\u0026gt; , generally invoked by the converting copy constructors of basic_result (NOT the standard copy constructor). See each constructor\u0026rsquo;s documentation to see which specific hook it invokes.\nRequires: Always available.\nGuarantees: Never throws an exception.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/policies/base/on_result_in_place_construction/",
	"title": "`static void on_result_in_place_construction(T *, in_place_type_t&lt;U&gt;, Args &amp;&amp;...) noexcept`",
	"tags": [],
	"description": "(&gt;= Outcome v2.2.0) Hook invoked by the in-place constructors of `basic_result`.",
	"content": "One of the constructor hooks for basic_result\u0026lt;T, E, NoValuePolicy\u0026gt; , generally invoked by the in-place constructors of basic_result. See each constructor\u0026rsquo;s documentation to see which specific hook it invokes.\nRequires: Always available.\nGuarantees: Never throws an exception.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/policies/base/on_result_move_construction/",
	"title": "`static void on_result_move_construction(T *, U &amp;&amp;) noexcept`",
	"tags": [],
	"description": "(&gt;= Outcome v2.2.0) Hook invoked by the converting move constructors of `basic_result`.",
	"content": "One of the constructor hooks for basic_result\u0026lt;T, E, NoValuePolicy\u0026gt; , generally invoked by the converting move constructors of basic_result (NOT the standard move constructor). See each constructor\u0026rsquo;s documentation to see which specific hook it invokes.\nRequires: Always available.\nGuarantees: Never throws an exception.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/basic_outcome/implicit_success_copy_constructor/",
	"title": "`basic_outcome(const success_type&lt;T&gt; &amp;)`",
	"tags": [],
	"description": "Implicit value-from-success-type-sugar copy constructor. Available if `predicate::enable_compatible_conversion&lt;T, void, void&gt;` is true, or `T` is `void`. Constexpr, triviality and noexcept propagating.",
	"content": "Implicit value-from-success-type-sugar copy constructor used to disambiguate the construction of the value type. Note that if T = void, value_type will be default constructed. Calls void on_outcome_copy_construction(T *, U \u0026amp;\u0026amp;) noexcept with this and const success_type\u0026lt;T\u0026gt; \u0026amp;.\nRequires: predicate::enable_compatible_conversion\u0026lt;T, void, void\u0026gt; is true, or T is void.\nComplexity: Same as for the value_type constructor which accepts T, or the value_type default constructor if T is void. Constexpr, triviality and noexcept of underlying operations is propagated.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/basic_result/implicit_success_copy_constructor/",
	"title": "`basic_result(const success_type&lt;T&gt; &amp;)`",
	"tags": [],
	"description": "Implicit value-from-success-type-sugar copy constructor. Available if `predicate::enable_compatible_conversion&lt;T, void, void&gt;` is true, or `T` is `void`. Constexpr, triviality and noexcept propagating.",
	"content": "Implicit value-from-success-type-sugar copy constructor used to disambiguate the construction of the value type. Note that if T = void, value_type will be default constructed. Calls void on_result_copy_construction(T *, U \u0026amp;\u0026amp;) noexcept with this and const success_type\u0026lt;T\u0026gt; \u0026amp;.\nRequires: predicate::enable_compatible_conversion\u0026lt;T, void, void\u0026gt; is true, or T is void.\nComplexity: Same as for the value_type constructor which accepts T, or the value_type default constructor if T is void. Constexpr, triviality and noexcept of underlying operations is propagated.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/basic_outcome/implicit_success_move_constructor/",
	"title": "`basic_outcome(success_type&lt;T&gt; &amp;&amp;)`",
	"tags": [],
	"description": "Implicit value-from-success-type-sugar move constructor. Available if `predicate::enable_compatible_conversion&lt;T, void, void&gt;` is true, or `T` is `void`. Constexpr, triviality and noexcept propagating.",
	"content": "Implicit value-from-success-type-sugar move constructor used to disambiguate the construction of the value type. Note that if T = void, value_type will be default constructed. Calls void on_outcome_move_construction(T *, U \u0026amp;\u0026amp;) noexcept with this and success_type\u0026lt;T\u0026gt; \u0026amp;\u0026amp;.\nRequires: predicate::enable_compatible_conversion\u0026lt;T, void, void\u0026gt; is true, or T is void.\nComplexity: Same as for the value_type constructor which accepts T, or the value_type default constructor if T is void. Constexpr, triviality and noexcept of underlying operations is propagated.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/basic_result/implicit_success_move_constructor/",
	"title": "`basic_result(success_type&lt;T&gt; &amp;&amp;)`",
	"tags": [],
	"description": "Implicit value-from-success-type-sugar move constructor. Available if `predicate::enable_compatible_conversion&lt;T, void, void&gt;` is true, or `T` is `void`. Constexpr, triviality and noexcept propagating.",
	"content": "Implicit value-from-success-type-sugar move constructor used to disambiguate the construction of the value type. Note that if T = void, value_type will be default constructed. Calls void on_result_move_construction(T *, U \u0026amp;\u0026amp;) noexcept with this and success_type\u0026lt;T\u0026gt; \u0026amp;\u0026amp;.\nRequires: predicate::enable_compatible_conversion\u0026lt;T, void, void\u0026gt; is true, or T is void.\nComplexity: Same as for the value_type constructor which accepts T, or the value_type default constructor if T is void. Constexpr, triviality and noexcept of underlying operations is propagated.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/basic_outcome/implicit_failure_error_copy_constructor/",
	"title": "`basic_outcome(const failure_type&lt;EC&gt; &amp;)`",
	"tags": [],
	"description": "Implicit error-from-failure-type-sugar copy constructor. Available if `predicate::enable_compatible_conversion&lt;void, EC, void, void&gt;` is true. Constexpr, triviality and noexcept propagating.",
	"content": "Implicit error-from-failure-type-sugar copy constructor used to disambiguate the construction of the error type. Calls void on_outcome_copy_construction(T *, U \u0026amp;\u0026amp;) noexcept with this and const failure_type\u0026lt;EC\u0026gt; \u0026amp;.\nRequires: predicate::enable_compatible_conversion\u0026lt;void, EC, void, void\u0026gt; is true.\nComplexity: Same as for the error_type constructor which accepts EC. Constexpr, triviality and noexcept of underlying operations is propagated.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/basic_result/implicit_failure_copy_constructor/",
	"title": "`basic_result(const failure_type&lt;T&gt; &amp;)`",
	"tags": [],
	"description": "Implicit error-from-failure-type-sugar copy constructor. Available if `predicate::enable_compatible_conversion&lt;void, T, void&gt;` is true, or `T` is `void`. Constexpr, triviality and noexcept propagating.",
	"content": "Implicit error-from-failure-type-sugar copy constructor used to disambiguate the construction of the error type. Note that if T = void, error_type will be default constructed. Calls void on_result_copy_construction(T *, U \u0026amp;\u0026amp;) noexcept with this and const failure_type\u0026lt;T\u0026gt; \u0026amp;.\nRequires: predicate::enable_compatible_conversion\u0026lt;void, T, void\u0026gt; is true, or T is void.\nComplexity: Same as for the error_type constructor which accepts T, or the error_type default constructor if T is void. Constexpr, triviality and noexcept of underlying operations is propagated.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/basic_outcome/implicit_failure_error_move_constructor/",
	"title": "`basic_outcome(failure_type&lt;EC&gt; &amp;&amp;)`",
	"tags": [],
	"description": "Implicit error-from-failure-type-sugar move constructor. Available if `predicate::enable_compatible_conversion&lt;void, EC, void, void&gt;` is true. Constexpr, triviality and noexcept propagating.",
	"content": "Implicit error-from-failure-type-sugar move constructor used to disambiguate the construction of the error type. Calls void on_outcome_move_construction(T *, U \u0026amp;\u0026amp;) noexcept with this and failure_type\u0026lt;EC\u0026gt; \u0026amp;\u0026amp;.\nRequires: predicate::enable_compatible_conversion\u0026lt;void, EC, void, void\u0026gt; is true.\nComplexity: Same as for the error_type constructor which accepts EC. Constexpr, triviality and noexcept of underlying operations is propagated.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/basic_result/implicit_failure_move_constructor/",
	"title": "`basic_result(failure_type&lt;T&gt; &amp;&amp;)`",
	"tags": [],
	"description": "Implicit error-from-failure-type-sugar move constructor. Available if `predicate::enable_compatible_conversion&lt;void, T, void&gt;` is true, or `T` is `void`. Constexpr, triviality and noexcept propagating.",
	"content": "Implicit error-from-failure-type-sugar move constructor used to disambiguate the construction of the error type. Note that if T = void, error_type will be default constructed. Calls void on_result_move_construction(T *, U \u0026amp;\u0026amp;) noexcept with this and failure_type\u0026lt;T\u0026gt; \u0026amp;\u0026amp;.\nRequires: predicate::enable_compatible_conversion\u0026lt;void, T, void\u0026gt; is true, or T is void.\nComplexity: Same as for the error_type constructor which accepts T, or the error_type default constructor if T is void. Constexpr, triviality and noexcept of underlying operations is propagated.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/basic_outcome/implicit_failure_error_make_error_code_copy_constructor/",
	"title": "`basic_outcome(const failure_type&lt;EC&gt; &amp;)`",
	"tags": [],
	"description": "Implicit error-from-failure-type-sugar copy constructor. Available if `predicate::enable_make_error_code_compatible_conversion&lt;void, EC, void, void&gt;` is true. Constexpr, triviality and noexcept propagating.",
	"content": "Implicit error-from-failure-type-sugar copy constructor used to disambiguate the construction of the error type. Calls void on_outcome_copy_construction(T *, U \u0026amp;\u0026amp;) noexcept with this and const failure_type\u0026lt;EC\u0026gt; \u0026amp;.\nRequires: predicate::enable_make_error_code_compatible_conversion\u0026lt;void, EC, void, void\u0026gt; is true.\nComplexity: Same as for the error_type constructor which accepts EC. Constexpr, triviality and noexcept of underlying operations is propagated.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/basic_result/implicit_failure_make_error_code_copy_constructor/",
	"title": "`basic_result(const failure_type&lt;T&gt; &amp;)`",
	"tags": [],
	"description": "Implicit error-from-failure-type-sugar copy constructor. Available if `predicate::enable_make_error_code_compatible_conversion&lt;void, T, void&gt;` is true, or `T` is `void`. Constexpr, triviality and noexcept propagating.",
	"content": "Implicit error-from-failure-type-sugar copy constructor used to disambiguate the construction of the error type. Note that if T = void, error_type will be default constructed. Calls void on_result_copy_construction(T *, U \u0026amp;\u0026amp;) noexcept with this and const failure_type\u0026lt;T\u0026gt; \u0026amp;.\nRequires: predicate::enable_make_error_code_compatible_conversion\u0026lt;void, T, void\u0026gt; is true, or T is void.\nComplexity: Same as for the error_type constructor which accepts T, or the error_type default constructor if T is void. Constexpr, triviality and noexcept of underlying operations is propagated.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/basic_outcome/implicit_failure_error_make_error_code_move_constructor/",
	"title": "`basic_outcome(failure_type&lt;EC&gt; &amp;&amp;)`",
	"tags": [],
	"description": "Implicit error-from-failure-type-sugar move constructor. Available if `predicate::enable_make_error_code_compatible_conversion&lt;void, EC, void, void&gt;` is true. Constexpr, triviality and noexcept propagating.",
	"content": "Implicit error-from-failure-type-sugar move constructor used to disambiguate the construction of the error type. Calls void on_outcome_move_construction(T *, U \u0026amp;\u0026amp;) noexcept with this and failure_type\u0026lt;EC\u0026gt; \u0026amp;\u0026amp;.\nRequires: predicate::enable_make_error_code_compatible_conversion\u0026lt;void, EC, void, void\u0026gt; is true.\nComplexity: Same as for the error_type constructor which accepts EC. Constexpr, triviality and noexcept of underlying operations is propagated.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/basic_result/implicit_failure_make_error_code_move_constructor/",
	"title": "`basic_result(failure_type&lt;T&gt; &amp;&amp;)`",
	"tags": [],
	"description": "Implicit error-from-failure-type-sugar move constructor. Available if `predicate::enable_make_error_code_compatible_conversion&lt;void, T, void&gt;` is true, or `T` is `void`. Constexpr, triviality and noexcept propagating.",
	"content": "Implicit error-from-failure-type-sugar move constructor used to disambiguate the construction of the error type. Note that if T = void, error_type will be default constructed. Calls void on_result_move_construction(T *, U \u0026amp;\u0026amp;) noexcept with this and failure_type\u0026lt;T\u0026gt; \u0026amp;\u0026amp;.\nRequires: predicate::enable_make_error_code_compatible_conversion\u0026lt;void, T, void\u0026gt; is true, or T is void.\nComplexity: Same as for the error_type constructor which accepts T, or the error_type default constructor if T is void. Constexpr, triviality and noexcept of underlying operations is propagated.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/basic_result/implicit_failure_make_exception_ptr_copy_constructor/",
	"title": "`basic_result(const failure_type&lt;T&gt; &amp;)`",
	"tags": [],
	"description": "Implicit error-from-failure-type-sugar copy constructor. Available if `predicate::enable_make_exception_ptr_compatible_conversion&lt;void, T, void&gt;` is true, or `T` is `void`. Constexpr, triviality and noexcept propagating.",
	"content": "Implicit error-from-failure-type-sugar copy constructor used to disambiguate the construction of the error type. Note that if T = void, error_type will be default constructed. Calls void on_result_copy_construction(T *, U \u0026amp;\u0026amp;) noexcept with this and const failure_type\u0026lt;T\u0026gt; \u0026amp;.\nRequires: predicate::enable_make_exception_ptr_compatible_conversion\u0026lt;void, T, void\u0026gt; is true, or T is void.\nComplexity: Same as for the error_type constructor which accepts T, or the error_type default constructor if T is void. Constexpr, triviality and noexcept of underlying operations is propagated.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/basic_outcome/implicit_failure_exception_copy_constructor/",
	"title": "`basic_outcome(const failure_type&lt;EP&gt; &amp;)`",
	"tags": [],
	"description": "Implicit exception-from-failure-type-sugar copy constructor. Available if `predicate::enable_compatible_conversion&lt;void, void, EP, void&gt;` is true. Constexpr, triviality and noexcept propagating.",
	"content": "Implicit exception-from-failure-type-sugar copy constructor used to disambiguate the construction of the exception type. Calls void on_outcome_copy_construction(T *, U \u0026amp;\u0026amp;) noexcept with this and const failure_type\u0026lt;EP\u0026gt; \u0026amp;.\nRequires: predicate::enable_compatible_conversion\u0026lt;void, void, EP, void\u0026gt; is true.\nComplexity: Same as for the exception_type constructor which accepts EP. Constexpr, triviality and noexcept of underlying operations is propagated.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/basic_result/implicit_failure_make_exception_ptr_move_constructor/",
	"title": "`basic_result(failure_type&lt;T&gt; &amp;&amp;)`",
	"tags": [],
	"description": "Implicit error-from-failure-type-sugar move constructor. Available if `predicate::enable_make_exception_ptr_compatible_conversion&lt;void, T, void&gt;` is true, or `T` is `void`. Constexpr, triviality and noexcept propagating.",
	"content": "Implicit error-from-failure-type-sugar move constructor used to disambiguate the construction of the error type. Note that if T = void, error_type will be default constructed. Calls void on_result_move_construction(T *, U \u0026amp;\u0026amp;) noexcept with this and failure_type\u0026lt;T\u0026gt; \u0026amp;\u0026amp;.\nRequires: predicate::enable_make_exception_ptr_compatible_conversion\u0026lt;void, T, void\u0026gt; is true, or T is void.\nComplexity: Same as for the error_type constructor which accepts T, or the error_type default constructor if T is void. Constexpr, triviality and noexcept of underlying operations is propagated.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/basic_outcome/implicit_failure_exception_move_constructor/",
	"title": "`basic_outcome(failure_type&lt;EP&gt; &amp;&amp;)`",
	"tags": [],
	"description": "Implicit exception-from-failure-type-sugar move constructor. Available if `predicate::enable_compatible_conversion&lt;void, void, EP, void&gt;` is true. Constexpr, triviality and noexcept propagating.",
	"content": "Implicit exception-from-failure-type-sugar move constructor used to disambiguate the construction of the exception type. Calls void on_outcome_move_construction(T *, U \u0026amp;\u0026amp;) noexcept with this and failure_type\u0026lt;EP\u0026gt; \u0026amp;\u0026amp;.\nRequires: predicate::enable_compatible_conversion\u0026lt;void, void, EP, void\u0026gt; is true.\nComplexity: Same as for the exception_type constructor which accepts EP. Constexpr, triviality and noexcept of underlying operations is propagated.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/basic_outcome/implicit_failure_error_exception_copy_constructor/",
	"title": "`basic_outcome(const failure_type&lt;EC, EP&gt; &amp;)`",
	"tags": [],
	"description": "Implicit error-and-exception-from-failure-type-sugar copy constructor. Available if `predicate::enable_compatible_conversion&lt;void, EC, EP, void&gt;` is true. Constexpr, triviality and noexcept propagating.",
	"content": "Implicit error-and-exception-from-failure-type-sugar copy constructor used to disambiguate the construction of the error + exception types. Calls void on_outcome_copy_construction(T *, U \u0026amp;\u0026amp;, V \u0026amp;\u0026amp;) noexcept with this, const failure_type\u0026lt;EC\u0026gt; \u0026amp; and const failure_type\u0026lt;EP\u0026gt; \u0026amp;.\nRequires: predicate::enable_compatible_conversion\u0026lt;void, EC, EP, void\u0026gt; is true.\nComplexity: Same as for the error_type and exception_type constructors which accept EC and EP. Constexpr, triviality and noexcept of underlying operations is propagated.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/basic_outcome/implicit_failure_error_exception_move_constructor/",
	"title": "`basic_outcome(failure_type&lt;EC, EP&gt; &amp;&amp;)`",
	"tags": [],
	"description": "Implicit error-and-exception-from-failure-type-sugar move constructor. Available if `predicate::enable_compatible_conversion&lt;void, EC, EP, void&gt;` is true. Constexpr, triviality and noexcept propagating.",
	"content": "Implicit error-and-exception-from-failure-type-sugar move constructor used to disambiguate the construction of the error + exception types. Calls void on_outcome_move_construction(T *, U \u0026amp;\u0026amp;, V \u0026amp;\u0026amp;) noexcept with this, failure_type\u0026lt;EC\u0026gt; \u0026amp;\u0026amp; and failure_type\u0026lt;EP\u0026gt; \u0026amp;\u0026amp;.\nRequires: predicate::enable_compatible_conversion\u0026lt;void, EC, EP, void\u0026gt; is true.\nComplexity: Same as for the error_type and exception_type constructors which accept EC and EP. Constexpr, triviality and noexcept of underlying operations is propagated.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/basic_outcome/operator_bool/",
	"title": "`explicit operator bool() const noexcept`",
	"tags": [],
	"description": "Returns true if a value is present. Constexpr, never throws.",
	"content": "Returns true if a value is present. Constexpr where possible. Alias for bool has_value() const noexcept .\nRequires: Always available.\nComplexity: Constant time.\nGuarantees: Never throws an exception.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/basic_result/operator_bool/",
	"title": "`explicit operator bool() const noexcept`",
	"tags": [],
	"description": "Returns true if a value is present. Constexpr, never throws.",
	"content": "Returns true if a value is present. Constexpr where possible. Alias for bool has_value() const noexcept .\nRequires: Always available.\nComplexity: Constant time.\nGuarantees: Never throws an exception.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/basic_outcome/has_value/",
	"title": "`bool has_value() const noexcept`",
	"tags": [],
	"description": "Returns true if a value is present. Constexpr, never throws.",
	"content": "Returns true if a value is present. Constexpr where possible. Alias for explicit operator bool() const noexcept .\nRequires: Always available.\nComplexity: Constant time.\nGuarantees: Never throws an exception.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/basic_result/has_value/",
	"title": "`bool has_value() const noexcept`",
	"tags": [],
	"description": "Returns true if a value is present. Constexpr, never throws.",
	"content": "Returns true if a value is present. Constexpr where possible. Alias for explicit operator bool() const noexcept .\nRequires: Always available.\nComplexity: Constant time.\nGuarantees: Never throws an exception.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/basic_outcome/has_error/",
	"title": "`bool has_error() const noexcept`",
	"tags": [],
	"description": "Returns true if an error is present. Constexpr, never throws.",
	"content": "Returns true if an error is present. Constexpr where possible.\nRequires: Always available.\nComplexity: Constant time.\nGuarantees: Never throws an exception.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/basic_result/has_error/",
	"title": "`bool has_error() const noexcept`",
	"tags": [],
	"description": "Returns true if an error is present. Constexpr, never throws.",
	"content": "Returns true if an error is present. Constexpr where possible.\nRequires: Always available.\nComplexity: Constant time.\nGuarantees: Never throws an exception.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/basic_outcome/has_exception/",
	"title": "`bool has_exception() const noexcept`",
	"tags": [],
	"description": "Returns true if an exception is present. Constexpr, never throws.",
	"content": "Returns true if an exception is present. Constexpr where possible.\nRequires: Always available.\nComplexity: Constant time.\nGuarantees: Never throws an exception.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/basic_result/has_exception/",
	"title": "`bool has_exception() const noexcept`",
	"tags": [],
	"description": "Always returns false for `basic_result`. Constexpr, never throws.",
	"content": "Always returns false for basic_result. Constexpr where possible.\nRequires: Always available.\nComplexity: Constant time.\nGuarantees: Never throws an exception.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/basic_outcome/has_failure/",
	"title": "`bool has_failure() const noexcept`",
	"tags": [],
	"description": "Returns true if there is either an error or an exception. Constexpr, never throws.",
	"content": "Returns true if there is either an error or an exception. Constexpr where possible.\nRequires: Always available.\nComplexity: Constant time.\nGuarantees: Never throws an exception.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/basic_result/has_failure/",
	"title": "`bool has_failure() const noexcept`",
	"tags": [],
	"description": "Returns true if there is either an error or an exception. Constexpr, never throws.",
	"content": "Returns true if there is either an error or an exception. Constexpr where possible.\nRequires: Always available.\nComplexity: Constant time.\nGuarantees: Never throws an exception.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/basic_result/has_lost_consistency/",
	"title": "`bool has_lost_consistency() const noexcept`",
	"tags": [],
	"description": "Returns true if a preceding swap involving this object failed to preserve the strong guarantee. Constexpr, never throws.",
	"content": "Returns true if a preceding swap involving this object failed to preserve the strong guarantee. Constexpr where possible.\nRequires: Always available.\nComplexity: Constant time.\nGuarantees: Never throws an exception.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/basic_outcome/assume_value_lvalue/",
	"title": "`value_type &amp;assume_value() &amp; noexcept`",
	"tags": [],
	"description": "Narrow contract lvalue reference observer of any value present. Constexpr propagating, never throws.",
	"content": "Narrow contract lvalue reference observer of any value present. NoValuePolicy::narrow_value_check() is first invoked, then the reference to the value is returned. The convention is that hard undefined behaviour occurs if no value is actually present, however NoValuePolicy::narrow_value_check() can do something to avoid that.\nNote that if value_type is void, only a const overload returning void is present.\nRequires: Always available.\nComplexity: Depends on NoValuePolicy::narrow_value_check().\nGuarantees: An exception is never thrown.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/basic_result/assume_value_lvalue/",
	"title": "`value_type &amp;assume_value() &amp; noexcept`",
	"tags": [],
	"description": "Narrow contract lvalue reference observer of any value present. Constexpr propagating, never throws.",
	"content": "Narrow contract lvalue reference observer of any value present. NoValuePolicy::narrow_value_check() is first invoked, then the reference to the value is returned. The convention is that hard undefined behaviour occurs if no value is actually present, however NoValuePolicy::narrow_value_check() can do something to avoid that.\nNote that if value_type is void, only a const overload returning void is present.\nRequires: Always available.\nComplexity: Depends on NoValuePolicy::narrow_value_check().\nGuarantees: An exception is never thrown.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/basic_outcome/assume_value_lvalue_const/",
	"title": "`const value_type &amp;assume_value() const &amp; noexcept`",
	"tags": [],
	"description": "Narrow contract const lvalue reference observer of any value present. Constexpr propagating, never throws.",
	"content": "Narrow contract const lvalue reference observer of any value present. NoValuePolicy::narrow_value_check() is first invoked, then the reference to the value is returned. The convention is that hard undefined behaviour occurs if no value is actually present, however NoValuePolicy::narrow_value_check() can do something to avoid that.\nNote that if value_type is void, only a const overload returning void is present.\nRequires: Always available.\nComplexity: Depends on NoValuePolicy::narrow_value_check().\nGuarantees: An exception is never thrown.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/basic_result/assume_value_lvalue_const/",
	"title": "`const value_type &amp;assume_value() const &amp; noexcept`",
	"tags": [],
	"description": "Narrow contract const lvalue reference observer of any value present. Constexpr propagating, never throws.",
	"content": "Narrow contract const lvalue reference observer of any value present. NoValuePolicy::narrow_value_check() is first invoked, then the reference to the value is returned. The convention is that hard undefined behaviour occurs if no value is actually present, however NoValuePolicy::narrow_value_check() can do something to avoid that.\nNote that if value_type is void, only a const overload returning void is present.\nRequires: Always available.\nComplexity: Depends on NoValuePolicy::narrow_value_check().\nGuarantees: An exception is never thrown.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/basic_outcome/assume_value_rvalue/",
	"title": "`value_type &amp;&amp;assume_value() &amp;&amp; noexcept`",
	"tags": [],
	"description": "Narrow contract rvalue reference observer of any value present. Constexpr propagating, never throws.",
	"content": "Narrow contract rvalue reference observer of any value present. NoValuePolicy::narrow_value_check() is first invoked, then the reference to the value is returned. The convention is that hard undefined behaviour occurs if no value is actually present, however NoValuePolicy::narrow_value_check() can do something to avoid that.\nNote that if value_type is void, only a const overload returning void is present.\nRequires: Always available.\nComplexity: Depends on NoValuePolicy::narrow_value_check().\nGuarantees: An exception is never thrown.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/basic_result/assume_value_rvalue/",
	"title": "`value_type &amp;&amp;assume_value() &amp;&amp; noexcept`",
	"tags": [],
	"description": "Narrow contract rvalue reference observer of any value present. Constexpr propagating, never throws.",
	"content": "Narrow contract rvalue reference observer of any value present. NoValuePolicy::narrow_value_check() is first invoked, then the reference to the value is returned. The convention is that hard undefined behaviour occurs if no value is actually present, however NoValuePolicy::narrow_value_check() can do something to avoid that.\nNote that if value_type is void, only a const overload returning void is present.\nRequires: Always available.\nComplexity: Depends on NoValuePolicy::narrow_value_check().\nGuarantees: An exception is never thrown.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/basic_outcome/assume_value_rvalue_const/",
	"title": "`const value_type &amp;&amp;assume_value() const &amp;&amp; noexcept`",
	"tags": [],
	"description": "Narrow contract const rvalue reference observer of any value present. Constexpr propagating, never throws.",
	"content": "Narrow contract const rvalue reference observer of any value present. NoValuePolicy::narrow_value_check() is first invoked, then the reference to the value is returned. The convention is that hard undefined behaviour occurs if no value is actually present, however NoValuePolicy::narrow_value_check() can do something to avoid that.\nNote that if value_type is void, only a const overload returning void is present.\nRequires: Always available.\nComplexity: Depends on NoValuePolicy::narrow_value_check().\nGuarantees: An exception is never thrown.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/basic_result/assume_value_rvalue_const/",
	"title": "`const value_type &amp;&amp;assume_value() const &amp;&amp; noexcept`",
	"tags": [],
	"description": "Narrow contract const rvalue reference observer of any value present. Constexpr propagating, never throws.",
	"content": "Narrow contract const rvalue reference observer of any value present. NoValuePolicy::narrow_value_check() is first invoked, then the reference to the value is returned. The convention is that hard undefined behaviour occurs if no value is actually present, however NoValuePolicy::narrow_value_check() can do something to avoid that.\nNote that if value_type is void, only a const overload returning void is present.\nRequires: Always available.\nComplexity: Depends on NoValuePolicy::narrow_value_check().\nGuarantees: An exception is never thrown.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/basic_outcome/value_lvalue/",
	"title": "`value_type &amp;value() &amp;`",
	"tags": [],
	"description": "Wide contract lvalue reference observer of any value present. Constexpr propagating.",
	"content": "Wide contract lvalue reference observer of any value present. NoValuePolicy::wide_value_check() is first invoked, then the reference to the value is returned.\nNote that if value_type is void, only a const overload returning void is present.\nRequires: Always available.\nComplexity: Depends on NoValuePolicy::wide_value_check().\nGuarantees: None.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/basic_result/value_lvalue/",
	"title": "`value_type &amp;value() &amp;`",
	"tags": [],
	"description": "Wide contract lvalue reference observer of any value present. Constexpr propagating.",
	"content": "Wide contract lvalue reference observer of any value present. NoValuePolicy::wide_value_check() is first invoked, then the reference to the value is returned.\nNote that if value_type is void, only a const overload returning void is present.\nRequires: Always available.\nComplexity: Depends on NoValuePolicy::wide_value_check().\nGuarantees: None.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/basic_outcome/value_lvalue_const/",
	"title": "`const value_type &amp;value() const &amp;`",
	"tags": [],
	"description": "Wide contract const lvalue reference observer of any value present. Constexpr propagating.",
	"content": "Wide contract const lvalue reference observer of any value present. NoValuePolicy::wide_value_check() is first invoked, then the reference to the value is returned.\nNote that if value_type is void, only a const overload returning void is present.\nRequires: Always available.\nComplexity: Depends on NoValuePolicy::wide_value_check().\nGuarantees: None.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/basic_result/value_lvalue_const/",
	"title": "`const value_type &amp;value() const &amp;`",
	"tags": [],
	"description": "Wide contract const lvalue reference observer of any value present. Constexpr propagating.",
	"content": "Wide contract const lvalue reference observer of any value present. NoValuePolicy::wide_value_check() is first invoked, then the reference to the value is returned.\nNote that if value_type is void, only a const overload returning void is present.\nRequires: Always available.\nComplexity: Depends on NoValuePolicy::wide_value_check().\nGuarantees: None.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/basic_outcome/value_rvalue/",
	"title": "`value_type &amp;&amp;value() &amp;&amp;`",
	"tags": [],
	"description": "Wide contract rvalue reference observer of any value present. Constexpr propagating.",
	"content": "Wide contract rvalue reference observer of any value present. NoValuePolicy::wide_value_check() is first invoked, then the reference to the value is returned.\nNote that if value_type is void, only a const overload returning void is present.\nRequires: Always available.\nComplexity: Depends on NoValuePolicy::wide_value_check().\nGuarantees: None.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/basic_result/value_rvalue/",
	"title": "`value_type &amp;&amp;value() &amp;&amp;`",
	"tags": [],
	"description": "Wide contract rvalue reference observer of any value present. Constexpr propagating.",
	"content": "Wide contract rvalue reference observer of any value present. NoValuePolicy::wide_value_check() is first invoked, then the reference to the value is returned.\nNote that if value_type is void, only a const overload returning void is present.\nRequires: Always available.\nComplexity: Depends on NoValuePolicy::wide_value_check().\nGuarantees: None.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/basic_outcome/value_rvalue_const/",
	"title": "`const value_type &amp;&amp;value() const &amp;&amp;`",
	"tags": [],
	"description": "Wide contract const rvalue reference observer of any value present. Constexpr propagating.",
	"content": "Wide contract const rvalue reference observer of any value present. NoValuePolicy::wide_value_check() is first invoked, then the reference to the value is returned.\nNote that if value_type is void, only a const overload returning void is present.\nRequires: Always available.\nComplexity: Depends on NoValuePolicy::wide_value_check().\nGuarantees: None.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/basic_result/value_rvalue_const/",
	"title": "`const value_type &amp;&amp;value() const &amp;&amp;`",
	"tags": [],
	"description": "Wide contract const rvalue reference observer of any value present. Constexpr propagating.",
	"content": "Wide contract const rvalue reference observer of any value present. NoValuePolicy::wide_value_check() is first invoked, then the reference to the value is returned.\nNote that if value_type is void, only a const overload returning void is present.\nRequires: Always available.\nComplexity: Depends on NoValuePolicy::wide_value_check().\nGuarantees: None.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/basic_outcome/assume_error_lvalue/",
	"title": "`error_type &amp;assume_error() &amp; noexcept`",
	"tags": [],
	"description": "Narrow contract lvalue reference observer of the stored error. Constexpr propagating, never throws.",
	"content": "Narrow contract lvalue reference observer of the stored error. NoValuePolicy::narrow_error_check() is first invoked, then the reference to the error is returned. As a valid default constructed error is always present, no undefined behaviour occurs unless NoValuePolicy::narrow_error_check() does that.\nNote that if error_type is void, only a const overload returning void is present.\nRequires: Always available.\nComplexity: Depends on NoValuePolicy::narrow_error_check().\nGuarantees: An exception is never thrown.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/basic_result/assume_error_lvalue/",
	"title": "`error_type &amp;assume_error() &amp; noexcept`",
	"tags": [],
	"description": "Narrow contract lvalue reference observer of the stored error. Constexpr propagating, never throws.",
	"content": "Narrow contract lvalue reference observer of the stored error. NoValuePolicy::narrow_error_check() is first invoked, then the reference to the error is returned. As a valid default constructed error is always present, no undefined behaviour occurs unless NoValuePolicy::narrow_error_check() does that.\nNote that if error_type is void, only a const overload returning void is present.\nRequires: Always available.\nComplexity: Depends on NoValuePolicy::narrow_error_check().\nGuarantees: An exception is never thrown.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/basic_outcome/assume_error_lvalue_const/",
	"title": "`const error_type &amp;assume_error() const &amp; noexcept`",
	"tags": [],
	"description": "Narrow contract const lvalue reference observer of the stored error. Constexpr propagating, never throws.",
	"content": "Narrow contract const lvalue reference observer of the stored error. NoValuePolicy::narrow_error_check() is first invoked, then the reference to the error is returned. As a valid default constructed error is always present, no undefined behaviour occurs unless NoValuePolicy::narrow_error_check() does that.\nNote that if error_type is void, only a const overload returning void is present.\nRequires: Always available.\nComplexity: Depends on NoValuePolicy::narrow_error_check().\nGuarantees: An exception is never thrown.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/basic_result/assume_error_lvalue_const/",
	"title": "`const error_type &amp;assume_error() const &amp; noexcept`",
	"tags": [],
	"description": "Narrow contract const lvalue reference observer of the stored error. Constexpr propagating, never throws.",
	"content": "Narrow contract const lvalue reference observer of the stored error. NoValuePolicy::narrow_error_check() is first invoked, then the reference to the error is returned. As a valid default constructed error is always present, no undefined behaviour occurs unless NoValuePolicy::narrow_error_check() does that.\nNote that if error_type is void, only a const overload returning void is present.\nRequires: Always available.\nComplexity: Depends on NoValuePolicy::narrow_error_check().\nGuarantees: An exception is never thrown.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/basic_outcome/assume_error_rvalue/",
	"title": "`error_type &amp;&amp;assume_error() &amp;&amp; noexcept`",
	"tags": [],
	"description": "Narrow contract rvalue reference observer of the stored error. Constexpr propagating, never throws.",
	"content": "Narrow contract rvalue reference observer of the stored error. NoValuePolicy::narrow_error_check() is first invoked, then the reference to the error is returned. As a valid default constructed error is always present, no undefined behaviour occurs unless NoValuePolicy::narrow_error_check() does that.\nNote that if error_type is void, only a const overload returning void is present.\nRequires: Always available.\nComplexity: Depends on NoValuePolicy::narrow_error_check().\nGuarantees: An exception is never thrown.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/basic_result/assume_error_rvalue/",
	"title": "`error_type &amp;&amp;assume_error() &amp;&amp; noexcept`",
	"tags": [],
	"description": "Narrow contract rvalue reference observer of the stored error. Constexpr propagating, never throws.",
	"content": "Narrow contract rvalue reference observer of the stored error. NoValuePolicy::narrow_error_check() is first invoked, then the reference to the error is returned. As a valid default constructed error is always present, no undefined behaviour occurs unless NoValuePolicy::narrow_error_check() does that.\nNote that if error_type is void, only a const overload returning void is present.\nRequires: Always available.\nComplexity: Depends on NoValuePolicy::narrow_error_check().\nGuarantees: An exception is never thrown.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/basic_outcome/assume_error_rvalue_const/",
	"title": "`const error_type &amp;&amp;assume_error() const &amp;&amp; noexcept`",
	"tags": [],
	"description": "Narrow contract const rvalue reference observer of the stored error. Constexpr propagating, never throws.",
	"content": "Narrow contract const rvalue reference observer of the stored error. NoValuePolicy::narrow_error_check() is first invoked, then the reference to the error is returned. As a valid default constructed error is always present, no undefined behaviour occurs unless NoValuePolicy::narrow_error_check() does that.\nNote that if error_type is void, only a const overload returning void is present.\nRequires: Always available.\nComplexity: Depends on NoValuePolicy::narrow_error_check().\nGuarantees: An exception is never thrown.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/basic_result/assume_error_rvalue_const/",
	"title": "`const error_type &amp;&amp;assume_error() const &amp;&amp; noexcept`",
	"tags": [],
	"description": "Narrow contract const rvalue reference observer of the stored error. Constexpr propagating, never throws.",
	"content": "Narrow contract const rvalue reference observer of the stored error. NoValuePolicy::narrow_error_check() is first invoked, then the reference to the error is returned. As a valid default constructed error is always present, no undefined behaviour occurs unless NoValuePolicy::narrow_error_check() does that.\nNote that if error_type is void, only a const overload returning void is present.\nRequires: Always available.\nComplexity: Depends on NoValuePolicy::narrow_error_check().\nGuarantees: An exception is never thrown.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/basic_outcome/error_lvalue/",
	"title": "`error_type &amp;error() &amp;`",
	"tags": [],
	"description": "Wide contract lvalue reference observer of the stored error. Constexpr propagating.",
	"content": "Wide contract lvalue reference observer of the stored error. NoValuePolicy::wide_error_check() is first invoked, then the reference to the error is returned. As a valid default constructed error is always present, no undefined behaviour occurs if NoValuePolicy::wide_error_check() returns.\nNote that if error_type is void, only a const overload returning void is present.\nRequires: Always available.\nComplexity: Depends on NoValuePolicy::wide_error_check().\nGuarantees: None.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/basic_result/error_lvalue/",
	"title": "`error_type &amp;error() &amp;`",
	"tags": [],
	"description": "Wide contract lvalue reference observer of the stored error. Constexpr propagating.",
	"content": "Wide contract lvalue reference observer of the stored error. NoValuePolicy::wide_error_check() is first invoked, then the reference to the error is returned. As a valid default constructed error is always present, no undefined behaviour occurs if NoValuePolicy::wide_error_check() returns.\nNote that if error_type is void, only a const overload returning void is present.\nRequires: Always available.\nComplexity: Depends on NoValuePolicy::wide_error_check().\nGuarantees: None.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/basic_outcome/error_lvalue_const/",
	"title": "`const error_type &amp;error() const &amp;`",
	"tags": [],
	"description": "Wide contract const lvalue reference observer of the stored error. Constexpr propagating.",
	"content": "Wide contract const lvalue reference observer of the stored error. NoValuePolicy::wide_error_check() is first invoked, then the reference to the error is returned. As a valid default constructed error is always present, no undefined behaviour occurs if NoValuePolicy::wide_error_check() returns.\nNote that if error_type is void, only a const overload returning void is present.\nRequires: Always available.\nComplexity: Depends on NoValuePolicy::wide_error_check().\nGuarantees: None.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/basic_result/error_lvalue_const/",
	"title": "`const error_type &amp;error() const &amp;`",
	"tags": [],
	"description": "Wide contract const lvalue reference observer of the stored error. Constexpr propagating.",
	"content": "Wide contract const lvalue reference observer of the stored error. NoValuePolicy::wide_error_check() is first invoked, then the reference to the error is returned. As a valid default constructed error is always present, no undefined behaviour occurs if NoValuePolicy::wide_error_check() returns.\nNote that if error_type is void, only a const overload returning void is present.\nRequires: Always available.\nComplexity: Depends on NoValuePolicy::wide_error_check().\nGuarantees: None.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/basic_outcome/error_rvalue/",
	"title": "`error_type &amp;&amp;error() &amp;&amp;`",
	"tags": [],
	"description": "Wide contract rvalue reference observer of the stored error. Constexpr propagating.",
	"content": "Wide contract rvalue reference observer of the stored error. NoValuePolicy::wide_error_check() is first invoked, then the reference to the error is returned. As a valid default constructed error is always present, no undefined behaviour occurs if NoValuePolicy::wide_error_check() returns.\nNote that if error_type is void, only a const overload returning void is present.\nRequires: Always available.\nComplexity: Depends on NoValuePolicy::wide_error_check().\nGuarantees: None.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/basic_result/error_rvalue/",
	"title": "`error_type &amp;&amp;error() &amp;&amp;`",
	"tags": [],
	"description": "Wide contract rvalue reference observer of the stored error. Constexpr propagating.",
	"content": "Wide contract rvalue reference observer of the stored error. NoValuePolicy::wide_error_check() is first invoked, then the reference to the error is returned. As a valid default constructed error is always present, no undefined behaviour occurs if NoValuePolicy::wide_error_check() returns.\nNote that if error_type is void, only a const overload returning void is present.\nRequires: Always available.\nComplexity: Depends on NoValuePolicy::wide_error_check().\nGuarantees: None.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/basic_outcome/error_rvalue_const/",
	"title": "`const error_type &amp;&amp;error() const &amp;&amp;`",
	"tags": [],
	"description": "Wide contract const rvalue reference observer of the stored error. Constexpr propagating.",
	"content": "Wide contract const rvalue reference observer of the stored error. NoValuePolicy::wide_error_check() is first invoked, then the reference to the error is returned. As a valid default constructed error is always present, no undefined behaviour occurs if NoValuePolicy::wide_error_check() returns.\nNote that if error_type is void, only a const overload returning void is present.\nRequires: Always available.\nComplexity: Depends on NoValuePolicy::wide_error_check().\nGuarantees: None.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/basic_result/error_rvalue_const/",
	"title": "`const error_type &amp;&amp;error() const &amp;&amp;`",
	"tags": [],
	"description": "Wide contract const rvalue reference observer of the stored error. Constexpr propagating.",
	"content": "Wide contract const rvalue reference observer of the stored error. NoValuePolicy::wide_error_check() is first invoked, then the reference to the error is returned. As a valid default constructed error is always present, no undefined behaviour occurs if NoValuePolicy::wide_error_check() returns.\nNote that if error_type is void, only a const overload returning void is present.\nRequires: Always available.\nComplexity: Depends on NoValuePolicy::wide_error_check().\nGuarantees: None.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/basic_outcome/assume_exception_lvalue/",
	"title": "`exception_type &amp;assume_exception() &amp; noexcept`",
	"tags": [],
	"description": "Narrow contract lvalue reference observer of the stored exception. Constexpr propagating, never throws.",
	"content": "Narrow contract lvalue reference observer of the stored exception. NoValuePolicy::narrow_exception_check() is first invoked, then the reference to the exception is returned. As a valid default constructed exception is always present, no undefined behaviour occurs unless NoValuePolicy::narrow_exception_check() does that.\nNote that if exception_type is void, only a const overload returning void is present.\nRequires: Always available.\nComplexity: Depends on NoValuePolicy::narrow_exception_check().\nGuarantees: An exception is never thrown.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/basic_outcome/assume_exception_lvalue_const/",
	"title": "`const exception_type &amp;assume_exception() const &amp; noexcept`",
	"tags": [],
	"description": "Narrow contract const lvalue reference observer of the stored exception. Constexpr propagating, never throws.",
	"content": "Narrow contract const lvalue reference observer of the stored exception. NoValuePolicy::narrow_exception_check() is first invoked, then the reference to the exception is returned. As a valid default constructed exception is always present, no undefined behaviour occurs unless NoValuePolicy::narrow_exception_check() does that.\nNote that if exception_type is void, only a const overload returning void is present.\nRequires: Always available.\nComplexity: Depends on NoValuePolicy::narrow_exception_check().\nGuarantees: An exception is never thrown.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/basic_outcome/assume_exception_rvalue_const/",
	"title": "`const exception_type &amp;&amp;assume_exception() const &amp;&amp; noexcept`",
	"tags": [],
	"description": "Narrow contract const rvalue reference observer of the stored exception. Constexpr propagating, never throws.",
	"content": "Narrow contract const rvalue reference observer of the stored exception. NoValuePolicy::narrow_exception_check() is first invoked, then the reference to the exception is returned. As a valid default constructed exception is always present, no undefined behaviour occurs unless NoValuePolicy::narrow_exception_check() does that.\nNote that if exception_type is void, only a const overload returning void is present.\nRequires: Always available.\nComplexity: Depends on NoValuePolicy::narrow_exception_check().\nGuarantees: An exception is never thrown.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/basic_outcome/assume_exception_rvalue/",
	"title": "`exception_type &amp;&amp;assume_exception() &amp;&amp; noexcept`",
	"tags": [],
	"description": "Narrow contract rvalue reference observer of the stored exception. Constexpr propagating, never throws.",
	"content": "Narrow contract rvalue reference observer of the stored exception. NoValuePolicy::narrow_exception_check() is first invoked, then the reference to the exception is returned. As a valid default constructed exception is always present, no undefined behaviour occurs unless NoValuePolicy::narrow_exception_check() does that.\nNote that if exception_type is void, only a const overload returning void is present.\nRequires: Always available.\nComplexity: Depends on NoValuePolicy::narrow_exception_check().\nGuarantees: An exception is never thrown.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/basic_outcome/exception_lvalue/",
	"title": "`exception_type &amp;exception() &amp;`",
	"tags": [],
	"description": "Wide contract lvalue reference observer of the stored exception. Constexpr propagating.",
	"content": "Wide contract lvalue reference observer of the stored exception. NoValuePolicy::wide_exception_check() is first invoked, then the reference to the exception is returned. As a valid default constructed exception is always present, no undefined behaviour occurs if NoValuePolicy::wide_exception_check() returns.\nNote that if exception_type is void, only a const overload returning void is present.\nRequires: Always available.\nComplexity: Depends on NoValuePolicy::wide_exception_check().\nGuarantees: None.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/basic_outcome/exception_lvalue_const/",
	"title": "`const exception_type &amp;exception() const &amp;`",
	"tags": [],
	"description": "Wide contract const lvalue reference observer of the stored exception. Constexpr propagating.",
	"content": "Wide contract const lvalue reference observer of the stored exception. NoValuePolicy::wide_exception_check() is first invoked, then the reference to the exception is returned. As a valid default constructed exception is always present, no undefined behaviour occurs if NoValuePolicy::wide_exception_check() returns.\nNote that if exception_type is void, only a const overload returning void is present.\nRequires: Always available.\nComplexity: Depends on NoValuePolicy::wide_exception_check().\nGuarantees: None.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/basic_outcome/exception_rvalue/",
	"title": "`exception_type &amp;&amp;exception() &amp;&amp;`",
	"tags": [],
	"description": "Wide contract rvalue reference observer of the stored exception. Constexpr propagating.",
	"content": "Wide contract rvalue reference observer of the stored exception. NoValuePolicy::wide_exception_check() is first invoked, then the reference to the exception is returned. As a valid default constructed exception is always present, no undefined behaviour occurs if NoValuePolicy::wide_exception_check() returns.\nNote that if exception_type is void, only a const overload returning void is present.\nRequires: Always available.\nComplexity: Depends on NoValuePolicy::wide_exception_check().\nGuarantees: None.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/basic_outcome/exception_rvalue_const/",
	"title": "`const exception_type &amp;&amp;exception() const &amp;&amp;`",
	"tags": [],
	"description": "Wide contract const rvalue reference observer of the stored exception. Constexpr propagating.",
	"content": "Wide contract const rvalue reference observer of the stored exception. NoValuePolicy::wide_exception_check() is first invoked, then the reference to the exception is returned. As a valid default constructed exception is always present, no undefined behaviour occurs if NoValuePolicy::wide_exception_check() returns.\nNote that if exception_type is void, only a const overload returning void is present.\nRequires: Always available.\nComplexity: Depends on NoValuePolicy::wide_exception_check().\nGuarantees: None.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/basic_outcome/failure/",
	"title": "`exception_type failure() const noexcept`",
	"tags": [],
	"description": "Synthesising observer of the stored exception or error. Available if the traits `is_error_code_available&lt;T&gt;` and `is_exception_ptr_available&lt;T&gt;` are both true. Never throws.",
	"content": "Synthesising observer of the stored exception or error. If an exception is available, returns a copy of that directly. If an error is available, and not an exception, an ADL discovered free function auto basic_outcome_failure_exception_from_error(const EC \u0026amp;) is invoked. Default overloads for this function are defined in Outcome for  std::error_code and boost::system::error_code, these return std::make_exception_ptr(std::system_error(ec)) and boost::copy_exception(boost::system::system_error(ec)) respectively.\nRequires: Both the traits is_error_code_available\u0026lt;T\u0026gt; and is_exception_ptr_available\u0026lt;T\u0026gt; are true.\nComplexity: Depends on basic_outcome_failure_exception_from_error(const EC \u0026amp;).\nGuarantees: Never throws. If an exception is thrown during the copy of the exception, that exception (from std::current_exception()) is returned instead.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/basic_outcome/equality_basic_result/",
	"title": "`bool operator==(const basic_result&lt;A, B, C&gt; &amp;) const`",
	"tags": [],
	"description": "Returns true if this outcome compares equal to the other result. Constexpr and noexcept propagating.",
	"content": "Returns true if this outcome compares equal to the other result. Comparison is done using operator== on value_type or error_type if the currently chosen state is the same for both outcome and result, otherwise false is returned. Note that if the outcome is excepted, it will never compare equal to a result.\nRequires: operator== must be a valid expression between value_type and A, and between error_type and B. If value_type is void, then so must be A; similarly for error_type and B.\nComplexity: Whatever the underlying operator== have. Constexpr and noexcept of underlying operations is propagated.\nGuarantees: None.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/basic_result/equality_basic_result/",
	"title": "`bool operator==(const basic_result&lt;A, B, C&gt; &amp;) const`",
	"tags": [],
	"description": "Returns true if this result compares equal to the other result. Constexpr and noexcept propagating.",
	"content": "Returns true if this result compares equal to the other result. Comparison is done using operator== on either value_type or error_type if the currently chosen state is the same for both results, otherwise false is returned.\nRequires: operator== must be a valid expression between value_type and A, and between error_type and B. If value_type is void, then so must be A; similarly for error_type and B.\nComplexity: Whatever the underlying operator== have. Constexpr and noexcept of underlying operations is propagated.\nGuarantees: None.\nFree function alias: There is a free function bool operator==(const basic_result\u0026lt;A, B, C\u0026gt; \u0026amp;, const basic_outcome\u0026lt;A, B, C, D\u0026gt; \u0026amp;) which forwards perfectly to this function, by reversing the operands.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/basic_outcome/equality_basic_outcome/",
	"title": "`bool operator==(const basic_outcome&lt;A, B, C, D&gt; &amp;) const`",
	"tags": [],
	"description": "Returns true if this outcome compares equal to the other outcome. Constexpr and noexcept propagating.",
	"content": "Returns true if this outcome compares equal to the other outcome. Comparison is done using operator== on value_type or error_type and/or exception_type if the currently chosen state is the same for both outcomes, otherwise false is returned.\nRequires: operator== must be a valid expression between value_type and A, and between error_type and B, and between exception_type and C. If value_type is void, then so must be A; similarly for error_type and B; similarly for exception_type and C.\nComplexity: Whatever the underlying operator== have. Constexpr and noexcept of underlying operations is propagated.\nGuarantees: None.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/basic_outcome/inequality_success_type/",
	"title": "`bool operator==(const success_type&lt;A&gt; &amp;) const`",
	"tags": [],
	"description": "Returns true if this result compares equal to the success type sugar. Constexpr and noexcept propagating.",
	"content": "Returns true if this result is successful and its value compares equal to the value in the success type sugar. Comparison is done using operator== on value_type and A. If A is void, this call aliases bool has_value() const noexcept .\nRequires: operator== must be a valid expression between value_type and A, or A is void. If value_type is void, then so must be A.\nComplexity: Whatever the underlying operator== has. Constexpr and noexcept of underlying operations is propagated.\nGuarantees: None.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/basic_result/inequality_success_type/",
	"title": "`bool operator==(const success_type&lt;A&gt; &amp;) const`",
	"tags": [],
	"description": "Returns true if this result compares equal to the success type sugar. Constexpr and noexcept propagating.",
	"content": "Returns true if this result is successful and its value compares equal to the value in the success type sugar. Comparison is done using operator== on value_type and A. If A is void, this call aliases bool has_value() const noexcept .\nRequires: operator== must be a valid expression between value_type and A, or A is void. If value_type is void, then so must be A.\nComplexity: Whatever the underlying operator== has. Constexpr and noexcept of underlying operations is propagated.\nGuarantees: None.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/basic_outcome/equality_failure_type/",
	"title": "`bool operator==(const failure_type&lt;A, B&gt; &amp;) const`",
	"tags": [],
	"description": "Returns true if this outcome compares equal to the failure type sugar. Constexpr and noexcept propagating.",
	"content": "Returns true if this outcome is unsuccessful and its error compares equal to the error in the failure type sugar. Comparison is done using operator== on error_type and A and on exception_type and B.\nRequires: operator== must be a valid expression between error_type and A, or A is void; operator== must be a valid expression between exception_type and B, or B is void. If error_type is void, then so must be A; if exception_type is void, then so must be B.\nComplexity: Whatever the underlying operator== has. Constexpr and noexcept of underlying operations is propagated.\nGuarantees: None.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/basic_result/equality_failure_type/",
	"title": "`bool operator==(const failure_type&lt;A, void&gt; &amp;) const`",
	"tags": [],
	"description": "Returns true if this result compares equal to the failure type sugar. Constexpr and noexcept propagating.",
	"content": "Returns true if this result is unsuccessful and its error compares equal to the error in the failure type sugar. Comparison is done using operator== on error_type and A. If A is void, this call aliases bool has_error() const noexcept .\nRequires: operator== must be a valid expression between error_type and A, or A is void. If error_type is void, then so must be A.\nComplexity: Whatever the underlying operator== has. Constexpr and noexcept of underlying operations is propagated.\nGuarantees: None.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/basic_result/inequality_basic_result/",
	"title": "`bool operator!=(const basic_result&lt;A, B, C&gt; &amp;) const`",
	"tags": [],
	"description": "Returns true if this result does not compare equal to the other result. Constexpr and noexcept propagating.",
	"content": "Returns true if this result does not compare equal to the other result. Comparison is done using operator!= on either value_type or error_type if the currently chosen state is the same for both results, otherwise true is returned.\nRequires: operator!= must be a valid expression between value_type and A, and between error_type and B. If value_type is void, then so must be A; similarly for error_type and B.\nComplexity: Whatever the underlying operator!= have. Constexpr and noexcept of underlying operations is propagated.\nGuarantees: None.\nFree function alias: There is a free function bool operator!=(const basic_result\u0026lt;A, B, C\u0026gt; \u0026amp;, const basic_outcome\u0026lt;A, B, C, D\u0026gt; \u0026amp;) which forwards perfectly to this function, by reversing the operands.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/basic_outcome/inequality_basic_result/",
	"title": "`bool operator!=(const basic_result&lt;A, B, C&gt; &amp;) const`",
	"tags": [],
	"description": "Returns true if this outcome does not compare equal to the other result. Constexpr and noexcept propagating.",
	"content": "Returns true if this outcome does not compare equal to the other result. Comparison is done using operator!= on value_type or error_type if the currently chosen state is the same for both outcome and result, otherwise true is returned. Note that an excepted outcome is always unequal to a result.\nRequires: operator!= must be a valid expression between value_type and A, and between error_type and B. If value_type is void, then so must be A; similarly for error_type and B.\nComplexity: Whatever the underlying operator!= have. Constexpr and noexcept of underlying operations is propagated.\nGuarantees: None.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/basic_outcome/inequality_basic_outcome/",
	"title": "`bool operator!=(const basic_outcome&lt;A, B, C, D&gt; &amp;) const`",
	"tags": [],
	"description": "Returns true if this outcome does not compare equal to the other outcome. Constexpr and noexcept propagating.",
	"content": "Returns true if this outcome does not compare equal to the other outcome. Comparison is done using operator!= on value_type, error_type and/or exception_type if the currently chosen state is the same for both outcomes, otherwise true is returned.\nRequires: operator!= must be a valid expression between value_type and A, and between error_type and B, and between exception_type and C. If value_type is void, then so must be A; similarly for error_type and B; similarly for exception_type and C.\nComplexity: Whatever the underlying operator!= have. Constexpr and noexcept of underlying operations is propagated.\nGuarantees: None.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/basic_outcome/equality_success_type/",
	"title": "`bool operator!=(const success_type&lt;A&gt; &amp;) const`",
	"tags": [],
	"description": "Returns true if this outcome does not compare equal to the success type sugar. Constexpr and noexcept propagating.",
	"content": "Returns true if this outcome is not successful or its value does not compares equal to the value in the success type sugar. Comparison is done using operator!= on value_type and A. If A is void, this call aliases bool has_error() const noexcept .\nRequires: operator!= must be a valid expression between value_type and A, or A is void. If value_type is void, then so must be A.\nComplexity: Whatever the underlying operator!= has. Constexpr and noexcept of underlying operations is propagated.\nGuarantees: None.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/basic_result/equality_success_type/",
	"title": "`bool operator!=(const success_type&lt;A&gt; &amp;) const`",
	"tags": [],
	"description": "Returns true if this result does not compare equal to the success type sugar. Constexpr and noexcept propagating.",
	"content": "Returns true if this result is not successful or its value does not compares equal to the value in the success type sugar. Comparison is done using operator!= on value_type and A. If A is void, this call aliases bool has_error() const noexcept .\nRequires: operator!= must be a valid expression between value_type and A, or A is void. If value_type is void, then so must be A.\nComplexity: Whatever the underlying operator!= has. Constexpr and noexcept of underlying operations is propagated.\nGuarantees: None.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/basic_outcome/inequality_failure_type/",
	"title": "`bool operator!=(const failure_type&lt;A, B&gt; &amp;) const`",
	"tags": [],
	"description": "Returns true if this outcome does not compare equal to the failure type sugar. Constexpr and noexcept propagating.",
	"content": "Returns true if this outcome is successful or its error or exception does not compare equal to the error in the failure type sugar. Comparison is done using operator!= on error_type and A and on exception_type and B.\nRequires: operator!= must be a valid expression between error_type and A, or A is void; operator!= must be a valid expression between exception_type and B, or B is void. If error_type is void, then so must be A; if exception_type is void, then so must be B.\nComplexity: Whatever the underlying operator!= has. Constexpr and noexcept of underlying operations is propagated.\nGuarantees: None.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/basic_result/inequality_failure_type/",
	"title": "`bool operator!=(const failure_type&lt;A, void&gt; &amp;) const`",
	"tags": [],
	"description": "Returns true if this result does not compare equal to the failure type sugar. Constexpr and noexcept propagating.",
	"content": "Returns true if this result is successful or its error does not compare equal to the error in the failure type sugar. Comparison is done using operator!= on error_type and A. If A is void, this call aliases bool has_value() const noexcept .\nRequires: operator!= must be a valid expression between error_type and A, or A is void. If error_type is void, then so must be A.\nComplexity: Whatever the underlying operator!= has. Constexpr and noexcept of underlying operations is propagated.\nGuarantees: None.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/basic_outcome/swap/",
	"title": "`void swap(basic_outcome &amp;)`",
	"tags": [],
	"description": "Swap one basic_outcome with another, with the strong guarantee. Noexcept propagating.",
	"content": "Swap one basic_outcome with another, with the strong guarantee. Constexpr if move constructors and move assignments of value_type, error_type and exception_type are noexcept.\nRequires: Always available.\nComplexity: If the move constructor and move assignment for value_type, error_type and exception_type are noexcept, the complexity is the same as for the swap() implementations of the value_type, error_type and exception_type. Otherwise, complexity is not preserved, as strong_swap(bool \u0026amp;all_good, T \u0026amp;a, T \u0026amp;b) is used instead of swap(). This function defaults to using one move construction and two assignments, and it will attempt extra move assignments in order to restore the state upon entry if a failure occurs.\nGuarantees: If an exception is thrown during the swap operation, the state of all three operands on entry is attempted to be restored, in order to implement the strong guarantee. If that too fails, the flag bits are forced to something consistent such that there can be no simultaneously valued and errored/excepted state, or valueless and errorless/exceptionless. The flag has_lost_consistency() becomes true for both operands, which are now likely in an inconsistent state.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/basic_result/swap/",
	"title": "`void swap(basic_result &amp;)`",
	"tags": [],
	"description": "Swap one basic_result with another, with the strong guarantee. Noexcept propagating.",
	"content": "Swap one basic_result with another, with the strong guarantee. Constexpr if move constructors and move assignments of value_type and error_type are noexcept.\nRequires: Always available.\nComplexity: If the move constructor and move assignment for value_type and error_type are noexcept, the complexity is the same as for the swap() implementations of the value_type and error_type. Otherwise, complexity is not preserved, as strong_swap(bool \u0026amp;all_good, T \u0026amp;a, T \u0026amp;b) is used instead of swap(). This function defaults to using one move construction and two assignments, and it will attempt extra move assignments in order to restore the state upon entry if a failure occurs.\nGuarantees: If an exception is thrown during the swap operation, the state of both operands on entry is attempted to be restored, in order to implement the strong guarantee. If that too fails, the flag bits are forced to something consistent such that there can be no simultaneously valued and errored state, or valueless and errorless. The flag has_lost_consistency() becomes true for both operands, which are now likely in an inconsistent state.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/basic_result/as_failure_lvalue/",
	"title": "`auto as_failure() const &amp;`",
	"tags": [],
	"description": "Return the output from free function `failure()` containing a copy of any errored state.",
	"content": "Return the output from free function auto failure(T \u0026amp;\u0026amp;, ...) containing a copy of any errored state. The error state is accessed using const error_type \u0026amp;assume_error() const \u0026amp; noexcept .\nRequires: Always available.\nComplexity: Whatever that of error_type\u0026rsquo;s copy constructor is.\nGuarantees: None.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/basic_outcome/as_failure_lvalue/",
	"title": "`failure_type&lt;error_type, exception_type&gt; as_failure() const &amp;`",
	"tags": [],
	"description": "Return the output from free function `failure()` containing a copy of any errored and/or excepted state.",
	"content": "Return the output from free function auto failure(T \u0026amp;\u0026amp;, ...) containing a copy of any errored and/or excepted state. The error and/or exception state is accessed using const error_type \u0026amp;assume_error() const \u0026amp; noexcept and const exception_type \u0026amp;assume_exception() const \u0026amp; noexcept .\nRequires: Always available.\nComplexity: Whatever that of error_type\u0026rsquo;s and/or exception_type\u0026rsquo;s copy constructor is.\nGuarantees: None.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/basic_result/as_failure_rvalue/",
	"title": "`auto as_failure() &amp;&amp;`",
	"tags": [],
	"description": "Return the output from free function `failure()` containing a move of any errored state.",
	"content": "Return the output from free function auto failure(T \u0026amp;\u0026amp;, ...) containing a move from any errored state, thus leaving the result\u0026rsquo;s error value in a moved-from state. Depending on the choice of error_type, this function may therefore be destructive. The error state is accessed using error_type \u0026amp;\u0026amp;assume_error() \u0026amp;\u0026amp; noexcept .\nRequires: Always available.\nComplexity: Whatever that of error_type\u0026rsquo;s move constructor is.\nGuarantees: None.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/basic_outcome/as_failure_rvalue/",
	"title": "`failure_type&lt;error_type, exception_type&gt; as_failure() &amp;&amp;`",
	"tags": [],
	"description": "Return the output from free function `failure()` containing a move of any errored and/or excepted state.",
	"content": "Return the output from free function auto failure(T \u0026amp;\u0026amp;, ...) containing a move from any errored and/or excepted state, thus leaving the outcome\u0026rsquo;s error and exception values in a moved-from state. Depending on the choice of error_type and/or exception_type, this function may therefore be destructive. The error and exception states are accessed using error_type \u0026amp;\u0026amp;assume_error() \u0026amp;\u0026amp; noexcept and exception_type \u0026amp;\u0026amp;assume_exception() \u0026amp;\u0026amp; noexcept .\nRequires: Always available.\nComplexity: Whatever that of error_type\u0026rsquo;s and/or exception_type\u0026rsquo;s move constructor is.\nGuarantees: None.\n"
},
{
	"uri": "https://ned14.github.io/outcome/_footer/",
	"title": "",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ned14.github.io/outcome/_header/",
	"title": "",
	"tags": [],
	"description": "",
	"content": "Outcome 2.2 library documentation\n"
},
{
	"uri": "https://ned14.github.io/outcome/recipes/asio-integration/",
	"title": "ASIO/Networking TS : Boost &lt; 1.70",
	"tags": ["asio", "networking-ts"],
	"description": "How to teach ASIO/Networking TS about Outcome.",
	"content": " Thanks to Christos Stratopoulos for this Outcome recipe.\nCompatibility note This recipe targets Boost versions before 1.70, where coroutine support is based around the asio::experimental::this_coro::token completion token. For integration with Boost versions 1.70 and onward, see this recipe.\nUse case Boost.ASIO and standalone ASIO provide the async_result customisation point for adapting arbitrary third party libraries, such as Outcome, into ASIO.\nHistorically in ASIO you need to pass completion handler instances to the ASIO asynchronous i/o initiation functions. These get executed when the i/o completes.\n// Dynamically allocate a buffer to read into. This must be move-only  // so it can be attached to the completion handler, hence the unique_ptr.  auto buffer = std::make_unique\u0026lt;std::vector\u0026lt;byte\u0026gt;\u0026gt;(1024); // Begin an asynchronous socket read, upon completion invoke  // the lambda function specified  skt.async_read_some(asio::buffer(buffer-\u0026gt;data(), buffer-\u0026gt;size()), // Retain lifetime of the i/o buffer until completion  [buffer = std::move(buffer)](const error_code \u0026amp;ec, size_t bytes) { // Handle the buffer read  if(ec) { std::cerr \u0026lt;\u0026lt; \u0026#34;Buffer read failed with \u0026#34; \u0026lt;\u0026lt; ec \u0026lt;\u0026lt; std::endl; return; } std::cout \u0026lt;\u0026lt; \u0026#34;Read \u0026#34; \u0026lt;\u0026lt; bytes \u0026lt;\u0026lt; \u0026#34; bytes into buffer\u0026#34; \u0026lt;\u0026lt; std::endl; // buffer will be dynamically freed now  }); View this code on Github One of the big value adds of the Coroutines TS is the ability to not have to write so much boilerplate if you have a Coroutines supporting compiler:\n// As coroutines suspend the calling thread whilst an asynchronous  // operation executes, we can use stack allocation instead of dynamic  // allocation  char buffer[1024]; // Get an ASIO completion token for the current coroutine (requires  // Coroutines TS)  asio::experimental::await_token token = //  co_await asio::experimental::this_coro::token(); // Asynchronously read data, suspending this coroutine until completion,  // returning the bytes of the data read into the result.  try { size_t bytesread = //  co_await skt.async_read_some(asio::buffer(buffer), token); std::cout \u0026lt;\u0026lt; \u0026#34;Read \u0026#34; \u0026lt;\u0026lt; bytesread \u0026lt;\u0026lt; \u0026#34; bytes into buffer\u0026#34; \u0026lt;\u0026lt; std::endl; } catch(const std::system_error \u0026amp;e) { std::cerr \u0026lt;\u0026lt; \u0026#34;Buffer read failed with \u0026#34; \u0026lt;\u0026lt; e.what() \u0026lt;\u0026lt; std::endl; } View this code on Github The default ASIO implementation always throws exceptions on failure through its coroutine token transformation. The redirect_error token transformation recovers the option to use the error_code interface, but it suffers from the same drawbacks that make pure error codes unappealing in the synchronous case.\nThis recipe fixes that by making it possible for coroutinised i/o in ASIO to return a result\u0026lt;T\u0026gt;:\n// Asynchronously read data, suspending this coroutine until completion,  // returning the bytes of the data read into the result, or any failure.  outcome::result\u0026lt;size_t, error_code\u0026gt; bytesread = //  co_await skt.async_read_some(asio::buffer(buffer), as_result(token)); // Usage is exactly like ordinary Outcome. Note the lack of exception throw!  if(bytesread.has_error()) { std::cerr \u0026lt;\u0026lt; \u0026#34;Buffer read failed with \u0026#34; \u0026lt;\u0026lt; bytesread.error() \u0026lt;\u0026lt; std::endl; return; } std::cout \u0026lt;\u0026lt; \u0026#34;Read \u0026#34; \u0026lt;\u0026lt; bytesread.value() \u0026lt;\u0026lt; \u0026#34; bytes into buffer\u0026#34; \u0026lt;\u0026lt; std::endl; View this code on Github Implementation The below involves a lot of ASIO voodoo. NO SUPPORT WILL BE GIVEN HERE FOR THE ASIO CODE BELOW. Please raise any questions or problems that you have with how to implement this sort of stuff in ASIO on Stackoverflow #boost-asio.\n The real world, production-level recipe can be found at the bottom of this page. You ought to use that in any real world use case.\nIt is however worth providing a walkthrough of a simplified edition of the real world recipe, as a lot of barely documented ASIO voodoo is involved. You should not use the code presented next in your own code, it is too simplified. But it should help you understand how the real implementation works.\nFirstly we need to define some helper type sugar and a factory function for wrapping any arbitrary third party completion token with that type sugar:\nnamespace detail { // Type sugar for wrapping an external completion token  template \u0026lt;classCompletionToken\u0026gt; struct as_result_t { CompletionToken token; }; } // namespace detail  // Factory function for wrapping a third party completion token with // our type sugar template \u0026lt;classCompletionToken\u0026gt; // inline auto as_result(CompletionToken \u0026amp;\u0026amp;token) { return detail::as_result_t\u0026lt;std::decay_t\u0026lt;CompletionToken\u0026gt;\u0026gt;{std::forward\u0026lt;CompletionToken\u0026gt;(token)}; }; View this code on Github Next we tell ASIO about a new completion token it ought to recognise by specialising async_result:\n// Tell ASIO about a new kind of completion token, the kind returned // from our as_result() factory function. This implementation is // for functions with handlers void(error_code, T) only. template \u0026lt;classCompletionToken, classT\u0026gt; // struct asio::async_result\u0026lt;detail::as_result_t\u0026lt;CompletionToken\u0026gt;, //  void(error_code, T)\u0026gt; //  // NOTE we subclass for an async result taking an outcome::result  // as its completion handler. We will mangle the void(error_code, T)  // completion handler into this completion handler below.  : public asio::async_result\u0026lt;CompletionToken, void(outcome::result\u0026lt;T, error_code\u0026gt;)\u0026gt; { // The result type we shall return  using result_type = outcome::result\u0026lt;T, error_code\u0026gt;; using _base = asio::async_result\u0026lt;CompletionToken, void(result_type)\u0026gt;; // The awaitable type to be returned by the initiating function,  // the co_await of which will yield a result_type  using return_type = typename _base::return_type; // Get what would be the completion handler for the async_result  // whose completion handler is void(result_type)  using result_type_completion_handler_type = //  typename _base::completion_handler_type; View this code on Github The tricky part to understand is that our async_result specialisation inherits from an async_result for the supplied completion token type with a completion handler which consumes a result\u0026lt;T\u0026gt;. Our async_result is actually therefore the base async_result, but we layer on top a completion_handler_type with the void(error_code, size_t) signature which constructs from that a result:\n// Wrap that completion handler with void(error_code, T) converting  // handler  struct completion_handler_type { // Pass through unwrapped completion token  template \u0026lt;classU\u0026gt; completion_handler_type(::detail::as_result_t\u0026lt;U\u0026gt; \u0026amp;\u0026amp;ch) : _handler(std::forward\u0026lt;U\u0026gt;(ch.token)) { } // Our completion handler spec  void operator()(error_code ec, T v) { // Call the underlying completion handler, whose  // completion function is void(result_type)  if(ec) { // Complete with a failed result  _handler(result_type(outcome::failure(ec))); return; } // Complete with a successful result  _handler(result_type(outcome::success(v))); } result_type_completion_handler_type _handler; }; // Initialise base with the underlying completion handler  async_result(completion_handler_type \u0026amp;h) : _base(h._handler) { } using _base::get; }; View this code on Github To use, simply wrap the third party completion token with as_result to cause ASIO to return from co_await a result instead of throwing exceptions on failure:\nchar buffer[1024]; asio::experimental::await_token token = co_await asio::experimental::this_coro::token(); outcome::result\u0026lt;size_t, error_code\u0026gt; bytesread = co_await skt.async_read_some(asio::buffer(buffer), as_result(token));  The real world production-level implementation below is a lot more complex than the above which has been deliberately simplified to aid exposition. The above should help you get up and running with the below, eventually.\nOne again I would like to remind you that Outcome is not the appropriate place to seek help with ASIO voodoo. Please ask on Stackoverflow #boost-asio.\nHere follows the real world, production-level adapation of Outcome into ASIO, written and maintained by Christos Stratopoulos. If the following does not load due to Javascript being disabled, you can visit the gist at https://gist.github.com/cstratopoulos/901b5cdd41d07c6ce6d83798b09ecf9b/da584844f58353915dc2600fba959813f793b456.\n "
},
{
	"uri": "https://ned14.github.io/outcome/recipes/asio-integration-1-70/",
	"title": "ASIO/Networking TS: Boost &gt;= 1.70",
	"tags": ["asio", "networking-ts"],
	"description": "How to teach ASIO/Networking TS about Outcome.",
	"content": " Thanks to Christos Stratopoulos for this Outcome recipe.\nCompatibility note This recipe targets Boost versions including and after 1.70, where coroutine support is based around the asio::use_awaitable completion token. For integration with Boost versions before 1.70, see this recipe.\nUse case Boost.ASIO and standalone ASIO provide the async_result customisation point for adapting arbitrary third party libraries, such as Outcome, into ASIO.\nHistorically in ASIO you need to pass completion handler instances to the ASIO asynchronous i/o initiation functions. These get executed when the i/o completes.\n// Dynamically allocate a buffer to read into. This must be move-only  // so it can be attached to the completion handler, hence the unique_ptr.  auto buffer = std::make_unique\u0026lt;std::vector\u0026lt;byte\u0026gt;\u0026gt;(1024); // Begin an asynchronous socket read, upon completion invoke  // the lambda function specified  skt.async_read_some(asio::buffer(buffer-\u0026gt;data(), buffer-\u0026gt;size()), // Retain lifetime of the i/o buffer until completion  [buffer = std::move(buffer)](const error_code \u0026amp;ec, size_t bytes) { // Handle the buffer read  if(ec) { std::cerr \u0026lt;\u0026lt; \u0026#34;Buffer read failed with \u0026#34; \u0026lt;\u0026lt; ec \u0026lt;\u0026lt; std::endl; return; } std::cout \u0026lt;\u0026lt; \u0026#34;Read \u0026#34; \u0026lt;\u0026lt; bytes \u0026lt;\u0026lt; \u0026#34; bytes into buffer\u0026#34; \u0026lt;\u0026lt; std::endl; // buffer will be dynamically freed now  }); View this code on Github One of the big value adds of the Coroutines TS is the ability to not have to write so much boilerplate if you have a Coroutines supporting compiler:\n// As coroutines suspend the calling thread whilst an asynchronous  // operation executes, we can use stack allocation instead of dynamic  // allocation  char buffer[1024]; // Asynchronously read data, suspending this coroutine until completion,  // returning the bytes of the data read into the result.  try { // The use_awaitable completion token represents the current coroutine  // (requires Coroutines TS)  size_t bytesread = //  co_await skt.async_read_some(asio::buffer(buffer), asio::use_awaitable); std::cout \u0026lt;\u0026lt; \u0026#34;Read \u0026#34; \u0026lt;\u0026lt; bytesread \u0026lt;\u0026lt; \u0026#34; bytes into buffer\u0026#34; \u0026lt;\u0026lt; std::endl; } catch(const std::system_error \u0026amp;e) { std::cerr \u0026lt;\u0026lt; \u0026#34;Buffer read failed with \u0026#34; \u0026lt;\u0026lt; e.what() \u0026lt;\u0026lt; std::endl; } View this code on Github The default ASIO implementation always throws exceptions on failure through its coroutine token transformation. The redirect_error token transformation recovers the option to use the error_code interface, but it suffers from the same drawbacks that make pure error codes unappealing in the synchronous case.\nThis recipe fixes that by making it possible for coroutinised i/o in ASIO to return a result\u0026lt;T\u0026gt;:\n// Asynchronously read data, suspending this coroutine until completion,  // returning the bytes of the data read into the result, or any failure.  outcome::result\u0026lt;size_t, error_code\u0026gt; bytesread = //  co_await skt.async_read_some(asio::buffer(buffer), as_result(asio::use_awaitable)); // Usage is exactly like ordinary Outcome. Note the lack of exception throw!  if(bytesread.has_error()) { std::cerr \u0026lt;\u0026lt; \u0026#34;Buffer read failed with \u0026#34; \u0026lt;\u0026lt; bytesread.error() \u0026lt;\u0026lt; std::endl; return; } std::cout \u0026lt;\u0026lt; \u0026#34;Read \u0026#34; \u0026lt;\u0026lt; bytesread.value() \u0026lt;\u0026lt; \u0026#34; bytes into buffer\u0026#34; \u0026lt;\u0026lt; std::endl; View this code on Github Implementation The below involves a lot of ASIO voodoo. NO SUPPORT WILL BE GIVEN HERE FOR THE ASIO CODE BELOW. Please raise any questions or problems that you have with how to implement this sort of stuff in ASIO on Stackoverflow #boost-asio.\n The real world, production-level recipe can be found at the bottom of this page. You ought to use that in any real world use case.\nIt is however worth providing a walkthrough of a simplified edition of the real world recipe, as a lot of barely documented ASIO voodoo is involved. You should not use the code presented next in your own code, it is too simplified. But it should help you understand how the real implementation works.\nFirstly we need to define some helper type sugar and a factory function for wrapping any arbitrary third party completion token with that type sugar:\nnamespace detail { // Type sugar for wrapping an external completion token  template \u0026lt;classCompletionToken\u0026gt; struct as_result_t { CompletionToken token; }; } // namespace detail  // Factory function for wrapping a third party completion token with // our type sugar template \u0026lt;classCompletionToken\u0026gt; // inline auto as_result(CompletionToken \u0026amp;\u0026amp;token) { return detail::as_result_t\u0026lt;std::decay_t\u0026lt;CompletionToken\u0026gt;\u0026gt;{std::forward\u0026lt;CompletionToken\u0026gt;(token)}; }; View this code on Github Next we tell ASIO about a new completion token it ought to recognise by specialising async_result:\n// Tell ASIO about a new kind of completion token, the kind returned // from our as_result() factory function. This implementation is // for functions with handlers void(error_code, T) only. template \u0026lt;classCompletionToken, classT\u0026gt; // struct asio::async_result\u0026lt;detail::as_result_t\u0026lt;CompletionToken\u0026gt;, //  void(error_code, T)\u0026gt; //  { // The result type we shall return  using result_type = outcome::result\u0026lt;T, error_code\u0026gt;; // The awaitable type to be returned by the initiating function,  // the co_await of which will yield a result_type  using return_type = //  typename asio::async_result\u0026lt;CompletionToken, void(result_type)\u0026gt; //  ::return_type; View this code on Github There are a couple tricky parts to understand. First of all, we want our async_result specialization to work, in particular, with the async_result for ASIO\u0026rsquo;s use_awaitable_t completion token. With this token, the async_result specialization takes the form with a static initiate method which defers initiation of the asynchronous operation until, for example, co_await is called on the returned awaitable. Thus, our async_result specialization will take the same form. With this in mind, we need only understand how our specialization will implement its initiate method. The trick is that it will pass the initiation work off to an async_result for the supplied completion token type with a completion handler which consumes result\u0026lt;T\u0026gt;. Our async_result is thus just a simple wrapper over this underlying async_result, but we inject a completion handler with the void(error_code, size_t) signature which constructs from that a result:\n// Wrap a completion handler with void(error_code, T) converting  // handler  template \u0026lt;classHandler\u0026gt; struct completion_handler { // Our completion handler spec  void operator()(error_code ec, T v) { // Call the underlying completion handler, whose  // completion function is void(result_type)  if(ec) { // Complete with a failed result  _handler(result_type(outcome::failure(ec))); return; } // Complete with a successful result  _handler(result_type(outcome::success(v))); } Handler _handler; }; // NOTE the initiate member function initiates the async operation,  // and we want to defer to what would be the initiation of the  // async_result whose handler signature is void(result_type).  template \u0026lt;classInitiation, class... Args\u0026gt; static return_type initiate( Initiation\u0026amp;\u0026amp; init, detail::as_result_t\u0026lt;CompletionToken\u0026gt;\u0026amp;\u0026amp; token, Args\u0026amp;\u0026amp;... args) { // The async_initiate\u0026lt;CompletionToken, void(result_type)\u0026gt; helper  // function will invoke the async initiation method of the  // async_result\u0026lt;CompletionToken, void(result_type)\u0026gt;, as desired.  // Instead of CompletionToken and void(result_type)\twe start with  // detail::as_result_t\u0026lt;CompletionToken\u0026gt; and void(ec, T), so  // the inputs need to be massaged then passed along.  return asio::async_initiate\u0026lt;CompletionToken, void(result_type)\u0026gt;( // create a new initiation which wraps the provided init  [init = std::forward\u0026lt;Initiation\u0026gt;(init)]( auto\u0026amp;\u0026amp; handler, auto\u0026amp;\u0026amp;... initArgs) mutable { std::move(init)( // we wrap the handler in the converting completion_handler from  // above, and pass along the args  completion_handler\u0026lt;std::decay_t\u0026lt;decltype(handler)\u0026gt;\u0026gt;{ std::forward\u0026lt;decltype(handler)\u0026gt;(handler)}, std::forward\u0026lt;decltype(initArgs)\u0026gt;(initArgs)...); }, // the new initiation is called with the handler unwrapped from  // the token, and the original initiation arguments.  token.token, std::forward\u0026lt;Args\u0026gt;(args)...); } }; View this code on Github To use, simply wrap the third party completion token with as_result to cause ASIO to return from co_await a result instead of throwing exceptions on failure:\nchar buffer[1024]; outcome::result\u0026lt;size_t, error_code\u0026gt; bytesread = co_await skt.async_read_some(asio::buffer(buffer), as_result(asio::use_awaitable));  The real world production-level implementation below is a lot more complex than the above which has been deliberately simplified to aid exposition. The above should help you get up and running with the below, eventually.\nOne again I would like to remind you that Outcome is not the appropriate place to seek help with ASIO voodoo. Please ask on Stackoverflow #boost-asio.\nHere follows the real world, production-level adapation of Outcome into ASIO, written and maintained by Christos Stratopoulos. If the following does not load due to Javascript being disabled, you can visit the gist at https://gist.github.com/cstratopoulos/901b5cdd41d07c6ce6d83798b09ecf9b/863c1dbf3b063a5ff9ff2bdd834242ead556e74e.\n "
},
{
	"uri": "https://ned14.github.io/outcome/credits/",
	"title": "Acknowledgements",
	"tags": [],
	"description": "Giving thanks to those who made Outcome happen",
	"content": " github contributors .ghContributors{ display:flex; flex-flow: wrap; align-content: flex-start } .ghContributors  div{ width: 50% ; display: inline-flex; margin-bottom: 5px; } .ghContributors  div label{ padding-left: 4px ; } .ghContributors  div span{ font-size: x-small; padding-left: 4px ; }   @ned14 1526 commits   @akrzemi1 45 commits   @cstratopoulos 9 commits   @hazelnusse 7 commits   @BurningEnlightenment 7 commits   @libbooze 2 commits   @johnthagen 2 commits   @menuet 2 commits   @amerry 1 commits   @ecatmur 1 commits   @gix 1 commits   @norbertwenzel 1 commits   @vinipsmaker 1 commits   @alandefreitas 1 commits   @andoks 1 commits   @catskul 1 commits   @hyeongyukim 1 commits   @jenkins-nedprod 1 commits   @sdarwin 1 commits   This pretty, modern C++ documentation  Hugo - static website generator of this documentation. hugo-theme-docdock - the Hugo theme used by this documentation. Standardese - the API reference generator (up until Outcome v2.0)  Special thanks for Outcome v2.1 Once again Andrzej Krzemienski stands out for a never ceasing flow of excellent questions, \u0026ldquo;what if?\u0026rdquo;\u0026rsquo;s, eagle eyed spotting of corner case logic bugs, and design contradictions. Thank you Andrzej!\nMy thanks to the Microsoft Visual C++ compiler team for incorporating Outcome into the MSVC test suite, and thus finding many interesting corner case quirks in how best to interpret the C++ standard. In some cases, Outcome was refactored to be less ambiguous; in others, defects had to be submitted to WG21 because the standard wording was not clear. The Visual C++ compiler team were particularly generous with their time in helping track down the cause of these issues, complete with submitting pull requests with bug fixes. I am very grateful to them.\nSpecial thanks for Outcome v2.0 For a second time, Charley Bay stepped up as review manager. Given how much work it was for the v1 review, I can only say thank you.\nAndrzej Krzemienski went far beyond the call of duty in the development of Outcome v2. He wrote the front page, and the start of the tutorial. He thus set the tone, pacing, style and form of the tutorial which I merely continued for the rest of the tutorial. He also volunteered considerable amounts of his time as as primary peer reviewer for the v2 design and implementation, asking many very valuable \u0026ldquo;stupid questions\u0026rdquo; at least one of which caused a major rethink and refactor. If Outcome v2 passes its second peer review, it\u0026rsquo;s because of Andrzej. Thank you.\nJonathan M√ºller invested countless hours in his doxygen replacement tool Standardese which Outcome uses to generate the reference API docs, and a not insignificant number of those went on fixing issues for Outcome. Thank you.\nSpecial thanks for Outcome v1 To Paul Bristow who proposed the name \u0026ldquo;Outcome\u0026rdquo; for the library after a very extended period of name bikeshedding on boost-dev. I had been minded to call the library \u0026ldquo;Boost.Donkey\u0026rdquo; just to shut everyone up because the name bike shedding was getting ridiculous. But Outcome is a lot nicer, so thank you Paul.\nMy heartfelt thanks to Charley Bay for acting as review manager for Outcome in May 2017. It is becoming ever harder to find a Boost review manager, so thank you! My thanks also to the CppCast team Rob Irving and Jason Turner for so quickly getting me on to CppCast to discuss expected\u0026lt;T, E\u0026gt; during the Outcome peer review to help publicise the review.\nMore general thanks are due to those on boost-dev, Reddit and SG14 for extensive and often very detailed feedback on the library pretty much from its beginning. You are all too numerous to remember, but certainly Tongari and Andrzej Krzemienski come to mind as having engaged in particularly long discussion threads with tons of useful feedback which clarified my thinking. Andrzej also went through the documentation with a fine toothed comb before the review, finding many small errata and confusing wording.\nFinally, my thanks to Vicente for driving Expected from its beginnings to hopefully standardisation before 2020. It\u0026rsquo;s many years of work getting something standardised, even more years than getting a library into Boost which as you can see from the history above took about three years.\n"
},
{
	"uri": "https://ned14.github.io/outcome/tags/adl-bridging/",
	"title": "Adl Bridging",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ned14.github.io/outcome/tags/asio/",
	"title": "Asio",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ned14.github.io/outcome/categories/assignment/",
	"title": "Assignment",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ned14.github.io/outcome/tags/awaitables/",
	"title": "Awaitables",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ned14.github.io/outcome/tags/backtrace/",
	"title": "Backtrace",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ned14.github.io/outcome/tags/best-practice/",
	"title": "Best Practice",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ned14.github.io/outcome/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ned14.github.io/outcome/tags/co_await/",
	"title": "Co_await",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ned14.github.io/outcome/categories/comparisons/",
	"title": "Comparisons",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ned14.github.io/outcome/reference/macros/template/",
	"title": "Constrained template macros",
	"tags": [],
	"description": "",
	"content": "Overridable: All of the following macros are overridable, define before inclusion.\nHeader: \u0026lt;outcome/config.hpp\u0026gt;\nThese macros expand into either the syntax for directly specifying constrained templates in C++ 20, or into a SFINAE based emulation for earlier C++ versions. Form of usage looks as follows:\nOUTCOME_TEMPLATE(classErrorCondEnum) OUTCOME_TREQUIRES( // If this is a valid expression  OUTCOME_TEXPR(error_type(make_error_code(ErrorCondEnum()))), // If this predicate is true  OUTCOME_TPRED(predicate::template enable_error_condition_converting_constructor\u0026lt;ErrorCondEnum\u0026gt;) // Any additional requirements follow here ...  ) constexpr basic_result(ErrorCondEnum \u0026amp;\u0026amp;t, error_condition_converting_constructor_tag /*unused*/ = {});  Be aware that slightly different semantics occur for real C++ 20 constrained templates than for the SFINAE emulation.\n OUTCOME_TEMPLATE(template args ...)\nBegins a constrained template declaration.\n OUTCOME_TREQUIRES(requirements ...)\nSpecifies the requirements for the constrained template to be available for selection by the compiler.\n OUTCOME_TEXPR(expression)\nA requirement that the given expression is valid.\n OUTCOME_TPRED(boolean)\nA requirement that the given constant time expression is true.\n  "
},
{
	"uri": "https://ned14.github.io/outcome/tags/constructors/",
	"title": "Constructors",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ned14.github.io/outcome/categories/constructors/",
	"title": "Constructors",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ned14.github.io/outcome/tags/conventions/",
	"title": "Conventions",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ned14.github.io/outcome/categories/converting-constructors/",
	"title": "Converting Constructors",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ned14.github.io/outcome/categories/copy-assignment/",
	"title": "Copy Assignment",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ned14.github.io/outcome/categories/copy-constructors/",
	"title": "Copy Constructors",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ned14.github.io/outcome/tags/coroutines/",
	"title": "Coroutines",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ned14.github.io/outcome/tags/default-actions/",
	"title": "Default Actions",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ned14.github.io/outcome/categories/default-constructors/",
	"title": "Default Constructors",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ned14.github.io/outcome/categories/destructors/",
	"title": "Destructors",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ned14.github.io/outcome/categories/disabling-constructors/",
	"title": "Disabling Constructors",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ned14.github.io/outcome/tags/dual-api/",
	"title": "Dual Api",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ned14.github.io/outcome/tags/eager/",
	"title": "Eager",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ned14.github.io/outcome/tags/error/",
	"title": "Error",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ned14.github.io/outcome/tags/exception/",
	"title": "Exception",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ned14.github.io/outcome/categories/explicit-constructors/",
	"title": "Explicit Constructors",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ned14.github.io/outcome/recipes/foreign-try/",
	"title": "Extending `OUTCOME_TRY`",
	"tags": ["TRY"],
	"description": "How to informing `OUTCOME_TRY` about foreign Result types.",
	"content": " Outcome\u0026rsquo;s OUTCOME_TRY(var, expr) operation is fully extensible to accept as input any foreign types. It already recognises types matching the concepts::value_or_error\u0026lt;T, E\u0026gt; concept, which is to say all types which have:\n A public .has_value() member function which returns a bool. In order of preference, a public .assume_value()/.value() member function. In order of preference, a public .as_failure()/.assume_error()/.error() member function.  This should automatically handle inputs of std::expected\u0026lt;T, E\u0026gt;, and many others, including intermixing Boost.Outcome and standalone Outcome within the same translation unit.\nOUTCOME_TRY has the following free function customisation points:\n OUTCOME_V2_NAMESPACE::try_operation_has_value(X) Returns a `bool` which is true if the input to TRY has a value. OUTCOME_V2_NAMESPACE::try_operation_return_as(X) Returns a suitable failure_type\u0026lt;EC, EP = void\u0026gt; which is returned immediately to cause stack unwind. Ought to preserve rvalue semantics (i.e. if passed an rvalue, move the error state into the failure type). OUTCOME_V2_NAMESPACE::try_operation_extract_value(X) Extracts a value type from the input for the `TRY` to set its variable. Ought to preserve rvalue semantics (i.e. if passed an rvalue, move the value).  New overloads of these to support additional input types must be injected into the OUTCOME_V2_NAMESPACE namespace before the compiler parses the relevant OUTCOME_TRY in order to be found. This is called \u0026lsquo;early binding\u0026rsquo; in the two phase name lookup model in C++. This was chosen over \u0026lsquo;late binding\u0026rsquo;, where an OUTCOME_TRY in a templated piece of code could look up overloads introduced after parsing the template containing the OUTCOME_TRY, because it has much lower impact on build times, as binding is done once at the point of parse, instead of on every occasion at the point of instantiation. If you are careful to ensure that you inject the overloads which you need early in the parse of the translation unit, all will be well.\nLet us work through an applied example.\nA very foreign pseudo-Expected type This is a paraphrase of a poorly written pseudo-Expected type which I once encountered in the production codebase of a large multinational. Lots of the code was already using it, and it was weird enough that it couldn\u0026rsquo;t be swapped out for something better easily.\nenum Errc { kBadValue }; template \u0026lt;classT, classE = Errc\u0026gt; struct ForeignExpected { T Value; E Error; int IsErrored; ForeignExpected(T v) : Value(v) , Error() , IsErrored(0) { } ForeignExpected(E e) : Value() , Error(e) , IsErrored(1) { } }; View this code on Github What we would like is for new code to be written using Outcome, but be able to transparently call old code, like this:\nForeignExpected\u0026lt;int\u0026gt; old_code(int a) // old code { if(0 == a) return kBadValue; return a; } outcome::result\u0026lt;int\u0026gt; new_code(int a) // new code { OUTCOME_TRY(auto x, old_code(a)); return x; } View this code on Github Telling Outcome about this weird foreign Expected is straightforward:\nOUTCOME_V2_NAMESPACE_BEGIN template \u0026lt;classT, classE\u0026gt; // inline bool try_operation_has_value(const ForeignExpected\u0026lt;T, E\u0026gt; \u0026amp;v) { return 0 == v.IsErrored; } template \u0026lt;classT, classE\u0026gt; // inline auto try_operation_return_as(const ForeignExpected\u0026lt;T, E\u0026gt; \u0026amp;v) { switch(v.Error) { case kBadValue: return failure(make_error_code(std::errc::argument_out_of_domain)); } abort(); } template \u0026lt;classT, classE\u0026gt; // inline auto try_operation_extract_value(const ForeignExpected\u0026lt;T, E\u0026gt; \u0026amp;v) { return v.Value; } OUTCOME_V2_NAMESPACE_END View this code on Github And now OUTCOME_TRY works exactly as expected:\nauto printresult = [](const char *desc, auto x) { if(x) { std::cout \u0026lt;\u0026lt; desc \u0026lt;\u0026lt; \u0026#34; returns successful \u0026#34; \u0026lt;\u0026lt; x.value() \u0026lt;\u0026lt; std::endl; } else { std::cout \u0026lt;\u0026lt; desc \u0026lt;\u0026lt; \u0026#34; returns failure \u0026#34; \u0026lt;\u0026lt; x.error().message() \u0026lt;\u0026lt; std::endl; } }; printresult(\u0026#34;\\nnew_code(5)\u0026#34;, new_code(5)); printresult(\u0026#34;\\nnew_code(0)\u0026#34;, new_code(0)); View this code on Github \u0026hellip; which outputs:\nnew_code(5) returns successful 5 new_code(0) returns failure argument out of domain  "
},
{
	"uri": "https://ned14.github.io/outcome/tags/has_error_code/",
	"title": "Has_error_code",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ned14.github.io/outcome/",
	"title": "Home",
	"tags": [],
	"description": "",
	"content": " Outcome 2.2 library At the end of December 2021, Standalone Outcome went guaranteed future ABI stable. From v2.2.3 onwards, you get ABI compatibilty guarantees across Outcome releases.\n Outcome is a set of tools for reporting and handling function failures in contexts where directly using C++ exception handling is unsuitable. Such contexts include:\n there are programs, or parts thereof, that are compiled with exceptions disabled;\n there are parts of program that have a lot of branches depending on types of failures, where if-statements are cleaner than try-catch blocks;\n there is a hard requirement that the failure path of execution should not cost more than the successful path of execution;\n there are situations, like in the filesystem library, where whether the failure should be handled remotely (using a C++ exception throw), or locally cannot be made inside the function and needs to be decided by the caller, and in the latter case throwing a C++ exception is not desirable for the aforementioned reasons;\n there are parts of the program/framework that themselves implement exception handling and prefer to not use exceptions to propagate failure reports across threads, tasks, fibers, etc;\n one needs to propagate exceptions through layers that do not implement exception throw safety;\n there is an external requirement (such as a company-wide policy) that failure handling paths are explicitly indicated in the code.\n where interoperation with C code, without having to resort to C++ exception wrapper shims, is important.\n where your mostly C code base needs exception-like error handling, and the subset of Outcome\u0026rsquo;s functionality available in C is sufficient for your needs.\n  Outcome addresses failure handling through returning a special type from functions, which is able to store either a successfully computed value (or void), or the information about failure. Outcome also comes with a set of idioms for dealing with such types.\nParticular care has been taken to ensure that Outcome has the lowest possible impact on build times, thus making it suitable for use in the global headers of really large codebases. Storage layout is guaranteed and is C-compatible for result\u0026lt;T, E\u0026gt;1, thus making Outcome based code long term ABI-stable.\nFully deterministic all-noexcept C++ Coroutine support in Outcome is particularly strong, and we supply Outcome-optimising eager\u0026lt;T, Executor = void\u0026gt;/atomic_eager\u0026lt;T, Executor = void\u0026gt; , lazy\u0026lt;T, Executor = void\u0026gt;/atomic_lazy\u0026lt;T, Executor = void\u0026gt; and generator\u0026lt;T, Executor = void\u0026gt; awaitables which work for any user type.\nSample usage (C++) The main workhorse in the Outcome library is result\u0026lt;T\u0026gt;: it represents either a successfully computed value of type T, or a std::error_code/boost::system::error_code2 representing the reason for failure. You use it in the function\u0026rsquo;s return type:\noutcome::result\u0026lt;string\u0026gt; data_from_file(string_view path) noexcept; View this code on Github It is possible to inspect the state manually:\nif (outcome::result\u0026lt;string\u0026gt; rslt = data_from_file(\u0026#34;config.cfg\u0026#34;)) use_string(rslt.value()); // returns string else throw LibError{rslt.error(), \u0026#34;config.cfg\u0026#34;}; // returns error_code View this code on Github Or, if this function is called in another function that also returns result\u0026lt;T\u0026gt;, you can use a dedicated control statement:\noutcome::result\u0026lt;int\u0026gt; process(const string\u0026amp; content) noexcept; outcome::result\u0026lt;int\u0026gt; int_from_file(string_view path) noexcept { OUTCOME_TRY(auto str, data_from_file(path)); // if control gets here data_from_file() has succeeded  return process(str); // decltype(str) == string } View this code on Github OUTCOME_TRY is a control statement. If the returned result\u0026lt;T\u0026gt; object contains an error information, the enclosing function is immediately returned with result\u0026lt;U\u0026gt; containing the same failure information; otherwise an automatic object of type T is available in scope.\nSample usage (C) Equivalent to the C++ API: CXX_DECLARE_RESULT_SYSTEM(ident, T) declares the C type, thereafter CXX_RESULT_SYSTEM(ident) refers to it. You use it in the function\u0026rsquo;s return type:\nCXX_DECLARE_RESULT_SYSTEM(result_string, const char *) CXX_RESULT_SYSTEM(result_string) data_from_file(const char *path); View this code on Github It is possible to inspect the state manually:\nCXX_RESULT_SYSTEM(result_string) rslt = data_from_file(\u0026#34;config.cfg\u0026#34;); if(CXX_RESULT_HAS_VALUE(rslt)) use_string(rslt.value); // returns string  else fprintf(stderr, \u0026#34;%s\\n\u0026#34;, outcome_status_code_message(\u0026amp;rslt.error)); View this code on Github Or, if this function is called in another function that also returns CXX_RESULT_SYSTEM(ident), you can use a dedicated control statement:\nCXX_DECLARE_RESULT_SYSTEM(result_int, int) CXX_RESULT_SYSTEM(result_int) process(const char *content); CXX_RESULT_SYSTEM(result_int) int_from_file(const char *path) { CXX_RESULT_SYSTEM_TRY(const char *str, result_int, /* cleanup on fail */, data_from_file(path)); // if control gets here data_from_file() has succeeded  return process(str); // decltype(str) == string } View this code on Github The C Result is guaranteed to be layout identical to its C++ equivalent. Convenience conversion functions are available, but you can reinterpret cast too.\nThis library joined the Boost C++ libraries in the 1.70 release (Spring 2019). It can be grafted into much older Boost releases if desired.\n  If you choose a C-compatible T and E type. [return] result\u0026lt;T\u0026gt; defaults to std::error_code for Standalone Outcome, and to boost::system::error_code for Boost.Outcome. You can mandate a choice using std_result\u0026lt;T\u0026gt; or boost_result\u0026lt;T\u0026gt;. [return]   "
},
{
	"uri": "https://ned14.github.io/outcome/tags/hooks/",
	"title": "Hooks",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ned14.github.io/outcome/tags/idioms/",
	"title": "Idioms",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ned14.github.io/outcome/categories/implicit-constructors/",
	"title": "Implicit Constructors",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ned14.github.io/outcome/categories/inplace-constructors/",
	"title": "Inplace Constructors",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ned14.github.io/outcome/tags/lazy/",
	"title": "Lazy",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ned14.github.io/outcome/tags/make_error_code/",
	"title": "Make_error_code",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ned14.github.io/outcome/categories/modifiers/",
	"title": "Modifiers",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ned14.github.io/outcome/categories/move-assignment/",
	"title": "Move Assignment",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ned14.github.io/outcome/categories/move-constructors/",
	"title": "Move Constructors",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ned14.github.io/outcome/tags/namespace/",
	"title": "Namespace",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ned14.github.io/outcome/tags/networking-ts/",
	"title": "Networking Ts",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ned14.github.io/outcome/tags/nodiscard/",
	"title": "Nodiscard",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ned14.github.io/outcome/categories/observer-policies/",
	"title": "Observer Policies",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ned14.github.io/outcome/categories/observers/",
	"title": "Observers",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ned14.github.io/outcome/categories/operators/",
	"title": "Operators",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ned14.github.io/outcome/tags/outcome/",
	"title": "Outcome",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ned14.github.io/outcome/tags/payload/",
	"title": "Payload",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ned14.github.io/outcome/tags/playpen/",
	"title": "Playpen",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ned14.github.io/outcome/tags/policies/",
	"title": "Policies",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ned14.github.io/outcome/tags/result/",
	"title": "Result",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ned14.github.io/outcome/tags/rust/",
	"title": "Rust",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ned14.github.io/outcome/recipes/rust/",
	"title": "Rust FFI",
	"tags": ["Rust"],
	"description": "How to teach Rust about `result&lt;T&gt;`.",
	"content": "A nice side effect of Outcome.Experimental\u0026rsquo;s excellent C support is that teaching Rust about Outcome\u0026rsquo;s result\u0026lt;T\u0026gt; becomes trivially easy. C and C++ results propagate losslessly into Rust Results, and the full power of the Outcome C API is available to Rust code for semantic equivalence comparison et al.\nHere\u0026rsquo;s a quick snippet to get you started. This assumes that you have declared your C result using CXX_DECLARE_RESULT_SYSTEM(outcome, intptr_t) in order to produce a C result named \u0026ldquo;outcome\u0026rdquo; compatible with an erased system code C++ result:\n// Rust representation of an Outcome.Experimental Result pubtype OutcomeCResult\u0026lt;T\u0026gt;=Result\u0026lt;T,cxx_status_code_system\u0026gt;;unsafeimplSendforcxx_status_code_system{}implstd::fmt::Displayforcxx_status_code_system{fn fmt(\u0026amp;self,f: \u0026amp;mutstd::fmt::Formatter\u0026lt;\u0026#39;_\u0026gt;)-\u0026gt; std::fmt::Result{write!(f,\u0026#34;{}\u0026#34;,String::from_utf8_lossy(unsafe{CStr::from_ptr(outcome_status_code_message(selfas*const_as*const::std::os::raw::c_void,)).to_bytes()}).to_string())}}implstd::fmt::Debugforcxx_status_code_system{fn fmt(\u0026amp;self,f: \u0026amp;mutstd::fmt::Formatter\u0026lt;\u0026#39;_\u0026gt;)-\u0026gt; std::fmt::Result{write!(f,\u0026#34;{}\u0026#34;,String::from_utf8_lossy(unsafe{CStr::from_ptr(outcome_status_code_message(selfas*const_as*const::std::os::raw::c_void,)).to_bytes()}).to_string())}}fn to_result(res: cxx_result_status_code_system_outcome)-\u0026gt; OutcomeCResult\u0026lt;isize\u0026gt;{if(res.flags\u0026amp;1)==1{returnOk(res.value);}Err(res.error)} Let\u0026rsquo;s say there is an FFI function like this:\nunsafeextern\u0026#34;C\u0026#34;{pubfn file_read(arg1: *mutdb,buffer: *mutu8,bytes: usize,)-\u0026gt; monad_c_result;} You can now do:\n// Make a Rust Result equivalent to the Outcome Result letres=to_result(unsafe{file_read(db,buffer,256)});// Asks Outcome for the message automatically println!(\u0026#34;Message: {}\u0026#34;,res.err().unwrap()); You can use the standard Rust ? to TRY Rust Results, same as anywhere else in Rust.\nEasy as pie!\n"
},
{
	"uri": "https://ned14.github.io/outcome/categories/special/",
	"title": "Special",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ned14.github.io/outcome/categories/tagged-constructors/",
	"title": "Tagged Constructors",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ned14.github.io/outcome/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ned14.github.io/outcome/tags/try/",
	"title": "Try",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ned14.github.io/outcome/tags/value/",
	"title": "Value",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ned14.github.io/outcome/tags/value-or-error/",
	"title": "Value or Error",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ned14.github.io/outcome/reference/macros/version/",
	"title": "Version macros",
	"tags": [],
	"description": "",
	"content": "Overridable: None of the following macros are overridable.\nHeader: \u0026lt;outcome/config.hpp\u0026gt;\n OUTCOME_VERSION_MAJOR \u0026lt;number\u0026gt;\nMajor version for cmake and DLL version stamping.\n OUTCOME_VERSION_MINOR \u0026lt;number\u0026gt;\nMinor version for cmake and DLL version stamping.\n OUTCOME_VERSION_PATCH \u0026lt;number\u0026gt;\nPatch version for cmake and DLL version stamping.\n OUTCOME_VERSION_REVISION \u0026lt;number\u0026gt;\nRevision version for cmake and DLL version stamping.\n OUTCOME_UNSTABLE_VERSION \u0026lt;number\u0026gt;\nDefined between stable releases of Outcome. It means the inline namespace will be permuted per-commit to ensure ABI uniqueness such that multiple versions of Outcome in a single process space cannot collide.\n OUTCOME_V2 \u0026lt;tokens\u0026gt;\nThe namespace configuration of this Outcome v2. Consists of a sequence of bracketed tokens later fused by the preprocessor into namespace and C++ module names.\n OUTCOME_V2_NAMESPACE \u0026lt;identifier\u0026gt;\nThe Outcome namespace, which may be permuted per SHA commit. This is not fully qualified.\n OUTCOME_V2_NAMESPACE_BEGIN \u0026lt;keywords and identifiers\u0026gt;\nExpands into the appropriate namespace markup to enter the Outcome v2 namespace.\n OUTCOME_V2_NAMESPACE_EXPORT_BEGIN \u0026lt;keywords and identifiers\u0026gt;\nExpands into the appropriate namespace markup to enter the C++ module exported Outcome v2 namespace.\n OUTCOME_V2_NAMESPACE_END \u0026lt;keywords and identifiers\u0026gt;\nExpands into the appropriate namespace markup to exit the Outcome v2 namespace.\n  "
},
{
	"uri": "https://ned14.github.io/outcome/reference/macros/co_try/",
	"title": "`OUTCOME_CO_TRY(var, expr)`",
	"tags": [],
	"description": "Evaluate within a coroutine an expression which results in an understood type, assigning `T` to a decl called `var` if successful, immediately returning `try_operation_return_as(X)` from the calling function if unsuccessful.",
	"content": "Evaluate within a coroutine an expression which results in a type matching the following customisation points, assigning T to a decl called var if successful, immediately returning try_operation_return_as(X) from the calling function if unsuccessful:\n OUTCOME_V2_NAMESPACE::try_operation_has_value(X)  OUTCOME_V2_NAMESPACE::try_operation_return_as(X)  OUTCOME_V2_NAMESPACE::try_operation_extract_value(X)   Default overloads for these customisation points are provided. See the recipe for supporting foreign input to OUTCOME_TRY.\nHints are given to the compiler that the expression will be successful. If you expect failure, you should use OUTCOME_CO_TRY_FAILURE_LIKELY(var, expr) instead.\nAn internal temporary to hold the value of the expression is created, which generally invokes a copy/move. If you wish to never copy/move, you can tell this macro to create the internal temporary as a reference instead.\nOverridable: Not overridable.\nDefinition: See OUTCOME_CO_TRYV(expr) for most of the mechanics.\nIf successful, var is initialised or assigned to the expression result\u0026rsquo;s .assume_value() if available, else to its .value(). This binds a reference possibly to the T stored inside the bound result of the expression, but possibly also to a temporary emitted from the value observer function.\nHeader: \u0026lt;outcome/try.hpp\u0026gt;\nLegacy: Before Outcome v2.2, var was always declared as an automatic rvalue ref. You can use the backwards compatibility macro OUTCOME21_CO_TRY() if wish to retain the old behaviour.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/macros/co_tryv/",
	"title": "`OUTCOME_CO_TRYV(expr)/OUTCOME_CO_TRY(expr)`",
	"tags": [],
	"description": "Evaluate from within a coroutine an expression which results in an understood type, continuing execution if successful, immediately returning `try_operation_return_as(X)` from the calling function if unsuccessful.",
	"content": "Evaluate from within a coroutine an expression which results in a type matching the following customisation points, continuing execution if successful, immediately returning try_operation_return_as(X) from the calling function if unsuccessful:\n OUTCOME_V2_NAMESPACE::try_operation_has_value(X)  OUTCOME_V2_NAMESPACE::try_operation_return_as(X)  OUTCOME_V2_NAMESPACE::try_operation_extract_value(X)   Default overloads for these customisation points are provided. See the recipe for supporting foreign input to OUTCOME_TRY.\nThe difference between the OUTCOME_CO_TRYV(expr) and OUTCOME_CO_TRY(expr) editions is that the latter will set a variable if two or more macro arguments are present (see OUTCOME_CO_TRY(var, expr) ). The former requires the T to be void.\nHints are given to the compiler that the expression will be successful. If you expect failure, you should use OUTCOME_CO_TRYV_FAILURE_LIKELY(expr) instead.\nAn internal temporary to hold the value of the expression is created, which generally invokes a copy/move. If you wish to never copy/move, you can tell this macro to create the internal temporary as a reference instead.\nOverridable: Not overridable.\nDefinition: Firstly the expression\u0026rsquo;s temporary is bound to a uniquely named, stack allocated, auto \u0026amp;\u0026amp;. If that reference\u0026rsquo;s bound object\u0026rsquo;s try_operation_has_value() is false, immediately execute return try_operation_return_as(propagated unique reference);, propagating the rvalue/lvalue/etc-ness of the original expression.\nHeader: \u0026lt;outcome/try.hpp\u0026gt;\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/macros/co_tryv2/",
	"title": "`OUTCOME_CO_TRYV2(spec, expr)`",
	"tags": [],
	"description": "Evaluate an expression which results in an understood type, continuing execution if successful, immediately returning `try_operation_return_as(X)` from the calling function if unsuccessful.",
	"content": "Evaluate an expression which results in a type matching the following customisation points, continuing execution if successful, immediately returning try_operation_return_as(X) from the calling function if unsuccessful:\n OUTCOME_V2_NAMESPACE::try_operation_has_value(X)  OUTCOME_V2_NAMESPACE::try_operation_return_as(X)  OUTCOME_V2_NAMESPACE::try_operation_extract_value(X)   Default overloads for these customisation points are provided. See the recipe for supporting foreign input to OUTCOME_TRY.\nHints are given to the compiler that the expression will be successful. If you expect failure, you should use OUTCOME_TRYV2_FAILURE_LIKELY(spec, expr) instead.\nOverridable: Not overridable.\nDefinition: Firstly the expression\u0026rsquo;s temporary is bound to a uniquely named, stack allocated, spec. If that reference\u0026rsquo;s bound object\u0026rsquo;s try_operation_has_value() is false, immediately execute return try_operation_return_as(propagated unique reference);, propagating the rvalue/lvalue/etc-ness of the original expression.\nHeader: \u0026lt;outcome/try.hpp\u0026gt;\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/macros/co_tryv2_failure_likely/",
	"title": "`OUTCOME_CO_TRYV2_FAILURE_LIKELY(spec, expr)`",
	"tags": [],
	"description": "Evaluate an expression which results in an understood type, continuing execution if successful, immediately returning `try_operation_return_as(X)` from the calling function if unsuccessful.",
	"content": "Evaluate an expression which results in a type matching the following customisation points, continuing execution if successful, immediately returning try_operation_return_as(X) from the calling function if unsuccessful:\n OUTCOME_V2_NAMESPACE::try_operation_has_value(X)  OUTCOME_V2_NAMESPACE::try_operation_return_as(X)  OUTCOME_V2_NAMESPACE::try_operation_extract_value(X)   Default overloads for these customisation points are provided. See the recipe for supporting foreign input to OUTCOME_TRY.\nHints are given to the compiler that the expression will be unsuccessful. If you expect success, you should use OUTCOME_TRYV(expr) instead.\nOverridable: Not overridable.\nDefinition: Firstly the expression\u0026rsquo;s temporary is bound to a uniquely named, stack allocated, spec. If that reference\u0026rsquo;s bound object\u0026rsquo;s try_operation_has_value() is false, immediately execute return try_operation_return_as(propagated unique reference);, propagating the rvalue/lvalue/etc-ness of the original expression.\nHeader: \u0026lt;outcome/try.hpp\u0026gt;\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/macros/co_tryv_failure_likely/",
	"title": "`OUTCOME_CO_TRYV_FAILURE_LIKELY(expr)/OUTCOME_CO_TRY_FAILURE_LIKELY(expr)`",
	"tags": [],
	"description": "Evaluate from within a coroutine an expression which results in an understood type, continuing execution if successful, immediately returning `try_operation_return_as(X)` from the calling function if unsuccessful.",
	"content": "Evaluate from within a coroutine an expression which results in a type matching the following customisation points, continuing execution if successful, immediately returning try_operation_return_as(X) from the calling function if unsuccessful:\n OUTCOME_V2_NAMESPACE::try_operation_has_value(X)  OUTCOME_V2_NAMESPACE::try_operation_return_as(X)  OUTCOME_V2_NAMESPACE::try_operation_extract_value(X)   Default overloads for these customisation points are provided. See the recipe for supporting foreign input to OUTCOME_TRY.\nThe difference between the OUTCOME_CO_TRYV(expr) and OUTCOME_CO_TRY(expr) editions is that the latter will set a variable if two or more macro arguments are present (see OUTCOME_CO_TRY(var, expr) ). The former requires the T to be void.\nHints are given to the compiler that the expression will be unsuccessful. If you expect success, you should use OUTCOME_CO_TRYV(expr) instead.\nAn internal temporary to hold the value of the expression is created, which generally invokes a copy/move. If you wish to never copy/move, you can tell this macro to create the internal temporary as a reference instead.\nOverridable: Not overridable.\nDefinition: Firstly the expression\u0026rsquo;s temporary is bound to a uniquely named, stack allocated, auto \u0026amp;\u0026amp;. If that reference\u0026rsquo;s bound object\u0026rsquo;s try_operation_has_value() is false, immediately execute return try_operation_return_as(propagated unique reference);, propagating the rvalue/lvalue/etc-ness of the original expression.\nHeader: \u0026lt;outcome/try.hpp\u0026gt;\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/macros/co_tryx/",
	"title": "`OUTCOME_CO_TRYX(expr)`",
	"tags": [],
	"description": "Evaluate from within a coroutine an expression which results in an understood type, emitting the `T` if successful, immediately returning `try_operation_return_as(X)` from the calling function if unsuccessful.",
	"content": "Evaluate within a coroutine an expression which results in a type matching the following customisation points, emitting the T if successful, immediately returning try_operation_return_as(X) from the calling function if unsuccessful:\n OUTCOME_V2_NAMESPACE::try_operation_has_value(X)  OUTCOME_V2_NAMESPACE::try_operation_return_as(X)  OUTCOME_V2_NAMESPACE::try_operation_extract_value(X)   Default overloads for these customisation points are provided. See the recipe for supporting foreign input to OUTCOME_TRY.\nHints are given to the compiler that the expression will be successful. If you expect failure, you should use OUTCOME_CO_TRYX_FAILURE_LIKELY(expr) instead.\nAn internal temporary to hold the value of the expression is created, which generally invokes a copy/move. If you wish to never copy/move, you can tell this macro to create the internal temporary as a reference instead.\nAvailability: GCC and clang only. Use #ifdef OUTCOME_CO_TRYX to determine if available.\nOverridable: Not overridable.\nDefinition: See OUTCOME_CO_TRYV(expr) for most of the mechanics.\nThis macro makes use of a proprietary extension in GCC and clang to emit the T from a successful expression. You can thus use OUTCOME_CO_TRYX(expr) directly in expressions e.g. auto x = y + OUTCOME_CO_TRYX(foo(z));.\nBe aware there are compiler quirks in preserving the rvalue/lvalue/etc-ness of emitted T\u0026rsquo;s, specifically copy or move constructors may be called unexpectedly and/or copy elision not work as expected. If these prove to be problematic, use OUTCOME_CO_TRY(var, expr) instead.\nHeader: \u0026lt;outcome/try.hpp\u0026gt;\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/macros/co_tryx_failure_likely/",
	"title": "`OUTCOME_CO_TRYX_FAILURE_LIKELY(expr)`",
	"tags": [],
	"description": "Evaluate from within a coroutine an expression which results in an understood type, emitting the `T` if successful, immediately returning `try_operation_return_as(X)` from the calling function if unsuccessful.",
	"content": "Evaluate within a coroutine an expression which results in a type matching the following customisation points, emitting the T if successful, immediately returning try_operation_return_as(X) from the calling function if unsuccessful:\n OUTCOME_V2_NAMESPACE::try_operation_has_value(X)  OUTCOME_V2_NAMESPACE::try_operation_return_as(X)  OUTCOME_V2_NAMESPACE::try_operation_extract_value(X)   Default overloads for these customisation points are provided. See the recipe for supporting foreign input to OUTCOME_TRY.\nHints are given to the compiler that the expression will be unsuccessful. If you expect success, you should use OUTCOME_CO_TRYX(expr) instead.\nAn internal temporary to hold the value of the expression is created, which generally invokes a copy/move. If you wish to never copy/move, you can tell this macro to create the internal temporary as a reference instead.\nAvailability: GCC and clang only. Use #ifdef OUTCOME_CO_TRYX to determine if available.\nOverridable: Not overridable.\nDefinition: See OUTCOME_CO_TRYV(expr) for most of the mechanics.\nThis macro makes use of a proprietary extension in GCC and clang to emit the T from a successful expression. You can thus use OUTCOME_CO_TRYX(expr) directly in expressions e.g. auto x = y + OUTCOME_CO_TRYX(foo(z));.\nBe aware there are compiler quirks in preserving the rvalue/lvalue/etc-ness of emitted T\u0026rsquo;s, specifically copy or move constructors may be called unexpectedly and/or copy elision not work as expected. If these prove to be problematic, use OUTCOME_CO_TRY(var, expr) instead.\nHeader: \u0026lt;outcome/try.hpp\u0026gt;\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/macros/co_try_failure_likely/",
	"title": "`OUTCOME_CO_TRY_FAILURE_LIKELY(var, expr)`",
	"tags": [],
	"description": "Evaluate within a coroutine an expression which results in an understood type, assigning `T` to a decl called `var` if successful, immediately returning `try_operation_return_as(X)` from the calling function if unsuccessful.",
	"content": "Evaluate within a coroutine an expression which results in a type matching the following customisation points, assigning T to a decl called var if successful, immediately returning try_operation_return_as(X) from the calling function if unsuccessful:\n OUTCOME_V2_NAMESPACE::try_operation_has_value(X)  OUTCOME_V2_NAMESPACE::try_operation_return_as(X)  OUTCOME_V2_NAMESPACE::try_operation_extract_value(X)   Default overloads for these customisation points are provided. See the recipe for supporting foreign input to OUTCOME_TRY.\nHints are given to the compiler that the expression will be unsuccessful. If you expect success, you should use OUTCOME_CO_TRY(var, expr) instead.\nAn internal temporary to hold the value of the expression is created, which generally invokes a copy/move. If you wish to never copy/move, you can tell this macro to create the internal temporary as a reference instead.\nOverridable: Not overridable.\nDefinition: See OUTCOME_CO_TRYV(expr) for most of the mechanics.\nIf successful, var is initialised or assigned to the expression result\u0026rsquo;s .assume_value() if available, else to its .value(). This binds a reference possibly to the T stored inside the bound result of the expression, but possibly also to a temporary emitted from the value observer function.\nHeader: \u0026lt;outcome/try.hpp\u0026gt;\nLegacy: Before Outcome v2.2, var was always declared as an automatic rvalue ref. You can use the backwards compatibility macro OUTCOME21_CO_TRY() if wish to retain the old behaviour.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/macros/disable_execinfo/",
	"title": "`OUTCOME_DISABLE_EXECINFO`",
	"tags": [],
	"description": "If defined, disables the use of the `&lt;execinfo.h&gt;` header (or the win32 emulation).",
	"content": "If defined, disables the use of the \u0026lt;execinfo.h\u0026gt; header (or the win32 emulation).\nSome embedded Linux toolchains do not define \u0026lt;execinfo.h\u0026gt;, thus disabling C++ exceptions on those toolchains produces a failure to find this file. Avoid that problem by defining this macro to disable stack backtrace support entirely.\nOverridable: Define before inclusion.\nDefault: Defined if __ANDROID__ is defined, else undefined.\nHeader: \u0026lt;outcome/config.hpp\u0026gt;\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/macros/enable_legacy_support_for/",
	"title": "`OUTCOME_ENABLE_LEGACY_SUPPORT_FOR`",
	"tags": [],
	"description": "Enables backwards features and naming compatibility for earlier versions of Outcome.",
	"content": "As Outcome has evolved, some features and especially naming were retired in newer versions. Define this macro to enable backwards compatibility aliasing from old features and naming to new features and naming.\nOverridable: Define before inclusion.\nDefault: The current version of Outcome, expressed in hundreds e.g. Outcome v2.10 is 210.\nHeader: \u0026lt;outcome/config.hpp\u0026gt;\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/macros/nodiscard/",
	"title": "`OUTCOME_NODISCARD`",
	"tags": [],
	"description": "How to tell the compiler than the return value of a function should not be discarded without examining it.",
	"content": "Compiler-specific markup used to tell the compiler than the return value of a function should not be discarded without examining it.\nOverridable: Define before inclusion.\nDefault: To [[nodiscard]] if on C++ 17 or higher, __attribute__((warn_unused_result)) if on clang, SAL _Must_inspect_result_ if on MSVC, otherwise nothing.\nHeader: \u0026lt;outcome/config.hpp\u0026gt;\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/macros/requires/",
	"title": "`OUTCOME_REQUIRES(...)`",
	"tags": [],
	"description": "A C++ 20 `requires(...)`, if available.",
	"content": "A C++ 20 requires(...), if available.\nOverridable: Define before inclusion.\nDefault: To requires(...) if on C++ 20 or later, else to nothing.\nHeader: \u0026lt;outcome/config.hpp\u0026gt;\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/macros/symbol_visible/",
	"title": "`OUTCOME_SYMBOL_VISIBLE`",
	"tags": [],
	"description": "How to mark throwable types as always having default ELF symbol visibility.",
	"content": "Compiler-specific markup used to mark throwable types as always having default ELF symbol visibility, without which it will be impossible to catch throws of such types across shared library boundaries on ELF only.\nOverridable: Define before inclusion.\nDefault: Standalone Outcome: To __attribute__((visibility(\u0026quot;default\u0026quot;)) on GCC and clang when targeting ELF, otherwise nothing. Boost.Outcome: To BOOST_SYMBOL_VISIBLE. \nHeader: \u0026lt;outcome/config.hpp\u0026gt;\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/macros/thread_local/",
	"title": "`OUTCOME_THREAD_LOCAL`",
	"tags": [],
	"description": "How to mark variables as having thread local storage duration.",
	"content": "Compiler-specific markup used to mark variables as having thread local storage duration.\nThis isn\u0026rsquo;t used inside Outcome, but is used by its unit test suite.\n Overridable: Define before inclusion.\nDefault: To thread_local if the compiler implements C++ 11 thread_local, else __thread for the one supported compiler (older Mac OS XCode) which does not.\nHeader: \u0026lt;outcome/config.hpp\u0026gt;\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/macros/throw_exception/",
	"title": "`OUTCOME_THROW_EXCEPTION(expr)`",
	"tags": [],
	"description": "How to throw a C++ exception, or equivalent thereof.",
	"content": "Throws a C++ exception, or equivalent thereof.\nOverridable: Define before inclusion.\nDefault: Standalone Outcome (C++ exceptions enabled): To throw expr Standalone Outcome (C++ exceptions disabled): To OUTCOME_V2_NAMESPACE::detail::do_fatal_exit(#expr) which is a function which prints a useful error message including a stack backtrace (where available) to stderr before calling abort(). Boost.Outcome: To BOOST_THROW_EXCEPTION(expr). \nHeader: \u0026lt;outcome/config.hpp\u0026gt;\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/macros/try/",
	"title": "`OUTCOME_TRY(var, expr)`",
	"tags": [],
	"description": "Evaluate an expression which results in an understood type, assigning `T` to a decl called `var` if successful, immediately returning `try_operation_return_as(X)` from the calling function if unsuccessful.",
	"content": "Evaluate an expression which results in a type matching the following customisation points, assigning T to a decl called var if successful, immediately returning try_operation_return_as(X) from the calling function if unsuccessful:\n OUTCOME_V2_NAMESPACE::try_operation_has_value(X)  OUTCOME_V2_NAMESPACE::try_operation_return_as(X)  OUTCOME_V2_NAMESPACE::try_operation_extract_value(X)   Default overloads for these customisation points are provided. See the recipe for supporting foreign input to OUTCOME_TRY.\nHints are given to the compiler that the expression will be successful. If you expect failure, you should use OUTCOME_TRY_FAILURE_LIKELY(var, expr) instead.\nAn internal temporary to hold the value of the expression is created, which generally invokes a copy/move. If you wish to never copy/move, you can tell this macro to create the internal temporary as a reference instead.\nOverridable: Not overridable.\nDefinition: See OUTCOME_TRYV(expr) for most of the mechanics.\nIf successful, var is initialised or assigned to the expression result\u0026rsquo;s .assume_value() if available, else to its .value(). This binds a reference possibly to the T stored inside the bound result of the expression, but possibly also to a temporary emitted from the value observer function.\nHeader: \u0026lt;outcome/try.hpp\u0026gt;\nLegacy: Before Outcome v2.2, var was always declared as an automatic rvalue ref. You can use the backwards compatibility macro OUTCOME21_TRY() if wish to retain the old behaviour.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/macros/tryv/",
	"title": "`OUTCOME_TRYV(expr)/OUTCOME_TRY(expr)`",
	"tags": [],
	"description": "Evaluate an expression which results in an understood type, continuing execution if successful, immediately returning `try_operation_return_as(X)` from the calling function if unsuccessful.",
	"content": "Evaluate an expression which results in a type matching the following customisation points, continuing execution if successful, immediately returning try_operation_return_as(X) from the calling function if unsuccessful:\n OUTCOME_V2_NAMESPACE::try_operation_has_value(X)  OUTCOME_V2_NAMESPACE::try_operation_return_as(X)  OUTCOME_V2_NAMESPACE::try_operation_extract_value(X)   Default overloads for these customisation points are provided. See the recipe for supporting foreign input to OUTCOME_TRY.\nThe difference between the OUTCOME_TRYV(expr) and OUTCOME_TRY(expr) editions is that the latter will set a variable if two or more macro arguments are present (see OUTCOME_TRY(var, expr) ). The former requires the T to be void.\nHints are given to the compiler that the expression will be successful. If you expect failure, you should use OUTCOME_TRYV_FAILURE_LIKELY(expr) instead.\nAn internal temporary to hold the value of the expression is created, which generally invokes a copy/move. If you wish to never copy/move, you can tell this macro to create the internal temporary as a reference instead.\nOverridable: Not overridable.\nDefinition: Firstly the expression\u0026rsquo;s temporary is bound to a uniquely named, stack allocated, auto \u0026amp;\u0026amp;. If that reference\u0026rsquo;s bound object\u0026rsquo;s try_operation_has_value() is false, immediately execute return try_operation_return_as(propagated unique reference);, propagating the rvalue/lvalue/etc-ness of the original expression.\nHeader: \u0026lt;outcome/try.hpp\u0026gt;\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/macros/tryv2/",
	"title": "`OUTCOME_TRYV2(spec, expr)`",
	"tags": [],
	"description": "Evaluate an expression which results in an understood type, continuing execution if successful, immediately returning `try_operation_return_as(X)` from the calling function if unsuccessful.",
	"content": "Evaluate an expression which results in a type matching the following customisation points, continuing execution if successful, immediately returning try_operation_return_as(X) from the calling function if unsuccessful:\n OUTCOME_V2_NAMESPACE::try_operation_has_value(X)  OUTCOME_V2_NAMESPACE::try_operation_return_as(X)  OUTCOME_V2_NAMESPACE::try_operation_extract_value(X)   Default overloads for these customisation points are provided. See the recipe for supporting foreign input to OUTCOME_TRY.\nHints are given to the compiler that the expression will be successful. If you expect failure, you should use OUTCOME_TRYV2_FAILURE_LIKELY(spec, expr) instead.\nOverridable: Not overridable.\nDefinition: Firstly the expression\u0026rsquo;s temporary is bound to a uniquely named, stack allocated, spec. If that reference\u0026rsquo;s bound object\u0026rsquo;s try_operation_has_value() is false, immediately execute return try_operation_return_as(propagated unique reference);, propagating the rvalue/lvalue/etc-ness of the original expression.\nHeader: \u0026lt;outcome/try.hpp\u0026gt;\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/macros/tryv2_failure_likely/",
	"title": "`OUTCOME_TRYV2_FAILURE_LIKELY(spec, expr)`",
	"tags": [],
	"description": "Evaluate an expression which results in an understood type, continuing execution if successful, immediately returning `try_operation_return_as(X)` from the calling function if unsuccessful.",
	"content": "Evaluate an expression which results in a type matching the following customisation points, continuing execution if successful, immediately returning try_operation_return_as(X) from the calling function if unsuccessful:\n OUTCOME_V2_NAMESPACE::try_operation_has_value(X)  OUTCOME_V2_NAMESPACE::try_operation_return_as(X)  OUTCOME_V2_NAMESPACE::try_operation_extract_value(X)   Default overloads for these customisation points are provided. See the recipe for supporting foreign input to OUTCOME_TRY.\nHints are given to the compiler that the expression will be unsuccessful. If you expect success, you should use OUTCOME_TRYV(expr) instead.\nOverridable: Not overridable.\nDefinition: Firstly the expression\u0026rsquo;s temporary is bound to a uniquely named, stack allocated, spec. If that reference\u0026rsquo;s bound object\u0026rsquo;s try_operation_has_value() is false, immediately execute return try_operation_return_as(propagated unique reference);, propagating the rvalue/lvalue/etc-ness of the original expression.\nHeader: \u0026lt;outcome/try.hpp\u0026gt;\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/macros/tryv_failure_likely/",
	"title": "`OUTCOME_TRYV_FAILURE_LIKELY(expr)/OUTCOME_TRY_FAILURE_LIKELY(expr)`",
	"tags": [],
	"description": "Evaluate an expression which results in an understood type, continuing execution if successful, immediately returning `try_operation_return_as(X)` from the calling function if unsuccessful.",
	"content": "Evaluate an expression which results in a type matching the following customisation points, continuing execution if successful, immediately returning try_operation_return_as(X) from the calling function if unsuccessful:\n OUTCOME_V2_NAMESPACE::try_operation_has_value(X)  OUTCOME_V2_NAMESPACE::try_operation_return_as(X)  OUTCOME_V2_NAMESPACE::try_operation_extract_value(X)   Default overloads for these customisation points are provided. See the recipe for supporting foreign input to OUTCOME_TRY.\nThe difference between the OUTCOME_TRYV(expr) and OUTCOME_TRY(expr) editions is that the latter will set a variable if two or more macro arguments are present (see OUTCOME_TRY(var, expr) ). The former requires the T to be void.\nHints are given to the compiler that the expression will be unsuccessful. If you expect success, you should use OUTCOME_TRYV(expr) instead.\nAn internal temporary to hold the value of the expression is created, which generally invokes a copy/move. If you wish to never copy/move, you can tell this macro to create the internal temporary as a reference instead.\nOverridable: Not overridable.\nDefinition: Firstly the expression\u0026rsquo;s temporary is bound to a uniquely named, stack allocated, auto \u0026amp;\u0026amp;. If that reference\u0026rsquo;s bound object\u0026rsquo;s try_operation_has_value() is false, immediately execute return try_operation_return_as(propagated unique reference);, propagating the rvalue/lvalue/etc-ness of the original expression.\nHeader: \u0026lt;outcome/try.hpp\u0026gt;\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/macros/tryx/",
	"title": "`OUTCOME_TRYX(expr)`",
	"tags": [],
	"description": "Evaluate an expression which results in an understood type, emitting the `T` if successful, immediately returning `try_operation_return_as(X)` from the calling function if unsuccessful.",
	"content": "Evaluate an expression which results in a type matching the following customisation points, emitting the T if successful, immediately returning try_operation_return_as(X) from the calling function if unsuccessful:\n OUTCOME_V2_NAMESPACE::try_operation_has_value(X)  OUTCOME_V2_NAMESPACE::try_operation_return_as(X)  OUTCOME_V2_NAMESPACE::try_operation_extract_value(X)   Default overloads for these customisation points are provided. See the recipe for supporting foreign input to OUTCOME_TRY.\nHints are given to the compiler that the expression will be successful. If you expect failure, you should use OUTCOME_TRYX_FAILURE_LIKELY(expr) instead.\nAn internal temporary to hold the value of the expression is created, which generally invokes a copy/move. If you wish to never copy/move, you can tell this macro to create the internal temporary as a reference instead.\nAvailability: GCC and clang only. Use #ifdef OUTCOME_TRYX to determine if available.\nOverridable: Not overridable.\nDefinition: See OUTCOME_TRYV(expr) for most of the mechanics.\nThis macro makes use of a proprietary extension in GCC and clang to emit the T from a successful expression. You can thus use OUTCOME_TRYX(expr) directly in expressions e.g. auto x = y + OUTCOME_TRYX(foo(z));.\nBe aware there are compiler quirks in preserving the rvalue/lvalue/etc-ness of emitted T\u0026rsquo;s, specifically copy or move constructors may be called unexpectedly and/or copy elision not work as expected. If these prove to be problematic, use OUTCOME_TRY(var, expr) instead.\nHeader: \u0026lt;outcome/try.hpp\u0026gt;\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/macros/tryx_failure_likely/",
	"title": "`OUTCOME_TRYX_FAILURE_LIKELY(expr)`",
	"tags": [],
	"description": "Evaluate an expression which results in an understood type, emitting the `T` if successful, immediately returning `try_operation_return_as(X)` from the calling function if unsuccessful.",
	"content": "Evaluate an expression which results in a type matching the following customisation points, emitting the T if successful, immediately returning try_operation_return_as(X) from the calling function if unsuccessful:\n OUTCOME_V2_NAMESPACE::try_operation_has_value(X)  OUTCOME_V2_NAMESPACE::try_operation_return_as(X)  OUTCOME_V2_NAMESPACE::try_operation_extract_value(X)   Default overloads for these customisation points are provided. See the recipe for supporting foreign input to OUTCOME_TRY.\nHints are given to the compiler that the expression will be unsuccessful. If you expect success, you should use OUTCOME_TRYX(expr) instead.\nAn internal temporary to hold the value of the expression is created, which generally invokes a copy/move. If you wish to never copy/move, you can tell this macro to create the internal temporary as a reference instead.\nAvailability: GCC and clang only. Use #ifdef OUTCOME_TRYX to determine if available.\nOverridable: Not overridable.\nDefinition: See OUTCOME_TRYV(expr) for most of the mechanics.\nThis macro makes use of a proprietary extension in GCC and clang to emit the T from a successful expression. You can thus use OUTCOME_TRYX(expr) directly in expressions e.g. auto x = y + OUTCOME_TRYX(foo(z));.\nBe aware there are compiler quirks in preserving the rvalue/lvalue/etc-ness of emitted T\u0026rsquo;s, specifically copy or move constructors may be called unexpectedly and/or copy elision not work as expected. If these prove to be problematic, use OUTCOME_TRY(var, expr) instead.\nHeader: \u0026lt;outcome/try.hpp\u0026gt;\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/macros/try_failure_likely/",
	"title": "`OUTCOME_TRY_FAILURE_LIKELY(var, expr)`",
	"tags": [],
	"description": "Evaluate an expression which results in an understood type, assigning `T` to a decl called `var` if successful, immediately returning `try_operation_return_as(X)` from the calling function if unsuccessful.",
	"content": "Evaluate an expression which results in a type matching the following customisation points, assigning T to a decl called var if successful, immediately returning try_operation_return_as(X) from the calling function if unsuccessful:\n OUTCOME_V2_NAMESPACE::try_operation_has_value(X)  OUTCOME_V2_NAMESPACE::try_operation_return_as(X)  OUTCOME_V2_NAMESPACE::try_operation_extract_value(X)   Default overloads for these customisation points are provided. See the recipe for supporting foreign input to OUTCOME_TRY.\nHints are given to the compiler that the expression will be unsuccessful. If you expect success, you should use OUTCOME_TRY(var, expr) instead.\nAn internal temporary to hold the value of the expression is created, which generally invokes a copy/move. If you wish to never copy/move, you can tell this macro to create the internal temporary as a reference instead.\nOverridable: Not overridable.\nDefinition: See OUTCOME_TRYV(expr) for most of the mechanics.\nIf successful, var is initialised or assigned to the expression result\u0026rsquo;s .assume_value() if available, else to its .value(). This binds a reference possibly to the T stored inside the bound result of the expression, but possibly also to a temporary emitted from the value observer function.\nHeader: \u0026lt;outcome/try.hpp\u0026gt;\nLegacy: Before Outcome v2.2, var was always declared as an automatic rvalue ref. You can use the backwards compatibility macro OUTCOME21_CO_TRY() if wish to retain the old behaviour.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/macros/in_place_type/",
	"title": "`OUTCOME_USE_STD_IN_PLACE_TYPE`",
	"tags": [],
	"description": "How to implement `in_place_type_t&lt;T&gt;` and `in_place_type&lt;T&gt;`.",
	"content": "How to implement in_place_type_t\u0026lt;T\u0026gt; and in_place_type\u0026lt;T\u0026gt;.\nIf set to 1, the \u0026lt;utility\u0026gt; header is included, and std::in_place_type_t\u0026lt;T\u0026gt; is aliased into OUTCOME_V2_NAMESPACE::in_place_type_t\u0026lt;T\u0026gt; along with std::in_place_type\u0026lt;T\u0026gt;.\nIf set to 0, a local emulation is used.\nOverridable: Define before inclusion.\nDefault: If the current compiler implements C++ 17 or later, if unset this macro is defaulted to 1, otherwise it is defaulted to 0.\nHeader: \u0026lt;outcome/config.hpp\u0026gt;\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/macros/is_nothrow_swappable/",
	"title": "`OUTCOME_USE_STD_IS_NOTHROW_SWAPPABLE`",
	"tags": [],
	"description": "How to implement `is_nothrow_swappable&lt;T&gt;`.",
	"content": "Whether to implement is_nothrow_swappable\u0026lt;T\u0026gt; as std::is_nothrow_swappable\u0026lt;T\u0026gt;, or else use a local emulation.\nOverridable: Define before inclusion.\nDefault: If the current compiler implements C++ 17 or later, if unset this macro is defaulted to 1, otherwise it is defaulted to 0.\nHeader: \u0026lt;outcome/config.hpp\u0026gt;\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/policies/all_narrow/",
	"title": "`all_narrow`",
	"tags": [],
	"description": "Policy class defining that hard undefined behaviour should occur on incorrect narrow and wide value, error or exception observation. Inherits publicly from `base`.",
	"content": "Policy class defining that hard undefined behaviour should occur on incorrect narrow and wide value, error or exception observation.\nInherits publicly from base , and simply defines its wide value, error and exception observer policies to call their corresponding narrow editions.\nIncluded by \u0026lt;basic_result.hpp\u0026gt;, and so is always available when basic_result is available.\nRequires: Nothing.\nNamespace: OUTCOME_V2_NAMESPACE::policy\nHeader: \u0026lt;outcome/policy/all_narrow.hpp\u0026gt;\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/functions/policy/basic_outcome_failure_exception_from_error/",
	"title": "`auto basic_outcome_failure_exception_from_error(const EC &amp;)`",
	"tags": [],
	"description": "ADL discovered free function synthesising an exception type from an error type, used by the `.failure()` observers.",
	"content": "Synthesises an exception type from an error type, used by the exception_type failure() const noexcept observers. ADL discovered. Default overloads for this function are defined in Outcome for  std::error_code and boost::system::error_code, these return std::make_exception_ptr(std::system_error(ec)) and boost::copy_exception(boost::system::system_error(ec)) respectively.\nOverridable: Argument dependent lookup.\nRequires: Nothing.\nNamespace: Namespace of EC type.\nHeader: \u0026lt;outcome/std_outcome.hpp\u0026gt;, \u0026lt;outcome/boost_outcome.hpp\u0026gt;\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/functions/failure/",
	"title": "`auto failure(T &amp;&amp;, ...)`",
	"tags": [],
	"description": "Returns appropriate type sugar for constructing an unsuccessful result or outcome.",
	"content": "Returns appropriate type sugar for constructing an unsuccessful result or outcome, usually failure_type\u0026lt;EC, EP = void\u0026gt; with a decayed T.\nTwo default overloads are provided, one taking a single required parameter with optional spare storage value parameter returning failure_type\u0026lt;std::decay_t\u0026lt;T\u0026gt;\u0026gt;, the other taking two required parameters with optional spare storage value parameter returning failure_type\u0026lt;std::decay_t\u0026lt;T\u0026gt;, std::decay_t\u0026lt;U\u0026gt;\u0026gt;. Both overloads perfectly forward their inputs.\nNote that failure() overloads are permitted by Outcome to return something other than failure_type. For example, basic_result\u0026rsquo;s auto as_failure() const \u0026amp; returns whatever type failure() returns, and OUTCOME_TRY(var, expr) by default returns for failure whatever .as_failure() returns. This can be useful to have OUTCOME_TRY(...} propagate on failure something custom for some specific input basic_result or basic_outcome.\nOverridable: By Argument Dependent Lookup (ADL).\nRequires: Always available.\nNamespace: OUTCOME_V2_NAMESPACE\nHeader: \u0026lt;outcome/success_failure.hpp\u0026gt;\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/functions/success/",
	"title": "`auto success(T &amp;&amp;, ...)`",
	"tags": [],
	"description": "Returns appropriate type sugar for constructing a successful result or outcome.",
	"content": "Returns appropriate type sugar for constructing a successful result or outcome, usually success_type\u0026lt;T\u0026gt; with a decayed T.\nTwo default overloads are provided, one taking a single required parameter with optional spare storage value parameter returning success_type\u0026lt;std::decay_t\u0026lt;T\u0026gt;\u0026gt; and perfectly forwarding the input. The other overload takes no parameters, and returns success_type\u0026lt;void\u0026gt;, which usually causes the construction of the receiving basic_result or basic_outcome\u0026rsquo;s with a default construction of their value type.\nOverridable: By Argument Dependent Lookup (ADL).\nRequires: Always available.\nNamespace: OUTCOME_V2_NAMESPACE\nHeader: \u0026lt;outcome/success_failure.hpp\u0026gt;\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/bad_outcome_access/",
	"title": "`bad_outcome_access`",
	"tags": [],
	"description": "Exception type publicly inheriting from `std::logic_error` indicating an incorrect observation of value or error or exception occurred.",
	"content": "Exception type publicly inheriting from  std::logic_error indicating an incorrect observation of value or error or exception occurred by basic_outcome\u0026lt;T, EC, EP, NoValuePolicy\u0026gt; .\nNo member functions are added in addition to std::logic_error. Typical .what() strings are:\n \u0026quot;no value\u0026quot; \u0026quot;no error\u0026quot; \u0026quot;no exception\u0026quot;  Requires: Nothing.\nNamespace: OUTCOME_V2_NAMESPACE\nHeader: \u0026lt;outcome/bad_access.hpp\u0026gt;\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/bad_result_access_with/",
	"title": "`bad_result_access_with&lt;EC&gt;`",
	"tags": [],
	"description": "Exception type publicly inheriting from `bad_result_access` indicating an incorrect observation of value occurred, supplying the error value.",
	"content": "Exception type publicly inheriting from bad_result_access , and thus also  std::logic_error , indicating an incorrect observation of value occurred. The error value at the time of the exception throw is moved or copied into this type, and is available using the .error() observer which comes in lvalue ref, const lvalue ref, rvalue ref, and const rvalue ref overloads.\nThe primary purpose of this exception type is to enable standing in for  P0323 std::expected\u0026lt;T, E\u0026gt; \u0026rsquo;s bad_expected_access\u0026lt;E\u0026gt; which is thrown on incorrect wide value observation. This is why it is only ever EC which is thrown with bad_result_access_with\u0026lt;EC\u0026gt; on value observation only, and only when there is an error available. See the throw_bad_result_access\u0026lt;EC\u0026gt; policy for more information.\nRequires: Nothing.\nNamespace: OUTCOME_V2_NAMESPACE\nHeader: \u0026lt;outcome/bad_access.hpp\u0026gt;\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/bad_result_access/",
	"title": "`bad_result_access`",
	"tags": [],
	"description": "Exception type publicly inheriting from `std::logic_error` indicating an incorrect observation of value or error occurred.",
	"content": "Exception type publicly inheriting from  std::logic_error indicating an incorrect observation of value or error occurred by basic_result\u0026lt;T, E, NoValuePolicy\u0026gt; .\nNo member functions are added in addition to std::logic_error. Typical .what() strings are:\n \u0026quot;no value\u0026quot; \u0026quot;no error\u0026quot;  Requires: Nothing.\nNamespace: OUTCOME_V2_NAMESPACE\nHeader: \u0026lt;outcome/bad_access.hpp\u0026gt;\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/policies/base/",
	"title": "`base`",
	"tags": [],
	"description": "Base class of most policy classes defining the narrow observer policies.",
	"content": " Implements the base class of most policy classes defining the narrow observer policies.\nRequires: Nothing.\nNamespace: OUTCOME_V2_NAMESPACE::policy\nHeader: \u0026lt;outcome/policy/base.hpp\u0026gt;\nProtected member functions Special  static void _ub(Impl \u0026amp;\u0026amp;) Special function which causes noticeable hard undefined behaviour.\n Observers  static bool _has_value(Impl \u0026amp;\u0026amp;) noexcept Returns true if a value is present in the implementation passed in. Constexpr, never throws.\n static bool _has_error(Impl \u0026amp;\u0026amp;) noexcept Returns true if an error is present in the implementation passed in. Constexpr, never throws.\n static bool _has_exception(Impl \u0026amp;\u0026amp;) noexcept Returns true if an exception is present in the implementation passed in. Constexpr, never throws.\n static bool _has_error_is_errno(Impl \u0026amp;\u0026amp;) noexcept Returns true if the error code in the implementation passed in has a domain or category matching that of POSIX errno. Constexpr, never throws.\n static auto \u0026amp;\u0026amp;_value(Impl \u0026amp;\u0026amp;) noexcept Returns a reference to the value in the implementation passed in. Constexpr, never throws.\n static auto \u0026amp;\u0026amp;_error(Impl \u0026amp;\u0026amp;) noexcept Returns a reference to the error in the implementation passed in. Constexpr, never throws.\n static auto \u0026amp;\u0026amp;_exception(Impl \u0026amp;\u0026amp;) noexcept Returns a reference to the exception in the implementation passed in. Constexpr, never throws.\n Modifiers  static void _set_has_value(Impl \u0026amp;\u0026amp;, bool) noexcept Sets whether the implementation has a value. Constexpr, never throws.\n static void _set_has_error(Impl \u0026amp;\u0026amp;, bool) noexcept Sets whether the implementation has an error. Constexpr, never throws.\n static void _set_has_exception(Impl \u0026amp;\u0026amp;, bool) noexcept Sets whether the implementation has an exception. Constexpr, never throws.\n static void _set_has_exception(Impl \u0026amp;\u0026amp;, bool) noexcept Sets whether the implementation\u0026rsquo;s error code has a domain or category matching that of POSIX errno. Constexpr, never throws.\n Public member functions  static void narrow_value_check(Impl \u0026amp;\u0026amp;) noexcept Observer policy performing hard UB if no value is present. Constexpr, never throws.\n static void narrow_error_check(Impl \u0026amp;\u0026amp;) noexcept Observer policy performing hard UB if no error is present. Constexpr, never throws.\n static void narrow_exception_check(Impl \u0026amp;\u0026amp;) noexcept Observer policy performing hard UB if no exception is present. Constexpr, never throws.\n static void on_outcome_construction(T *, U \u0026amp;\u0026amp;) noexcept (\u0026gt;= Outcome v2.2.0) Hook invoked by the implicit constructors of basic_outcome.\n static void on_outcome_construction(T *, U \u0026amp;\u0026amp;, V \u0026amp;\u0026amp;) noexcept (\u0026gt;= Outcome v2.2.0) Hook invoked by the implicit constructors of basic_outcome.\n static void on_outcome_copy_construction(T *, U \u0026amp;\u0026amp;) noexcept (\u0026gt;= Outcome v2.2.0) Hook invoked by the converting copy constructors of basic_outcome.\n static void on_outcome_copy_construction(T *, U \u0026amp;\u0026amp;, V \u0026amp;\u0026amp;) noexcept (\u0026gt;= Outcome v2.2.0) Hook invoked by the converting copy constructors of basic_outcome.\n static void on_outcome_in_place_construction(T *, in_place_type_t\u0026lt;U\u0026gt;, Args \u0026amp;\u0026amp;...) noexcept (\u0026gt;= Outcome v2.2.0) Hook invoked by the in-place constructors of basic_outcome.\n static void on_outcome_move_construction(T *, U \u0026amp;\u0026amp;) noexcept (\u0026gt;= Outcome v2.2.0) Hook invoked by the converting move constructors of basic_outcome.\n static void on_outcome_move_construction(T *, U \u0026amp;\u0026amp;, V \u0026amp;\u0026amp;) noexcept (\u0026gt;= Outcome v2.2.0) Hook invoked by the converting move constructors of basic_outcome.\n static void on_result_construction(T *, U \u0026amp;\u0026amp;) noexcept (\u0026gt;= Outcome v2.2.0) Hook invoked by the implicit constructors of basic_result.\n static void on_result_copy_construction(T *, U \u0026amp;\u0026amp;) noexcept (\u0026gt;= Outcome v2.2.0) Hook invoked by the converting copy constructors of basic_result.\n static void on_result_in_place_construction(T *, in_place_type_t\u0026lt;U\u0026gt;, Args \u0026amp;\u0026amp;...) noexcept (\u0026gt;= Outcome v2.2.0) Hook invoked by the in-place constructors of basic_result.\n static void on_result_move_construction(T *, U \u0026amp;\u0026amp;) noexcept (\u0026gt;= Outcome v2.2.0) Hook invoked by the converting move constructors of basic_result.\n "
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/basic_outcome/",
	"title": "`basic_outcome&lt;T, EC, EP, NoValuePolicy&gt;`",
	"tags": [],
	"description": "A type carrying one of (i) a successful `T` (ii) a disappointment `EC` (iii) a failure `EP` (iv) both a disappointment `EC` and a failure `EP`, with `NoValuePolicy` specifying what to do if one tries to read state which isn&#39;t there.",
	"content": " A type carrying one of (i) a successful T (ii) a disappointment EC (iii) a failure EP (iv) both a disappointment EC and a failure EP, with NoValuePolicy specifying what to do if one tries to read state which isn\u0026rsquo;t there, and enabling injection of hooks to trap when lifecycle events occur. Any one, two, or all of T, EC and EP can be void to indicate no value for that state is present. Detectable using is_basic_outcome\u0026lt;T\u0026gt; .\nRequires: Concept requirements if C++ 20, else static asserted:\n That trait type_can_be_used_in_basic_result\u0026lt;R\u0026gt; is true for T, EC and EP. That either EC is void or DefaultConstructible (Outcome v2.1 and earlier only). That either EP is void or DefaultConstructible.  Namespace: OUTCOME_V2_NAMESPACE\nHeader: \u0026lt;outcome/basic_outcome.hpp\u0026gt;\nInclusions: The very lightest weight of C and C++ header files:\n \u0026lt;cstdint\u0026gt; \u0026lt;initializer_list\u0026gt; \u0026lt;iosfwd\u0026gt; \u0026lt;new\u0026gt; \u0026lt;type_traits\u0026gt; If OUTCOME_USE_STD_IN_PLACE_TYPE is 1, \u0026lt;utility\u0026gt; (defaults to 1 for C++ 17 or later only) If C++ exceptions disabled and OUTCOME_DISABLE_EXECINFO undefined only (used to print stack backtraces on \u0026ldquo;exception throw\u0026rdquo;):  \u0026lt;sal.h\u0026gt; (Windows only) \u0026lt;stddef.h\u0026gt; (Windows only) \u0026lt;string.h\u0026gt; (Windows only) \u0026lt;execinfo.h\u0026gt; (POSIX only)  \u0026lt;cstdio\u0026gt; \u0026lt;cstdlib\u0026gt; \u0026lt;cassert\u0026gt;  This very light weight set of inclusion dependencies makes basic outcome suitable for use in global header files of very large C++ codebases.\nDesign rationale basic_outcome extends basic_result\u0026lt;T, E, NoValuePolicy\u0026gt; with a third state to transport, conventionally (but not necessarily) some sort of \u0026ldquo;abort\u0026rdquo; or \u0026ldquo;exceptional\u0026rdquo; state which a function can return to indicate that not only did the operation fail, but it did so catastrophically i.e. please abort any attempt to retry the operation.\nA perfect alternative is to throw a C++ exception for the abort code path, and indeed most programs ought to do exactly that instead of using basic_outcome. However there are a number of use cases where choosing basic_outcome shines:\n Where C++ exceptions or RTTI is not available, but the ability to fail catastrophically without terminating the program is important. Where deterministic behaviour is required even in the catastrophic failure situation. In unit test suites of code using Outcome it is extremely convenient to accumulate test failures into a basic_outcome for later reporting. A similar convenience applies to RPC situations, where C++ exception throws need to be accumulated for reporting back to the initiating endpoint. Where a function is \u0026ldquo;dual use deterministic\u0026rdquo; i.e. it can be used deterministically, in which case one switches control flow based on .error(), or it can be used non-deterministically by throwing an exception perhaps carrying a custom payload.  Public member type aliases  value_type is T. error_type is EC. exception_type is EP. no_value_policy_type is NoValuePolicy. value_type_if_enabled is T if construction from T is available, else it is a usefully named unusable internal type. error_type_if_enabled is EC if construction from EC is available, else it is a usefully named unusable internal type. exception_type_if_enabled is EP if construction from EP is available, else it is a usefully named unusable internal type. rebind\u0026lt;A, B = EC, C = EP, D = NoValuePolicy\u0026gt; is basic_outcome\u0026lt;A, B, C, D\u0026gt;.  Protected member predicate booleans  predicate::constructors_enabled is constexpr boolean true if:\n Decayed value_type and decayed error_type are not the same type, or both are void. Decayed value_type and decayed exception_type are not the same type, or both are void. Decayed error_type and decayed exception_type are not the same type, or both are void.  predicate::implicit_constructors_enabled is constexpr boolean true if:\n predicate::constructors_enabled is true. Trait is_error_type\u0026lt;E\u0026gt; is not true for both decayed value_type and decayed error_type at the same time. value_type is not implicitly constructible from error_type and error_type is not implicitly constructible from value_type.\nOR\ntrait is_error_type\u0026lt;E\u0026gt; is true for decayed error_type and error_type is not implicitly constructible from value_type and value_type is an integral type. value_type is not implicitly constructible from exception_type. error_type is not implicitly constructible from exception_type. exception_type is not implicitly constructible from value_type. exception_type is not implicitly constructible from error_type.  predicate::enable_value_converting_constructor\u0026lt;A\u0026gt; is constexpr boolean true if:\n predicate::constructors_enabled is true. Decayed A is not this basic_outcome type. predicate::implicit_constructors_enabled is true. Decayed A is not an in_place_type_t. Trait is_error_type_enum\u0026lt;E, Enum\u0026gt; is false for error_type and decayed A. value_type is implicitly constructible from A and error_type is not implicitly constructible from A.\nOR\nvalue_type is the exact same type as decayed A and value_type is implicitly constructible from A. exception_type is not implicitly constructible from A.  predicate::enable_error_converting_constructor\u0026lt;A\u0026gt; is constexpr boolean true if:\n predicate::constructors_enabled is true. Decayed A is not this basic_outcome type. predicate::implicit_constructors_enabled is true. Decayed A is not an in_place_type_t. Trait is_error_type_enum\u0026lt;E, Enum\u0026gt; is false for error_type and decayed A. value_type is not implicitly constructible from A and error_type is implicitly constructible from A.\nOR\nerror_type is the exact same type as decayed A and error_type is implicitly constructible from A. exception_type is not implicitly constructible from A.  predicate::enable_error_condition_converting_constructor\u0026lt;ErrorCondEnum\u0026gt; is constexpr boolean true if:\n predicate::constructors_enabled is true. Decayed ErrorCondEnum is not this basic_outcome type. Decayed ErrorCondEnum is not an in_place_type_t. Trait is_error_type_enum\u0026lt;E, Enum\u0026gt; is true for error_type and decayed ErrorCondEnum. exception_type is not implicitly constructible from ErrorCondEnum.  predicate::enable_exception_converting_constructor\u0026lt;A\u0026gt; is constexpr boolean true if:\n predicate::constructors_enabled is true. Decayed A is not this basic_outcome type. predicate::implicit_constructors_enabled is true. Decayed A is not an in_place_type_t. value_type is not implicitly constructible from A. error_type is not implicitly constructible from A. exception_type is implicitly constructible from A.  predicate::enable_error_exception_converting_constructor\u0026lt;A, B\u0026gt; is constexpr boolean true if:\n predicate::constructors_enabled is true. Decayed A is not this basic_outcome type. predicate::implicit_constructors_enabled is true. Decayed A is not an in_place_type_t. value_type is not implicitly constructible from A. error_type is implicitly constructible from A. value_type is not implicitly constructible from B. exception_type is implicitly constructible from B.  predicate::enable_compatible_conversion\u0026lt;A, B, C, D\u0026gt; is constexpr boolean true if:\n predicate::constructors_enabled is true. basic_outcome\u0026lt;A, B, C, D\u0026gt; is not this basic_outcome type. A is void OR value_type is explicitly constructible from A. B is void OR error_type is explicitly constructible from B. C is void OR exception_type is explicitly constructible from C.  predicate::enable_make_error_code_compatible_conversion\u0026lt;A, B, C, D\u0026gt; is constexpr boolean true if:\n predicate::constructors_enabled is true. basic_outcome\u0026lt;A, B, C, D\u0026gt; is not this basic_outcome type. Trait is_error_code_available\u0026lt;T\u0026gt; is true for decayed error_type. predicate::enable_compatible_conversion\u0026lt;A, B, C, D\u0026gt; is not true. A is void OR value_type is explicitly constructible from A. error_type is explicitly constructible from make_error_code(B). C is void OR exception_type is explicitly constructible from C.  predicate::enable_inplace_value_constructor\u0026lt;Args...\u0026gt; is constexpr boolean true if:\n predicate::constructors_enabled is true. value_type is void OR value_type is explicitly constructible from Args....  predicate::enable_inplace_error_constructor\u0026lt;Args...\u0026gt; is constexpr boolean true if:\n predicate::constructors_enabled is true. error_type is void OR error_type is explicitly constructible from Args....  predicate::enable_inplace_exception_constructor\u0026lt;Args...\u0026gt; is constexpr boolean true if:\n predicate::constructors_enabled is true. exception_type is void OR exception_type is explicitly constructible from Args....  predicate::enable_inplace_value_error_exception_constructor\u0026lt;Args...\u0026gt; is constexpr boolean true if:\n predicate::constructors_enabled is true. predicate::implicit_constructors_enabled is true. Exactly one of value_type is explicitly constructible from Args..., or error_type is explicitly constructible from Args..., or exception_type is explicitly constructible from Args....   Summary of standard requirements provided  DefaultConstructible, always deleted to force user to choose valued or errored or excepted for every outcome instanced. MoveConstructible, if all of value_type, error_type and exception_type implement move constructors. CopyConstructible, if all of value_type, error_type and exception_type implement copy constructors. MoveAssignable, if all of value_type, error_type and exception_type implement move constructors and move assignment. CopyAssignable, if all of value_type, error_type and exception_type implement copy constructors and copy assignment. Destructible. Swappable, with the strong rather than weak guarantee. See void swap(basic_outcome \u0026amp;) for more information. TriviallyCopyable, if all of value_type, error_type and exception_type are trivially copyable. TrivialType, if all of value_type, error_type and exception_type are trivial types. LiteralType, if all of value_type, error_type and exception_type are literal types. StandardLayoutType. It is implementation defined if basic_outcome can be used by C. However all of the three major compilers MSVC, GCC and clang implement C layout of basic_outcome as follows:\nstruct outcome_layout { struct trivially_copyable_result_layout { union { value_type value; error_type error; }; unsigned int flags; }; exception_type exception; };  \u0026hellip; if both value_type and error_type are TriviallyCopyable, otherwise:\nstruct outcome_layout { struct non_trivially_copyable_result_layout { value_type value; unsigned int flags; error_type error; }; exception_type exception; };  If you choose standard layout value_type, error_type and exception_type, basic_outcome works fine from C on MSVC, GCC and clang.\n EqualityComparable, if all of value_type, error_type and exception_type implement equality comparisons with one another.\n LessThanComparable, not implemented due to availability of implicit conversions from value_type, error_type and exception_type, this can cause major surprise (i.e. hard to diagnose bugs), so we don\u0026rsquo;t implement these at all.\n Hash, not implemented as a generic implementation of a unique hash for non-valued items which are unequal would require a dependency on RTTI being enabled.\n  Thus basic_outcome meets the Regular concept if all of value_type, error_type and exception_type are Regular, except for the lack of a default constructor. Often where one needs a default constructor, wrapping basic_outcome into  std::optional\u0026lt;T\u0026gt; will suffice.\nPublic member functions Disabling constructors  basic_outcome(Args...) = delete Disabling catchall constructor used to give useful diagnostic error when trying to use non-inplace constructors when predicate::constructors_enabled is false.\n basic_outcome(X \u0026amp;\u0026amp;) = delete Disabling implicit constructor used to give useful diagnostic error when trying to use implicit constructors when predicate::implicit_constructors_enabled is false.\n Copy and move constructors and assignment, and destructor  basic_outcome() = delete The default constructor (disabled).\n basic_outcome(basic_outcome \u0026amp;\u0026amp;) Move constructor. Constexpr, triviality and noexcept propagating.\n basic_outcome(const basic_outcome \u0026amp;) Copy constructor. Constexpr, triviality and noexcept propagating.\n basic_outcome \u0026amp;operator=(basic_outcome \u0026amp;\u0026amp;) Move assignment. Constexpr, triviality and noexcept propagating.\n basic_outcome \u0026amp;operator=(const basic_outcome \u0026amp;) Copy assignment. Constexpr, triviality and noexcept propagating.\n ~basic_outcome() Destructor. Constexpr, triviality and noexcept propagating.\n Converting constructors  basic_outcome(R \u0026amp;\u0026amp;) Implicit value_type constructor. Available if predicate::enable_value_converting_constructor\u0026lt;R\u0026gt; is true. Constexpr, triviality and noexcept propagating.\n basic_outcome(S \u0026amp;\u0026amp;) Implicit error_type constructor. Available if predicate::enable_error_converting_constructor\u0026lt;S\u0026gt; is true. Constexpr, triviality and noexcept propagating.\n basic_outcome(ErrorCondEnum \u0026amp;\u0026amp;) Implicit error_type from ErrorCondEnum constructor. Available if predicate::enable_error_condition_converting_constructor\u0026lt;ErrorCondEnum\u0026gt; is true. Constexpr, triviality and noexcept propagating.\n basic_outcome(P \u0026amp;\u0026amp;) Implicit exception_type constructor. Available if predicate::enable_exception_converting_constructor\u0026lt;P\u0026gt; is true. Constexpr, triviality and noexcept propagating.\n basic_outcome(S \u0026amp;\u0026amp;, P \u0026amp;\u0026amp;) Implicit error_type + exception_type constructor. Available if predicate::enable_error_exception_converting_constructor\u0026lt;S, P\u0026gt; is true. Constexpr, triviality and noexcept propagating.\n explicit basic_outcome(concepts::value_or_error\u0026lt;T, E\u0026gt; \u0026amp;\u0026amp;) Explicit converting constructor from concepts::value_or_error\u0026lt;T, E\u0026gt; concept matching types. Available if convert::value_or_error\u0026lt;\u0026gt; permits it. Constexpr, triviality and noexcept propagating.\n explicit basic_outcome(const basic_outcome\u0026lt;A, B, C, D\u0026gt; \u0026amp;) Explicit converting copy constructor from compatible basic_outcome. Available if predicate::enable_compatible_conversion\u0026lt;A, B, C, D\u0026gt; is true. Constexpr, triviality and noexcept propagating.\n explicit basic_outcome(basic_outcome\u0026lt;A, B, C, D\u0026gt; \u0026amp;\u0026amp;) Explicit converting move constructor from compatible basic_outcome. Available if predicate::enable_compatible_conversion\u0026lt;A, B, C, D\u0026gt; is true. Constexpr, triviality and noexcept propagating.\n explicit basic_outcome(const basic_result\u0026lt;A, B, C\u0026gt; \u0026amp;) Explicit converting copy constructor from compatible basic_result. Available if predicate::enable_compatible_conversion\u0026lt;A, B, void, C\u0026gt; is true. Constexpr, triviality and noexcept propagating.\n explicit basic_outcome(basic_result\u0026lt;A, B, C\u0026gt; \u0026amp;\u0026amp;) Explicit converting move constructor from compatible basic_result. Available if predicate::enable_compatible_conversion\u0026lt;A, B, void, C\u0026gt; is true. Constexpr, triviality and noexcept propagating.\n explicit basic_outcome(const basic_result\u0026lt;A, B, C\u0026gt; \u0026amp;) Explicit converting copy constructor from compatible basic_result. Available if predicate::enable_make_error_code_compatible_conversion\u0026lt;A, B, void, C\u0026gt; is true. Constexpr, triviality and noexcept propagating.\n explicit basic_outcome(basic_result\u0026lt;A, B, C\u0026gt; \u0026amp;\u0026amp;) Explicit converting move constructor from compatible basic_result. Available if predicate::enable_make_error_code_compatible_conversion\u0026lt;A, B, void, C\u0026gt; is true. Constexpr, triviality and noexcept propagating.\n Inplace constructors  explicit basic_outcome(in_place_type_t\u0026lt;value_type_if_enabled\u0026gt;, Args ...) Explicit inplace value constructor. Available if predicate::enable_inplace_value_constructor\u0026lt;Args ...\u0026gt; is true. Constexpr, triviality and noexcept propagating.\n explicit basic_outcome(in_place_type_t\u0026lt;value_type_if_enabled\u0026gt;, std::initializer_list\u0026lt;U\u0026gt;, Args ...) Explicit inplace value constructor. Available if predicate::enable_inplace_value_constructor\u0026lt;std::initializer_list\u0026lt;U\u0026gt;, Args ...\u0026gt; is true. Constexpr, triviality and noexcept propagating.\n explicit basic_outcome(in_place_type_t\u0026lt;error_type_if_enabled\u0026gt;, Args ...) Explicit inplace error constructor. Available if predicate::enable_inplace_error_constructor\u0026lt;Args ...\u0026gt; is true. Constexpr, triviality and noexcept propagating.\n explicit basic_outcome(in_place_type_t\u0026lt;error_type_if_enabled\u0026gt;, std::initializer_list\u0026lt;U\u0026gt;, Args ...) Explicit inplace error constructor. Available if predicate::enable_inplace_error_constructor\u0026lt;std::initializer_list\u0026lt;U\u0026gt;, Args ...\u0026gt; is true. Constexpr, triviality and noexcept propagating.\n explicit basic_outcome(in_place_type_t\u0026lt;exception_type_if_enabled\u0026gt;, Args ...) Explicit inplace exception constructor. Available if predicate::enable_inplace_exception_constructor\u0026lt;Args ...\u0026gt; is true. Constexpr, triviality and noexcept propagating.\n explicit basic_outcome(in_place_type_t\u0026lt;exception_type_if_enabled\u0026gt;, std::initializer_list\u0026lt;U\u0026gt;, Args ...) Explicit inplace exception constructor. Available if predicate::enable_inplace_exception_constructor\u0026lt;std::initializer_list\u0026lt;U\u0026gt;, Args ...\u0026gt; is true. Constexpr, triviality and noexcept propagating.\n basic_outcome(A1 \u0026amp;\u0026amp;, A2 \u0026amp;\u0026amp;, Args ...) Implicit inplace value or error or exception constructor. Available if predicate::enable_inplace_value_error_exception_constructor\u0026lt;A1, A2, Args ...\u0026gt; is true. Constexpr, triviality and noexcept propagating.\n Tagged constructors  basic_outcome(const success_type\u0026lt;T\u0026gt; \u0026amp;) Implicit value-from-success-type-sugar copy constructor. Available if predicate::enable_compatible_conversion\u0026lt;T, void, void\u0026gt; is true, or T is void. Constexpr, triviality and noexcept propagating.\n basic_outcome(success_type\u0026lt;T\u0026gt; \u0026amp;\u0026amp;) Implicit value-from-success-type-sugar move constructor. Available if predicate::enable_compatible_conversion\u0026lt;T, void, void\u0026gt; is true, or T is void. Constexpr, triviality and noexcept propagating.\n basic_outcome(const failure_type\u0026lt;EC\u0026gt; \u0026amp;) Implicit error-from-failure-type-sugar copy constructor. Available if predicate::enable_compatible_conversion\u0026lt;void, EC, void, void\u0026gt; is true. Constexpr, triviality and noexcept propagating.\n basic_outcome(failure_type\u0026lt;EC\u0026gt; \u0026amp;\u0026amp;) Implicit error-from-failure-type-sugar move constructor. Available if predicate::enable_compatible_conversion\u0026lt;void, EC, void, void\u0026gt; is true. Constexpr, triviality and noexcept propagating.\n basic_outcome(const failure_type\u0026lt;EC\u0026gt; \u0026amp;) Implicit error-from-failure-type-sugar copy constructor. Available if predicate::enable_make_error_code_compatible_conversion\u0026lt;void, EC, void, void\u0026gt; is true. Constexpr, triviality and noexcept propagating.\n basic_outcome(failure_type\u0026lt;EC\u0026gt; \u0026amp;\u0026amp;) Implicit error-from-failure-type-sugar move constructor. Available if predicate::enable_make_error_code_compatible_conversion\u0026lt;void, EC, void, void\u0026gt; is true. Constexpr, triviality and noexcept propagating.\n basic_outcome(const failure_type\u0026lt;EP\u0026gt; \u0026amp;) Implicit exception-from-failure-type-sugar copy constructor. Available if predicate::enable_compatible_conversion\u0026lt;void, void, EP, void\u0026gt; is true. Constexpr, triviality and noexcept propagating.\n basic_outcome(failure_type\u0026lt;EP\u0026gt; \u0026amp;\u0026amp;) Implicit exception-from-failure-type-sugar move constructor. Available if predicate::enable_compatible_conversion\u0026lt;void, void, EP, void\u0026gt; is true. Constexpr, triviality and noexcept propagating.\n basic_outcome(const failure_type\u0026lt;EC, EP\u0026gt; \u0026amp;) Implicit error-and-exception-from-failure-type-sugar copy constructor. Available if predicate::enable_compatible_conversion\u0026lt;void, EC, EP, void\u0026gt; is true. Constexpr, triviality and noexcept propagating.\n basic_outcome(failure_type\u0026lt;EC, EP\u0026gt; \u0026amp;\u0026amp;) Implicit error-and-exception-from-failure-type-sugar move constructor. Available if predicate::enable_compatible_conversion\u0026lt;void, EC, EP, void\u0026gt; is true. Constexpr, triviality and noexcept propagating.\n Observers  explicit operator bool() const noexcept Returns true if a value is present. Constexpr, never throws.\n bool has_value() const noexcept Returns true if a value is present. Constexpr, never throws.\n bool has_error() const noexcept Returns true if an error is present. Constexpr, never throws.\n bool has_exception() const noexcept Returns true if an exception is present. Constexpr, never throws.\n bool has_failure() const noexcept Returns true if there is either an error or an exception. Constexpr, never throws.\n value_type \u0026amp;assume_value() \u0026amp; noexcept Narrow contract lvalue reference observer of any value present. Constexpr propagating, never throws.\n const value_type \u0026amp;assume_value() const \u0026amp; noexcept Narrow contract const lvalue reference observer of any value present. Constexpr propagating, never throws.\n value_type \u0026amp;\u0026amp;assume_value() \u0026amp;\u0026amp; noexcept Narrow contract rvalue reference observer of any value present. Constexpr propagating, never throws.\n const value_type \u0026amp;\u0026amp;assume_value() const \u0026amp;\u0026amp; noexcept Narrow contract const rvalue reference observer of any value present. Constexpr propagating, never throws.\n value_type \u0026amp;value() \u0026amp; Wide contract lvalue reference observer of any value present. Constexpr propagating.\n const value_type \u0026amp;value() const \u0026amp; Wide contract const lvalue reference observer of any value present. Constexpr propagating.\n value_type \u0026amp;\u0026amp;value() \u0026amp;\u0026amp; Wide contract rvalue reference observer of any value present. Constexpr propagating.\n const value_type \u0026amp;\u0026amp;value() const \u0026amp;\u0026amp; Wide contract const rvalue reference observer of any value present. Constexpr propagating.\n error_type \u0026amp;assume_error() \u0026amp; noexcept Narrow contract lvalue reference observer of the stored error. Constexpr propagating, never throws.\n const error_type \u0026amp;assume_error() const \u0026amp; noexcept Narrow contract const lvalue reference observer of the stored error. Constexpr propagating, never throws.\n error_type \u0026amp;\u0026amp;assume_error() \u0026amp;\u0026amp; noexcept Narrow contract rvalue reference observer of the stored error. Constexpr propagating, never throws.\n const error_type \u0026amp;\u0026amp;assume_error() const \u0026amp;\u0026amp; noexcept Narrow contract const rvalue reference observer of the stored error. Constexpr propagating, never throws.\n error_type \u0026amp;error() \u0026amp; Wide contract lvalue reference observer of the stored error. Constexpr propagating.\n const error_type \u0026amp;error() const \u0026amp; Wide contract const lvalue reference observer of the stored error. Constexpr propagating.\n error_type \u0026amp;\u0026amp;error() \u0026amp;\u0026amp; Wide contract rvalue reference observer of the stored error. Constexpr propagating.\n const error_type \u0026amp;\u0026amp;error() const \u0026amp;\u0026amp; Wide contract const rvalue reference observer of the stored error. Constexpr propagating.\n exception_type \u0026amp;assume_exception() \u0026amp; noexcept Narrow contract lvalue reference observer of the stored exception. Constexpr propagating, never throws.\n const exception_type \u0026amp;assume_exception() const \u0026amp; noexcept Narrow contract const lvalue reference observer of the stored exception. Constexpr propagating, never throws.\n const exception_type \u0026amp;\u0026amp;assume_exception() const \u0026amp;\u0026amp; noexcept Narrow contract const rvalue reference observer of the stored exception. Constexpr propagating, never throws.\n exception_type \u0026amp;\u0026amp;assume_exception() \u0026amp;\u0026amp; noexcept Narrow contract rvalue reference observer of the stored exception. Constexpr propagating, never throws.\n exception_type \u0026amp;exception() \u0026amp; Wide contract lvalue reference observer of the stored exception. Constexpr propagating.\n const exception_type \u0026amp;exception() const \u0026amp; Wide contract const lvalue reference observer of the stored exception. Constexpr propagating.\n exception_type \u0026amp;\u0026amp;exception() \u0026amp;\u0026amp; Wide contract rvalue reference observer of the stored exception. Constexpr propagating.\n const exception_type \u0026amp;\u0026amp;exception() const \u0026amp;\u0026amp; Wide contract const rvalue reference observer of the stored exception. Constexpr propagating.\n exception_type failure() const noexcept Synthesising observer of the stored exception or error. Available if the traits is_error_code_available\u0026lt;T\u0026gt; and is_exception_ptr_available\u0026lt;T\u0026gt; are both true. Never throws.\n failure_type\u0026lt;error_type, exception_type\u0026gt; as_failure() const \u0026amp; Return the output from free function failure() containing a copy of any errored and/or excepted state.\n Modifiers  void swap(basic_outcome \u0026amp;) Swap one basic_outcome with another, with the strong guarantee. Noexcept propagating.\n failure_type\u0026lt;error_type, exception_type\u0026gt; as_failure() \u0026amp;\u0026amp; Return the output from free function failure() containing a move of any errored and/or excepted state.\n Comparisons See above for why LessThanComparable is not implemented.\n bool operator==(const basic_result\u0026lt;A, B, C\u0026gt; \u0026amp;) const Returns true if this outcome compares equal to the other result. Constexpr and noexcept propagating.\n bool operator==(const basic_outcome\u0026lt;A, B, C, D\u0026gt; \u0026amp;) const Returns true if this outcome compares equal to the other outcome. Constexpr and noexcept propagating.\n bool operator==(const success_type\u0026lt;A\u0026gt; \u0026amp;) const Returns true if this result compares equal to the success type sugar. Constexpr and noexcept propagating.\n bool operator==(const failure_type\u0026lt;A, B\u0026gt; \u0026amp;) const Returns true if this outcome compares equal to the failure type sugar. Constexpr and noexcept propagating.\n bool operator!=(const basic_result\u0026lt;A, B, C\u0026gt; \u0026amp;) const Returns true if this outcome does not compare equal to the other result. Constexpr and noexcept propagating.\n bool operator!=(const basic_outcome\u0026lt;A, B, C, D\u0026gt; \u0026amp;) const Returns true if this outcome does not compare equal to the other outcome. Constexpr and noexcept propagating.\n bool operator!=(const success_type\u0026lt;A\u0026gt; \u0026amp;) const Returns true if this outcome does not compare equal to the success type sugar. Constexpr and noexcept propagating.\n bool operator!=(const failure_type\u0026lt;A, B\u0026gt; \u0026amp;) const Returns true if this outcome does not compare equal to the failure type sugar. Constexpr and noexcept propagating.\n "
},
{
	"uri": "https://ned14.github.io/outcome/reference/concepts/basic_outcome/",
	"title": "`basic_outcome&lt;T&gt;`",
	"tags": [],
	"description": "A boolean concept matching types which are convertible to a `basic_outcome&lt;T, EC, EP, NoValuePolicy&gt;`.",
	"content": "If on C++ 20 or the Concepts TS is enabled, a boolean concept matching types which have value_type, error_type and no_value_policy_type member typedefs; that the type is convertible to basic_result\u0026lt;value_type, error_type, no_value_policy_type\u0026gt;; that basic_result\u0026lt;value_type, error_type, no_value_policy_type\u0026gt; is a base of the type.\nIf without Concepts, a static constexpr bool which is true for types matching the same requirements, using a SFINAE based emulation.\nThis concept matches any type which provides the same typedefs as a basic_result\u0026lt;T, E, NoValuePolicy\u0026gt; , has that basic_result as a base class, and is implicitly convertible to basic_result. Whilst not guaranteed, it is very likely that the type is a basic_result, or inherits publicly from a basic_result. If you want something which matches any value-or-error type, consider value_or_error\u0026lt;T\u0026gt; . If you want something which exactly matches basic_outcome, use is_basic_outcome\u0026lt;T\u0026gt; .\nNamespace: OUTCOME_V2_NAMESPACE::concepts\nHeader: \u0026lt;outcome/basic_result.hpp\u0026gt;\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/basic_result/",
	"title": "`basic_result&lt;T, E, NoValuePolicy&gt;`",
	"tags": [],
	"description": "A sum type carrying either a successful `T`, or a disappointment `E`, with `NoValuePolicy` specifying what to do if one tries to read state which isn&#39;t there.",
	"content": " A sum type carrying either a T or an E, with NoValuePolicy specifying what to do if one tries to read state which isn\u0026rsquo;t there, and enabling injection of hooks to trap when lifecycle events occur. Either or both of T and E can be void to indicate no value for that state is present. Note that E = void makes basic result into effectively an optional\u0026lt;T\u0026gt;, but with NoValuePolicy configurable behaviour. Detectable using is_basic_result\u0026lt;T\u0026gt; .\nRequires: Concept requirements if C++ 20, else static asserted:\n That trait type_can_be_used_in_basic_result\u0026lt;R\u0026gt; is true for both T and E. That either E is void or DefaultConstructible (Outcome v2.1 and earlier only).  Namespace: OUTCOME_V2_NAMESPACE\nHeader: \u0026lt;outcome/basic_result.hpp\u0026gt;\nInclusions: The very lightest weight of C and C++ header files:\n \u0026lt;cstdint\u0026gt; \u0026lt;initializer_list\u0026gt; \u0026lt;iosfwd\u0026gt; \u0026lt;new\u0026gt; \u0026lt;type_traits\u0026gt; If OUTCOME_USE_STD_IN_PLACE_TYPE is 1, \u0026lt;utility\u0026gt; (defaults to 1 for C++ 17 or later only) If C++ exceptions disabled and OUTCOME_DISABLE_EXECINFO undefined only (used to print stack backtraces on \u0026ldquo;exception throw\u0026rdquo;):  \u0026lt;sal.h\u0026gt; (Windows only) \u0026lt;stddef.h\u0026gt; (Windows only) \u0026lt;string.h\u0026gt; (Windows only) \u0026lt;execinfo.h\u0026gt; (POSIX only)  \u0026lt;cstdio\u0026gt; \u0026lt;cstdlib\u0026gt; \u0026lt;cassert\u0026gt;  This very light weight set of inclusion dependencies makes basic result suitable for use in global header files of very large C++ codebases.\nDesign rationale The basic result type is the main workhorse type of the Outcome library, providing a simple sum type with optional values representing success or disappointment. Unlike  P0323 std::expected\u0026lt;T, E\u0026gt; , Outcome\u0026rsquo;s result type is designed specifically for convenience when implementing failure handling across very large codebases, and it has a number of API differences to facilitate that.\nThe first major design difference is that basic result models its constructor design on  std::variant\u0026lt;...\u0026gt; , rather than modelling  std::optional\u0026lt;T\u0026gt; \u0026rsquo;s constructor design like std::expected\u0026lt;T, E\u0026gt; does. This means that basic result will implicitly construct either a T or an E if doing so is unambiguous, same as variant does. Where implicit construction is ambiguous, the implicit constructors disable and a T or E can be specified via in_place_type_t\u0026lt;T\u0026gt; , or via success_type\u0026lt;T\u0026gt; or failure_type\u0026lt;T\u0026gt; . We implement a subset of variant\u0026rsquo;s constructors for improved compile time impact, so the implicit and explicit constructor design is split into fixed subsets to reduce SFINAE execution.\nThe second major design difference is that union storage is ONLY used when both T and E are trivially copyable or void, otherwise struct storage is used. This is usually not a problem, as it is assumed that sizeof(E) will be small for failure handling. The choice to only use union storage for trivially copyable types only very considerably reduces load on the compiler, and substantially improves compile times in very large C++ 14 codebases, because copies and moves do not need to jump through complex ceremony in order to implement the never-empty guarantees which would be required in a union storage based implementation (C++ 17 onwards does far fewer copy and move constructor instantiations, but it all adds up \u0026ndash; work avoided is always the fastest).\nPublic member type aliases  value_type is T. error_type is E. no_value_policy_type is NoValuePolicy. value_type_if_enabled is T if construction from T is available, else it is a usefully named unusable internal type. error_type_if_enabled is E if construction from E is available, else it is a usefully named unusable internal type. rebind\u0026lt;A, B = E, C = NoValuePolicy\u0026gt; is basic_result\u0026lt;A, B, C\u0026gt;.  Protected member predicate booleans  predicate::constructors_enabled is constexpr boolean true if decayed value_type and decayed error_type are not the same type.\n predicate::implicit_constructors_enabled is constexpr boolean true if:\n predicate::constructors_enabled is true. Trait is_error_type\u0026lt;E\u0026gt; is not true for both decayed value_type and decayed error_type at the same time. value_type is not implicitly constructible from error_type and error_type is not implicitly constructible from value_type.\nOR\ntrait is_error_type\u0026lt;E\u0026gt; is true for decayed error_type and error_type is not implicitly constructible from value_type and value_type is an integral type.  predicate::enable_value_converting_constructor\u0026lt;A\u0026gt; is constexpr boolean true if:\n predicate::constructors_enabled is true. Decayed A is not this basic_result type. predicate::implicit_constructors_enabled is true. Decayed A is not an in_place_type_t. Trait is_error_type_enum\u0026lt;E, Enum\u0026gt; is false for error_type and decayed A. value_type is implicitly constructible from A and error_type is not implicitly constructible from A.\nOR\nvalue_type is the exact same type as decayed A and value_type is implicitly constructible from A.  predicate::enable_error_converting_constructor\u0026lt;A\u0026gt; is constexpr boolean true if:\n predicate::constructors_enabled is true. Decayed A is not this basic_result type. predicate::implicit_constructors_enabled is true. Decayed A is not an in_place_type_t. Trait is_error_type_enum\u0026lt;E, Enum\u0026gt; is false for error_type and decayed A. value_type is not implicitly constructible from A and error_type is implicitly constructible from A.\nOR\nerror_type is the exact same type as decayed A and error_type is implicitly constructible from A.  predicate::enable_error_condition_converting_constructor\u0026lt;ErrorCondEnum\u0026gt; is constexpr boolean true if:\n predicate::constructors_enabled is true. Decayed ErrorCondEnum is not this basic_result type. Decayed ErrorCondEnum is not an in_place_type_t. Trait is_error_type_enum\u0026lt;E, Enum\u0026gt; is true for error_type and decayed ErrorCondEnum.  predicate::enable_compatible_conversion\u0026lt;A, B, C\u0026gt; is constexpr boolean true if:\n predicate::constructors_enabled is true. basic_result\u0026lt;A, B, C\u0026gt; is not this basic_result type. A is void OR value_type is explicitly constructible from A. B is void OR error_type is explicitly constructible from B.  predicate::enable_make_error_code_compatible_conversion\u0026lt;A, B, C\u0026gt; is constexpr boolean true if:\n predicate::constructors_enabled is true. basic_result\u0026lt;A, B, C\u0026gt; is not this basic_result type. Trait is_error_code_available\u0026lt;T\u0026gt; is true for decayed error_type. predicate::enable_compatible_conversion\u0026lt;A, B, C\u0026gt; is not true. A is void OR value_type is explicitly constructible from A. error_type is explicitly constructible from make_error_code(B).  predicate::enable_make_exception_ptr_compatible_conversion\u0026lt;A, B, C\u0026gt; is constexpr boolean true if:\n predicate::constructors_enabled is true. basic_result\u0026lt;A, B, C\u0026gt; is not this basic_result type. Trait is_exception_ptr_available\u0026lt;T\u0026gt; is true for decayed error_type. predicate::enable_compatible_conversion\u0026lt;A, B, C\u0026gt; is not true. A is void OR value_type is explicitly constructible from A. error_type is explicitly constructible from make_exception_ptr(B).  predicate::enable_inplace_value_constructor\u0026lt;Args...\u0026gt; is constexpr boolean true if:\n predicate::constructors_enabled is true. value_type is void OR value_type is explicitly constructible from Args....  predicate::enable_inplace_error_constructor\u0026lt;Args...\u0026gt; is constexpr boolean true if:\n predicate::constructors_enabled is true. error_type is void OR error_type is explicitly constructible from Args....  predicate::enable_inplace_value_error_constructor\u0026lt;Args...\u0026gt; is constexpr boolean true if:\n predicate::constructors_enabled is true. predicate::implicit_constructors_enabled is true. Either, but not both, of value_type is explicitly constructible from Args... or error_type is explicitly constructible from Args....   Summary of standard requirements provided  DefaultConstructible, always deleted to force user to choose valued or errored for every result instanced. MoveConstructible, if both value_type and error_type implement move constructors. CopyConstructible, if both value_type and error_type implement copy constructors. MoveAssignable, if both value_type and error_type implement move constructors and move assignment. CopyAssignable, if both value_type and error_type implement copy constructors and copy assignment. Destructible. Swappable, with the strong rather than weak guarantee. See void swap(basic_result \u0026amp;) for more information. TriviallyCopyable, if both value_type and error_type are trivially copyable. TrivialType, if both value_type and error_type are trivial types. LiteralType, if both value_type and error_type are literal types. StandardLayoutType, if both value_type and error_type are standard layout types. If so, layout of basic_result in C is guaranteed to be one of:\nstruct trivially_copyable_result_layout { union { value_type value; error_type error; }; unsigned int flags; };  \u0026hellip; if both value_type and error_type are TriviallyCopyable, otherwise:\nstruct non_trivially_copyable_result_layout { value_type value; unsigned int flags; error_type error; };  Obviously, all C compatible C++ types are TriviallyCopyable, so if you are passing non-trivially copyable types from C++ to C, you are doing undefined behaviour.\n EqualityComparable, if both value_type and error_type implement equality comparisons with one another.\n LessThanComparable, not implemented due to availability of implicit conversions from value_type and error_type, this can cause major surprise (i.e. hard to diagnose bugs), so we don\u0026rsquo;t implement these at all.\n Hash, not implemented as a generic implementation of a unique hash for non-valued items which are unequal would require a dependency on RTTI being enabled.\n  Thus basic_result meets the Regular concept if both value_type and error_type are Regular, except for the lack of a default constructor. Often where one needs a default constructor, wrapping basic_result into  std::optional\u0026lt;T\u0026gt; will suffice.\nPublic member functions Disabling constructors  basic_result(Args...) = delete Disabling catchall constructor used to give useful diagnostic error when trying to use non-inplace constructors when predicate::constructors_enabled is false.\n basic_result(X \u0026amp;\u0026amp;) = delete Disabling implicit constructor used to give useful diagnostic error when trying to use implicit constructors when predicate::implicit_constructors_enabled is false.\n Copy and move constructors and assignment, and destructor  basic_result() = delete The default constructor (disabled).\n basic_result(basic_result \u0026amp;\u0026amp;) Move constructor. Constexpr, triviality and noexcept propagating.\n basic_result(const basic_result \u0026amp;) Copy constructor. Constexpr, triviality and noexcept propagating.\n basic_result \u0026amp;operator=(basic_result \u0026amp;\u0026amp;) Move assignment. Constexpr, triviality and noexcept propagating.\n basic_result \u0026amp;operator=(const basic_result \u0026amp;) Copy assignment. Constexpr, triviality and noexcept propagating.\n ~basic_result() Destructor. Constexpr, triviality and noexcept propagating.\n Converting constructors  basic_result(R \u0026amp;\u0026amp;) Implicit value_type constructor. Available if predicate::enable_value_converting_constructor\u0026lt;R\u0026gt; is true. Constexpr, triviality and noexcept propagating.\n basic_result(S \u0026amp;\u0026amp;) Implicit error_type constructor. Available if predicate::enable_error_converting_constructor\u0026lt;S\u0026gt; is true. Constexpr, triviality and noexcept propagating.\n basic_result(ErrorCondEnum \u0026amp;\u0026amp;) Implicit error_type from ErrorCondEnum constructor. Available if predicate::enable_error_condition_converting_constructor\u0026lt;ErrorCondEnum\u0026gt; is true. Constexpr, triviality and noexcept propagating.\n explicit basic_result(concepts::value_or_error\u0026lt;T, E\u0026gt; \u0026amp;\u0026amp;) Explicit converting constructor from concepts::value_or_error\u0026lt;T, E\u0026gt; concept matching types. Available if convert::value_or_error\u0026lt;\u0026gt; permits it. Constexpr, triviality and noexcept propagating.\n explicit basic_result(const basic_result\u0026lt;R, S, P\u0026gt; \u0026amp;) Explicit converting copy constructor from compatible basic_result. Available if predicate::enable_compatible_conversion\u0026lt;R, S, P\u0026gt; is true. Constexpr, triviality and noexcept propagating.\n explicit basic_result(basic_result\u0026lt;R, S, P\u0026gt; \u0026amp;\u0026amp;) Explicit converting move constructor from compatible basic_result. Available if predicate::enable_compatible_conversion\u0026lt;R, S, P\u0026gt; is true. Constexpr, triviality and noexcept propagating.\n explicit basic_result(const basic_result\u0026lt;R, S, P\u0026gt; \u0026amp;) Explicit converting copy constructor from compatible basic_result. Available if predicate::enable_make_error_code_compatible_conversion\u0026lt;R, S, P\u0026gt; is true. Constexpr, triviality and noexcept propagating.\n explicit basic_result(basic_result\u0026lt;R, S, P\u0026gt; \u0026amp;\u0026amp;) Explicit converting move constructor from compatible basic_result. Available if predicate::enable_make_error_code_compatible_conversion\u0026lt;R, S, P\u0026gt; is true. Constexpr, triviality and noexcept propagating.\n explicit basic_result(const basic_result\u0026lt;R, S, P\u0026gt; \u0026amp;) Explicit converting copy constructor from compatible basic_result. Available if predicate::enable_make_exception_ptr_compatible_conversion\u0026lt;R, S, P\u0026gt; is true. Constexpr, triviality and noexcept propagating.\n explicit basic_result(basic_result\u0026lt;R, S, P\u0026gt; \u0026amp;\u0026amp;) Explicit converting move constructor from compatible basic_result. Available if predicate::enable_make_exception_ptr_compatible_conversion\u0026lt;R, S, P\u0026gt; is true. Constexpr, triviality and noexcept propagating.\n Inplace constructors  explicit basic_result(in_place_type_t\u0026lt;value_type_if_enabled\u0026gt;, Args ...) Explicit inplace value constructor. Available if predicate::enable_inplace_value_constructor\u0026lt;Args ...\u0026gt; is true. Constexpr, triviality and noexcept propagating.\n explicit basic_result(in_place_type_t\u0026lt;value_type_if_enabled\u0026gt;, std::initializer_list\u0026lt;U\u0026gt;, Args ...) Explicit inplace value constructor. Available if predicate::enable_inplace_value_constructor\u0026lt;std::initializer_list\u0026lt;U\u0026gt;, Args ...\u0026gt; is true. Constexpr, triviality and noexcept propagating.\n explicit basic_result(in_place_type_t\u0026lt;error_type_if_enabled\u0026gt;, Args ...) Explicit inplace error constructor. Available if predicate::enable_inplace_error_constructor\u0026lt;Args ...\u0026gt; is true. Constexpr, triviality and noexcept propagating.\n explicit basic_result(in_place_type_t\u0026lt;error_type_if_enabled\u0026gt;, std::initializer_list\u0026lt;U\u0026gt;, Args ...) Explicit inplace error constructor. Available if predicate::enable_inplace_error_constructor\u0026lt;std::initializer_list\u0026lt;U\u0026gt;, Args ...\u0026gt; is true. Constexpr, triviality and noexcept propagating.\n basic_result(A1 \u0026amp;\u0026amp;, A2 \u0026amp;\u0026amp;, Args ...) Implicit inplace value or error constructor. Available if predicate::enable_inplace_value_error_constructor\u0026lt;A1, A2, Args ...\u0026gt; is true. Constexpr, triviality and noexcept propagating.\n Tagged constructors  basic_result(const success_type\u0026lt;T\u0026gt; \u0026amp;) Implicit value-from-success-type-sugar copy constructor. Available if predicate::enable_compatible_conversion\u0026lt;T, void, void\u0026gt; is true, or T is void. Constexpr, triviality and noexcept propagating.\n basic_result(success_type\u0026lt;T\u0026gt; \u0026amp;\u0026amp;) Implicit value-from-success-type-sugar move constructor. Available if predicate::enable_compatible_conversion\u0026lt;T, void, void\u0026gt; is true, or T is void. Constexpr, triviality and noexcept propagating.\n basic_result(const failure_type\u0026lt;T\u0026gt; \u0026amp;) Implicit error-from-failure-type-sugar copy constructor. Available if predicate::enable_compatible_conversion\u0026lt;void, T, void\u0026gt; is true, or T is void. Constexpr, triviality and noexcept propagating.\n basic_result(failure_type\u0026lt;T\u0026gt; \u0026amp;\u0026amp;) Implicit error-from-failure-type-sugar move constructor. Available if predicate::enable_compatible_conversion\u0026lt;void, T, void\u0026gt; is true, or T is void. Constexpr, triviality and noexcept propagating.\n basic_result(const failure_type\u0026lt;T\u0026gt; \u0026amp;) Implicit error-from-failure-type-sugar copy constructor. Available if predicate::enable_make_error_code_compatible_conversion\u0026lt;void, T, void\u0026gt; is true, or T is void. Constexpr, triviality and noexcept propagating.\n basic_result(failure_type\u0026lt;T\u0026gt; \u0026amp;\u0026amp;) Implicit error-from-failure-type-sugar move constructor. Available if predicate::enable_make_error_code_compatible_conversion\u0026lt;void, T, void\u0026gt; is true, or T is void. Constexpr, triviality and noexcept propagating.\n basic_result(const failure_type\u0026lt;T\u0026gt; \u0026amp;) Implicit error-from-failure-type-sugar copy constructor. Available if predicate::enable_make_exception_ptr_compatible_conversion\u0026lt;void, T, void\u0026gt; is true, or T is void. Constexpr, triviality and noexcept propagating.\n basic_result(failure_type\u0026lt;T\u0026gt; \u0026amp;\u0026amp;) Implicit error-from-failure-type-sugar move constructor. Available if predicate::enable_make_exception_ptr_compatible_conversion\u0026lt;void, T, void\u0026gt; is true, or T is void. Constexpr, triviality and noexcept propagating.\n Observers  explicit operator bool() const noexcept Returns true if a value is present. Constexpr, never throws.\n bool has_value() const noexcept Returns true if a value is present. Constexpr, never throws.\n bool has_error() const noexcept Returns true if an error is present. Constexpr, never throws.\n bool has_exception() const noexcept Always returns false for basic_result. Constexpr, never throws.\n bool has_failure() const noexcept Returns true if there is either an error or an exception. Constexpr, never throws.\n bool has_lost_consistency() const noexcept Returns true if a preceding swap involving this object failed to preserve the strong guarantee. Constexpr, never throws.\n value_type \u0026amp;assume_value() \u0026amp; noexcept Narrow contract lvalue reference observer of any value present. Constexpr propagating, never throws.\n const value_type \u0026amp;assume_value() const \u0026amp; noexcept Narrow contract const lvalue reference observer of any value present. Constexpr propagating, never throws.\n value_type \u0026amp;\u0026amp;assume_value() \u0026amp;\u0026amp; noexcept Narrow contract rvalue reference observer of any value present. Constexpr propagating, never throws.\n const value_type \u0026amp;\u0026amp;assume_value() const \u0026amp;\u0026amp; noexcept Narrow contract const rvalue reference observer of any value present. Constexpr propagating, never throws.\n value_type \u0026amp;value() \u0026amp; Wide contract lvalue reference observer of any value present. Constexpr propagating.\n const value_type \u0026amp;value() const \u0026amp; Wide contract const lvalue reference observer of any value present. Constexpr propagating.\n value_type \u0026amp;\u0026amp;value() \u0026amp;\u0026amp; Wide contract rvalue reference observer of any value present. Constexpr propagating.\n const value_type \u0026amp;\u0026amp;value() const \u0026amp;\u0026amp; Wide contract const rvalue reference observer of any value present. Constexpr propagating.\n error_type \u0026amp;assume_error() \u0026amp; noexcept Narrow contract lvalue reference observer of the stored error. Constexpr propagating, never throws.\n const error_type \u0026amp;assume_error() const \u0026amp; noexcept Narrow contract const lvalue reference observer of the stored error. Constexpr propagating, never throws.\n error_type \u0026amp;\u0026amp;assume_error() \u0026amp;\u0026amp; noexcept Narrow contract rvalue reference observer of the stored error. Constexpr propagating, never throws.\n const error_type \u0026amp;\u0026amp;assume_error() const \u0026amp;\u0026amp; noexcept Narrow contract const rvalue reference observer of the stored error. Constexpr propagating, never throws.\n error_type \u0026amp;error() \u0026amp; Wide contract lvalue reference observer of the stored error. Constexpr propagating.\n const error_type \u0026amp;error() const \u0026amp; Wide contract const lvalue reference observer of the stored error. Constexpr propagating.\n error_type \u0026amp;\u0026amp;error() \u0026amp;\u0026amp; Wide contract rvalue reference observer of the stored error. Constexpr propagating.\n const error_type \u0026amp;\u0026amp;error() const \u0026amp;\u0026amp; Wide contract const rvalue reference observer of the stored error. Constexpr propagating.\n auto as_failure() const \u0026amp; Return the output from free function failure() containing a copy of any errored state.\n Modifiers  void swap(basic_result \u0026amp;) Swap one basic_result with another, with the strong guarantee. Noexcept propagating.\n auto as_failure() \u0026amp;\u0026amp; Return the output from free function failure() containing a move of any errored state.\n Comparisons See above for why LessThanComparable is not implemented.\n bool operator==(const basic_result\u0026lt;A, B, C\u0026gt; \u0026amp;) const Returns true if this result compares equal to the other result. Constexpr and noexcept propagating.\n bool operator==(const success_type\u0026lt;A\u0026gt; \u0026amp;) const Returns true if this result compares equal to the success type sugar. Constexpr and noexcept propagating.\n bool operator==(const failure_type\u0026lt;A, void\u0026gt; \u0026amp;) const Returns true if this result compares equal to the failure type sugar. Constexpr and noexcept propagating.\n bool operator!=(const basic_result\u0026lt;A, B, C\u0026gt; \u0026amp;) const Returns true if this result does not compare equal to the other result. Constexpr and noexcept propagating.\n bool operator!=(const success_type\u0026lt;A\u0026gt; \u0026amp;) const Returns true if this result does not compare equal to the success type sugar. Constexpr and noexcept propagating.\n bool operator!=(const failure_type\u0026lt;A, void\u0026gt; \u0026amp;) const Returns true if this result does not compare equal to the failure type sugar. Constexpr and noexcept propagating.\n "
},
{
	"uri": "https://ned14.github.io/outcome/reference/concepts/basic_result/",
	"title": "`basic_result&lt;T&gt;`",
	"tags": [],
	"description": "A boolean concept matching types which are convertible to a `basic_result&lt;T, E, NoValuePolicy&gt;`.",
	"content": "If on C++ 20 or the Concepts TS is enabled, a boolean concept matching types which have value_type, error_type and no_value_policy_type member typedefs; that the type is convertible to basic_result\u0026lt;value_type, error_type, no_value_policy_type\u0026gt;; that basic_result\u0026lt;value_type, error_type, no_value_policy_type\u0026gt; is a base of the type.\nIf without Concepts, a static constexpr bool which is true for types matching the same requirements, using a SFINAE based emulation.\nThis concept matches any type which provides the same typedefs as a basic_result\u0026lt;T, E, NoValuePolicy\u0026gt; , has that basic_result as a base class, and is implicitly convertible to basic_result. Whilst not guaranteed, it is very likely that the type is a basic_result, or inherits publicly from a basic_result. If you want something which matches any value-or-error type, consider value_or_error\u0026lt;T\u0026gt; . If you want something which exactly matches basic_result, use is_basic_result\u0026lt;T\u0026gt; .\nNamespace: OUTCOME_V2_NAMESPACE::concepts\nHeader: \u0026lt;outcome/basic_result.hpp\u0026gt;\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/functions/try_operation_has_value/",
	"title": "`bool try_operation_has_value(X)`",
	"tags": [],
	"description": "Default implementation of `try_operation_has_value(X)` ADL customisation point for `OUTCOME_TRY`.",
	"content": "This default implementation returns whatever the .has_value() member function returns.\nRequires: That the expression std::declval\u0026lt;T\u0026gt;().has_value() is a valid expression.\nNamespace: OUTCOME_V2_NAMESPACE\nHeader: \u0026lt;outcome/try.hpp\u0026gt;\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/aliases/boost_checked/",
	"title": "`boost_checked&lt;T, E = boost::system::error_code&gt;`",
	"tags": [],
	"description": "A type alias to a `basic_result` configured with `boost::system::error_code` and `policy::throw_bad_result_access&lt;EC&gt;`.",
	"content": "A type alias to a basic_result\u0026lt;T, E, NoValuePolicy\u0026gt; configured with boost::system::error_code and policy::throw_bad_result_access\u0026lt;EC\u0026gt; .\nThis type alias always references the boost edition of things, unlike checked\u0026lt;T, E = varies\u0026gt; which references either this alias or std_checked\u0026lt;T, E = std::error_code\u0026gt; .\nNamespace: OUTCOME_V2_NAMESPACE\nHeader: \u0026lt;outcome/boost_result.hpp\u0026gt;\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/aliases/boost_outcome/",
	"title": "`boost_outcome&lt;T, EC = boost::system::error_code, EP = boost::exception_ptr, NoValuePolicy = policy::default_policy&lt;T, EC, EP&gt;&gt;`",
	"tags": [],
	"description": "A type alias to a `basic_outcome` configured with `boost::system::error_code`, `boost::exception_ptr` and `policy::default_policy`.",
	"content": "A type alias to a basic_outcome\u0026lt;T, EC, EP, NoValuePolicy\u0026gt; configured with boost::system::error_code , boost::exception_ptr and policy::default_policy .\nThis type alias always references the std edition of things, unlike outcome\u0026lt;T, EC = varies, EP = varies, NoValuePolicy = policy::default_policy\u0026lt;T, EC, EP\u0026gt;\u0026gt; which references either this alias or std_outcome\u0026lt;T, EC = std::error_code, EP = std::exception_ptr, NoValuePolicy = policy::default_policy\u0026lt;T, EC, EP\u0026gt;\u0026gt; .\nNamespace: OUTCOME_V2_NAMESPACE\nHeader: \u0026lt;outcome/boost_outcome.hpp\u0026gt;\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/aliases/boost_result/",
	"title": "`boost_result&lt;T, E = boost::system::error_code, NoValuePolicy = policy::default_policy&lt;T, E, void&gt;&gt;`",
	"tags": [],
	"description": "A type alias to a `basic_result` configured with `boost::system::error_code` and `policy::default_policy`.",
	"content": "A type alias to a basic_result\u0026lt;T, E, NoValuePolicy\u0026gt; configured with boost::system::error_code and policy::default_policy .\nThis type alias always references the boost edition of things, unlike result\u0026lt;T, E = varies, NoValuePolicy = policy::default_policy\u0026lt;T, E, void\u0026gt;\u0026gt; which references either this alias or std_result\u0026lt;T, E = std::error_code, NoValuePolicy = policy::default_policy\u0026lt;T, E, void\u0026gt;\u0026gt; .\nNamespace: OUTCOME_V2_NAMESPACE\nHeader: \u0026lt;outcome/boost_result.hpp\u0026gt;\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/aliases/boost_unchecked/",
	"title": "`boost_unchecked&lt;T, E = boost::system::error_code&gt;`",
	"tags": [],
	"description": "A type alias to a `basic_result` configured with `boost::system::error_code` and `policy::all_narrow`.",
	"content": "A type alias to a basic_result\u0026lt;T, E, NoValuePolicy\u0026gt; configured with boost::system::error_code and policy::all_narrow .\nThis type alias always references the boost edition of things, unlike unchecked\u0026lt;T, E = varies\u0026gt; which references either this alias or std_unchecked\u0026lt;T, E = std::error_code\u0026gt; .\nNamespace: OUTCOME_V2_NAMESPACE\nHeader: \u0026lt;outcome/boost_result.hpp\u0026gt;\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/aliases/checked/",
	"title": "`checked&lt;T, E = varies&gt;`",
	"tags": [],
	"description": "A type alias to a `std_checked&lt;T, E&gt;` (standalone edition) or `boost_checked&lt;T, E&gt;` (Boost edition).",
	"content": "A type alias to either std_checked\u0026lt;T, E = std::error_code\u0026gt; (standalone edition) or boost_checked\u0026lt;T, E = boost::system::error_code\u0026gt; (Boost edition). This means that checked\u0026lt;T\u0026gt; uses the appropriate default alias depending on which edition of Outcome is in use.\nNamespace: OUTCOME_V2_NAMESPACE\nHeader: \u0026lt;outcome/result.hpp\u0026gt;\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/functions/policy/error_code/",
	"title": "`decltype(auto) error_code(T &amp;&amp;)`",
	"tags": [],
	"description": "Extracts a `boost::system::error_code` or `std::error_code` from the input via ADL discovery of a suitable `make_error_code(T)` function.",
	"content": "Extracts a boost::system::error_code or  std::error_code from the input via ADL discovery of a suitable make_error_code(T) function.\nOverridable: Argument dependent lookup.\nRequires: Always available.\nNamespace: OUTCOME_V2_NAMESPACE::policy\nHeader: \u0026lt;outcome/std_result.hpp\u0026gt;\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/functions/policy/exception_ptr/",
	"title": "`decltype(auto) exception_ptr(T &amp;&amp;)`",
	"tags": [],
	"description": "Extracts a `boost::exception_ptr` or `std::exception_ptr` from the input via ADL discovery of a suitable `make_exception_ptr(T)` function.",
	"content": "Extracts a boost::exception_ptr or  std::exception_ptr from the input via ADL discovery of a suitable make_exception_ptr(T) function.\nOverridable: Argument dependent lookup.\nRequires: Always available.\nNamespace: OUTCOME_V2_NAMESPACE::policy\nHeader: \u0026lt;outcome/std_result.hpp\u0026gt;\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/functions/try_operation_extract_value/",
	"title": "`decltype(auto) try_operation_extract_value(X)`",
	"tags": [],
	"description": "Default implementation of `try_operation_extract_value(X)` ADL customisation point for `OUTCOME_TRY`.",
	"content": "This default implementation returns whatever the .assume_value() or .value() member functions return, preferentially choosing the former where both are available.\nRequires: That the expression std::declval\u0026lt;T\u0026gt;().assume_value() and/or std::declval\u0026lt;T\u0026gt;().value() is a valid expression.\nNamespace: OUTCOME_V2_NAMESPACE\nHeader: \u0026lt;outcome/try.hpp\u0026gt;\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/functions/try_operation_return_as/",
	"title": "`decltype(auto) try_operation_return_as(X)`",
	"tags": [],
	"description": "Default implementation of `try_operation_return_as(X)` ADL customisation point for `OUTCOME_TRY`.",
	"content": "This default implementation preferentially returns whatever the input type\u0026rsquo;s .as_failure() member function returns. basic_result and basic_outcome provide such a member function, see auto as_failure() const \u0026amp; .\nIf .as_failure() is not available, it will also match any .error() member function, which it wraps into a failure type sugar using failure(T \u0026amp;\u0026amp;, ...) .\nRequires: That the expression std::declval\u0026lt;T\u0026gt;().as_failure() and/or std::declval\u0026lt;T\u0026gt;().error() is a valid expression.\nNamespace: OUTCOME_V2_NAMESPACE\nHeader: \u0026lt;outcome/try.hpp\u0026gt;\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/aliases/default_policy/",
	"title": "`default_policy&lt;T, EC, EP&gt;`",
	"tags": [],
	"description": "A type alias to a no-value policy selected based on traits matching of `T`, `EC` and `EP`.",
	"content": "A type alias to a no-value policy selected based on traits matching of T, EC and EP. It is defined as follows:\n If EC and EP is void, choose terminate .\n If is_error_code_available\u0026lt;T\u0026gt; true for EC, choose error_code_throw_as_system_error\u0026lt;T, EC, EP\u0026gt; for basic_outcome or error_code_throw_as_system_error\u0026lt;T, EC, void\u0026gt; for basic_result.\n If is_exception_ptr_available\u0026lt;T\u0026gt; true for EC or EP, choose exception_ptr_rethrow\u0026lt;T, EC, EP\u0026gt; for basic_outcome or exception_ptr_rethrow\u0026lt;T, EC, void\u0026gt; for basic_result.\n Else choose fail_to_compile_observers , which fails the build with a useful message.\n  Namespace: OUTCOME_V2_NAMESPACE::policy\nHeader: \u0026lt;outcome/std_result.hpp\u0026gt;\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/awaitables/eager/",
	"title": "`eager&lt;T, Executor = void&gt;/atomic_eager&lt;T, Executor = void&gt;`",
	"tags": [],
	"description": "An eagerly evaluated coroutine awaitable with Outcome customisation.",
	"content": "This is very similar to lazy\u0026lt;T, Executor = void\u0026gt; , except that execution of the eager\u0026lt;T\u0026gt; returning function begins immediately, and if the function never suspends during the course of its execution, no suspend-resume cycle occurs. Functions which return eager\u0026lt;T\u0026gt; are therefore suitable for tasks which may require suspension, but will often complete immediately.\natomic_eager\u0026lt;T\u0026gt; is like eager\u0026lt;T\u0026gt;, except that the setting of the coroutine result performs an atomic release, whilst the checking of whether the coroutine has finished is an atomic acquire.\nThe Executor template parameter is purely for compatibility with third party software such as ASIO, and this awaitable can be directly used by ASIO.\nExample of use (must be called from within a coroutinised function):\neager\u0026lt;int\u0026gt; func(int x) { co_return x + 1; } ... // Executes like a non-coroutine function i.e. r is immediately set to 6. int r = co_await func(5);  eager\u0026lt;T\u0026gt; has special semantics if T is a type capable of constructing from an exception_ptr or error_code \u0026ndash; any exceptions thrown during the function\u0026rsquo;s body are sent via T, preferably via the error code route if error_from_exception( ) successfully matches the exception throw. This means that a basic_result\u0026lt;T, E, NoValuePolicy\u0026gt; or basic_outcome\u0026lt;T, EC, EP, NoValuePolicy\u0026gt; where one of its types is is compatible will have its .error() or .exception() set.\nNote that eager\u0026lt;T\u0026gt; does not otherwise transport exception throws, and rethrows any exceptions thrown within the coroutine body through the coroutine machinery. This does not produce reliable consequences in current C++ compilers. You should therefore wrap the coroutine body in a try...catch if T is not able to transport exceptions on its own.\nRequires: C++ coroutines to be available in your compiler.\nNamespace: OUTCOME_V2_NAMESPACE::awaitables\nHeader: \u0026lt;outcome/coroutine_support.hpp\u0026gt;\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/policies/error_code_throw_as_system_error_outcome/",
	"title": "`error_code_throw_as_system_error&lt;T, EC, EP&gt;`",
	"tags": [],
	"description": "Policy class defining that `EP` ought to be rethrown if possible, then the ADL discovered free function `outcome_throw_as_system_error_with_payload()` should be called on incorrect wide value observation. Inherits publicly from `base`. Can only be used with `basic_outcome`.",
	"content": "Note: This policy class specialisation can only be used with basic_outcome, not basic_result. Use error_code_throw_as_system_error\u0026lt;T, EC, void\u0026gt; with basic_result.\nPolicy class defining that on incorrect wide value observation, EP ought to be rethrown if possible, then the ADL discovered free function outcome_throw_as_system_error_with_payload(impl.assume_error()) should be called. Some precanned overloads of that function are listed here.\nIncorrect wide error observation performs:\nOUTCOME_THROW_EXCEPTION(bad_outcome_access(\u0026#34;no error\u0026#34;));  Incorrect wide exception observation performs:\nOUTCOME_THROW_EXCEPTION(bad_outcome_access(\u0026#34;no exception\u0026#34;));  Inherits publicly from base , and its narrow value, error and exception observer policies are inherited from there.\nRequires: Nothing.\nNamespace: OUTCOME_V2_NAMESPACE::policy\nHeader: \u0026lt;outcome/policy/outcome_error_code_throw_as_system_error.hpp\u0026gt;\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/policies/error_code_throw_as_system_error_result/",
	"title": "`error_code_throw_as_system_error&lt;T, EC, void&gt;`",
	"tags": [],
	"description": "Policy class defining that the ADL discovered free function `outcome_throw_as_system_error_with_payload()` should be called on incorrect wide value observation. Inherits publicly from `base`. Can only be used with `basic_result`.",
	"content": "Note: This policy class specialisation can only be used with basic_result, not basic_outcome. Use error_code_throw_as_system_error\u0026lt;T, EC, EP\u0026gt; with basic_outcome.\nPolicy class defining that the ADL discovered free function outcome_throw_as_system_error_with_payload(impl.assume_error()) should be called on incorrect wide value observation. Some precanned overloads of that function are listed here.\nIncorrect wide error observation performs:\nOUTCOME_THROW_EXCEPTION(bad_result_access(\u0026#34;no error\u0026#34;));  Inherits publicly from base , and its narrow value, error and exception observer policies are inherited from there.\nRequires: Nothing.\nNamespace: OUTCOME_V2_NAMESPACE::policy\nHeader: \u0026lt;outcome/policy/result_error_code_throw_as_system_error.hpp\u0026gt;\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/policies/exception_ptr_rethrow_outcome/",
	"title": "`exception_ptr_rethrow&lt;T, EC, EP&gt;`",
	"tags": [],
	"description": "Policy class defining that the ADL discovered free function `rethrow_exception()` should be called on incorrect wide value observation. Inherits publicly from `base`. Can only be used with `basic_outcome`.",
	"content": "Note: This policy class specialisation can only be used with basic_outcome, not basic_result. Use exception_ptr_rethrow\u0026lt;T, EC, void\u0026gt; with basic_result.\nPolicy class defining that the ADL discovered free function rethrow_exception(impl.assume_exception()) if possible, followed by rethrow_exception(impl.assume_error()) should be called on incorrect wide value observation. Generally this will ADL discover  std::rethrow_exception() or boost::rethrow_exception() depending on the EC type.\nIncorrect wide error observation performs:\nOUTCOME_THROW_EXCEPTION(bad_outcome_access(\u0026#34;no error\u0026#34;));  Incorrect wide exception observation performs:\nOUTCOME_THROW_EXCEPTION(bad_outcome_access(\u0026#34;no exception\u0026#34;));  Inherits publicly from base , and its narrow value, error and exception observer policies are inherited from there.\nRequires: Nothing.\nNamespace: OUTCOME_V2_NAMESPACE::policy\nHeader: \u0026lt;outcome/policy/outcome_exception_ptr_rethrow.hpp\u0026gt;\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/policies/exception_ptr_rethrow_result/",
	"title": "`exception_ptr_rethrow&lt;T, EC, void&gt;`",
	"tags": [],
	"description": "Policy class defining that the ADL discovered free function `rethrow_exception()` should be called on incorrect wide value observation. Inherits publicly from `base`. Can only be used with `basic_result`.",
	"content": "Note: This policy class specialisation can only be used with basic_result, not basic_outcome. Use exception_ptr_rethrow\u0026lt;T, EC, EP\u0026gt; with basic_outcome.\nPolicy class defining that the ADL discovered free function rethrow_exception(impl.assume_error()) should be called on incorrect wide value observation. Generally this will ADL discover  std::rethrow_exception() or boost::rethrow_exception() depending on the EC type.\nIncorrect wide error observation performs:\nOUTCOME_THROW_EXCEPTION(bad_result_access(\u0026#34;no error\u0026#34;));  Inherits publicly from base , and its narrow value, error and exception observer policies are inherited from there.\nRequires: Nothing.\nNamespace: OUTCOME_V2_NAMESPACE::policy\nHeader: \u0026lt;outcome/policy/result_exception_ptr_rethrow.hpp\u0026gt;\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/policies/fail_to_compile_observers/",
	"title": "`fail_to_compile_observers`",
	"tags": [],
	"description": "Policy class defining that a static assertion should occur upon compilation of the wide value, error or exception observation. Inherits publicly from `base`.",
	"content": "Upon attempting to compile the wide observer policy functions, the following static assertion occurs which fails the build:\n Attempt to wide observe value, error or exception for a result/outcome given an EC or E type which is not void, and for whom trait::has_error_code_v, trait::has_exception_ptr_v, and trait::has_exception_ptr_v are all false. Please specify a NoValuePolicy to tell result/outcome what to do, or else use a more specific convenience type alias such as uncheckedto indicate you want the wide observers to be narrow, or checkedto indicate you always want an exception throw etc.\n This failure to compile was introduced after the Boost peer review of v2.0 of Outcome due to feedback that users were too often surprised by the default selection of the all_narrow policy if the types were unrecognised. It was felt this introduced too much danger in the default configuration, so to ensure that existing code based on Outcome broke very loudly after an upgrade, the above very verbose static assertion was implemented.\nRequires: Nothing.\nNamespace: OUTCOME_V2_NAMESPACE::policy\nHeader: \u0026lt;outcome/policy/fail_to_compile_observers.hpp\u0026gt;\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/failure_type/",
	"title": "`failure_type&lt;EC, EP = void&gt;`",
	"tags": [],
	"description": "Type sugar for constructing an unsuccessful result or outcome.",
	"content": "Type sugar for constructing an unsuccessful result or outcome. Generally not constructed directly, but via the free function failure(T \u0026amp;\u0026amp;, ...) . Detectable using is_failure_type\u0026lt;T\u0026gt; .\nThis is a regular wrapper type, with defaulted default, copy and move constructor, defaulted assignment, and defaulted destructor.\nMember type aliases error_type and exception_type indicate EC and E.\nThere is an explicit initialising constructor taking any types U and V which will forward construct the contained error_type and exception_type respectively. It also has an optional parameter spare_storage, if you wish to specify a spare storage value.\nThere are two tagged initialising constructors taking in_place_type_t\u0026lt;error_type\u0026gt; or in_place_type_t\u0026lt;exception_type\u0026gt;, and a U which will forward construct the contained error_type and exception_type respectively. These both also have an optional parameter spare_storage, if you wish to specify a spare storage value.\nThere are .error() and .exception() reference observers with the usual constexpr lvalue, const lvalue, rvalue and const rvalue overloads. One can discover which or both of these is valid using the usual .has_error() and .has_exception() observers.\nThere is a .spare_storage() observer which returns the spare storage value with which the failure type sugar was constructed.\nThere are specialisations failure_type\u0026lt;EC, void\u0026gt; and failure_type\u0026lt;void, E\u0026gt; which store nothing for the voided type and do not provide their observer functions.\nRequires: Nothing.\nNamespace: OUTCOME_V2_NAMESPACE\nHeader: \u0026lt;outcome/success_failure.hpp\u0026gt;\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/awaitables/generator/",
	"title": "`generator&lt;T, Executor = void&gt;`",
	"tags": [],
	"description": "A lazily evaluated coroutine generator with Outcome customisation.",
	"content": "This is a classic coroutine generator whereby the coroutine is resumed to calculate the next value, and is suspended upon yielding that value. If the value being yielded is an Outcome type, special semantics are used if the coroutine throws an exception (see below).\nThe Executor template parameter is purely for compatibility with third party software such as ASIO, and this awaitable can be directly used by ASIO.\nExample of use:\ngenerator\u0026lt;int\u0026gt; func(int x) { while(x \u0026gt;= 0) { co_yield x--; } } ... // Creates the coroutine, immediately suspending it. auto f = func(5); // If the coroutine has another value to yield ... while(f) { // Get the next value from the coroutine  int r = f(); ... }  generator\u0026lt;T\u0026gt; has special semantics if T is a type capable of constructing from an exception_ptr or error_code \u0026ndash; any exceptions thrown during the function\u0026rsquo;s body are sent via T, preferably via the error code route if error_from_exception( ) successfully matches the exception throw. This means that a basic_result\u0026lt;T, E, NoValuePolicy\u0026gt; or basic_outcome\u0026lt;T, EC, EP, NoValuePolicy\u0026gt; where one of its types is is compatible will have its .error() or .exception() set.\nNote that generator\u0026lt;T\u0026gt; does not otherwise transport exception throws, and rethrows any exceptions thrown within the coroutine body through the coroutine machinery. This does not produce reliable consequences in current C++ compilers. You should therefore wrap the coroutine body in a try...catch if T is not able to transport exceptions on its own.\nRequires: C++ coroutines to be available in your compiler.\nNamespace: OUTCOME_V2_NAMESPACE::awaitables\nHeader: \u0026lt;outcome/coroutine_support.hpp\u0026gt;\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/in_place_type_t/",
	"title": "`in_place_type_t&lt;T&gt;`",
	"tags": [],
	"description": "Either `std::in_place_type_t&lt;T&gt;` or a local emulation, depending on the `OUTCOME_USE_STD_IN_PLACE_TYPE` macro.",
	"content": "Either std::in_place_type_t\u0026lt;T\u0026gt; or a local emulation, depending on the OUTCOME_USE_STD_IN_PLACE_TYPE macro.\nNote that the templated variable in_place_type is also aliased or emulated locally.\nRequires: Nothing.\nNamespace: OUTCOME_V2_NAMESPACE\nHeader: \u0026lt;outcome/config.hpp\u0026gt;\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/traits/is_basic_outcome/",
	"title": "`is_basic_outcome&lt;T&gt;`",
	"tags": [],
	"description": "An integral constant type true for `basic_outcome&lt;T, EC, EP, NoValuePolicy&gt;` types.",
	"content": "An integral constant type true for basic_outcome\u0026lt;T, EC, EP, NoValuePolicy\u0026gt; types. This does not match anything not exactly a basic_outcome. If you want to match types like basic_outcome but not equal to it, consider basic_outcome\u0026lt;T\u0026gt; ..\nOverridable: Not overridable.\nNamespace: OUTCOME_V2_NAMESPACE\nHeader: \u0026lt;outcome/basic_outcome.hpp\u0026gt;\nVariable alias: is_basic_outcome_v\u0026lt;T\u0026gt;\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/traits/is_basic_result/",
	"title": "`is_basic_result&lt;T&gt;`",
	"tags": [],
	"description": "An integral constant type true for `basic_result&lt;T, E, NoValuePolicy&gt;` types.",
	"content": "An integral constant type true for basic_result\u0026lt;T, E, NoValuePolicy\u0026gt; types. This does not match anything not exactly a basic_result. If you want to match types like basic_result but not equal to it, consider basic_result\u0026lt;T\u0026gt; or value_or_error\u0026lt;T\u0026gt; .\nOverridable: Not overridable.\nNamespace: OUTCOME_V2_NAMESPACE\nHeader: \u0026lt;outcome/basic_result.hpp\u0026gt;\nVariable alias: is_basic_result_v\u0026lt;T\u0026gt;\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/traits/is_error_code_available/",
	"title": "`is_error_code_available&lt;T&gt;`",
	"tags": [],
	"description": "True if an error code can be constructed from a `T`.",
	"content": "::value is true if an error code can be constructed from a T e.g. if there exists an ADL discovered free function make_error_code(T). ::type is the type that would result if ::value is true, else void.\nOverridable: By template specialisation into the trait namespace.\nDefault: True if T is an error code, else to metaprogramming which performs the ADL discovery of make_error_code(T). Note that the STL defines multiple overloads of an ADL discovered free function  std::make_error_code(T) for its error enumerations, as does Boost.System for the Boost error enumerations. Thus this trait will pick up those free functions for those error types.\nNamespace: OUTCOME_V2_NAMESPACE::trait\nHeader: \u0026lt;outcome/trait.hpp\u0026gt;\nVariable alias: is_error_code_available_v\u0026lt;T\u0026gt;\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/traits/is_error_type/",
	"title": "`is_error_type&lt;E&gt;`",
	"tags": [],
	"description": "A customisable integral constant type true for `E` types which are to receive error throwing no-value policies.",
	"content": "A customisable integral constant type true for E types which are to receive error throwing no-value policies. Special weakened implicit construction enable is available for integral T types when combined with E types in this whitelist \u0026ndash; this permits boost_result\u0026lt;int, boost::system::errc::errc_t to retain its implicit constructors, despite the fact that errc_t as a C enum has an implicit conversion to int.\nOverridable: By template specialisation into the trait namespace.\nDefault: False. Specialisations to true exist for:\n \u0026lt;outcome/boost_result.hpp\u0026gt;\n boost::system::error_code boost::system::errc::errc_t boost::exception_ptr  \u0026lt;outcome/std_result.hpp\u0026gt;\n std::error_code std::errc std::exception_ptr   Namespace: OUTCOME_V2_NAMESPACE::trait\nHeader: \u0026lt;outcome/trait.hpp\u0026gt;\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/traits/is_error_type_enum/",
	"title": "`is_error_type_enum&lt;E, Enum&gt;`",
	"tags": [],
	"description": "A customisable integral constant type true for `E` types constructible from `Enum` types which are to receive error throwing no-value policies.",
	"content": "A customisable integral constant type true for E types constructible from Enum types which are to receive error throwing no-value policies\nOverridable: By template specialisation into the trait namespace.\nDefault: False. Specialisations exist for:\n \u0026lt;outcome/boost_result.hpp\u0026gt;\n boost::system::error_code to boost::system::is_error_condition_enum\u0026lt;Enum\u0026gt;::value.  \u0026lt;outcome/std_result.hpp\u0026gt;\n std::error_code to std::is_error_condition_enum\u0026lt;Enum\u0026gt;::value.   Namespace: OUTCOME_V2_NAMESPACE::trait\nHeader: \u0026lt;outcome/trait.hpp\u0026gt;\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/traits/is_exception_ptr_available/",
	"title": "`is_exception_ptr_available&lt;T&gt;`",
	"tags": [],
	"description": "True if an exception ptr can be constructed from a `T`.",
	"content": "::value is true if an exception ptr can be constructed from a T e.g. if there exists an ADL discovered free function make_exception_ptr(T). ::type is the type that would result if ::value is true, else void.\nOverridable: By template specialisation into the trait namespace.\nDefault: True if T is an exception ptr, else to metaprogramming which performs the ADL discovery of make_exception_ptr(T). Note that the STL defines an ADL discovered free function  std::make_exception_ptr(T) . Thus this trait will pick up that free function.\nNamespace: OUTCOME_V2_NAMESPACE::trait\nHeader: \u0026lt;outcome/trait.hpp\u0026gt;\nVariable alias: is_exception_ptr_available_v\u0026lt;T\u0026gt;\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/traits/is_failure_type/",
	"title": "`is_failure_type&lt;T&gt;`",
	"tags": [],
	"description": "An integral constant boolean variable true for `failure_type&lt;EC, E = void&gt;` types.",
	"content": "An integral constant boolean variable true for failure_type\u0026lt;EC, EP = void\u0026gt; types.\nOverridable: Not overridable.\nNamespace: OUTCOME_V2_NAMESPACE\nHeader: \u0026lt;outcome/success_failure.hpp\u0026gt;\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/traits/is_move_bitcopying/",
	"title": "`is_move_bitcopying&lt;T&gt;`",
	"tags": [],
	"description": "(&gt;= Outcome v2.2.0) A customisable integral constant type true for `T` types which are move bitcopying safe.",
	"content": "A customisable integral constant type true for T types which are move bitcopying safe. As per P1029 move bitcopying, these are types for which:\n There is an inline, constexpr-available, default constructor. The move constructor has side effects equivalent to memcpy of source to destination, followed by a memcpy of a default constructed instance to source. That the destruction of a default constructed instance has no visible side effects.  This implies that if you move from a bit copying type, you need not call its destructor, even if that is a virtual destructor.\nIf you opt your types into this trait, Outcome will track moved-from state and not call the destructor for your type on moved-from instances. Obviously enough this is, in current C++ standards, undefined behaviour. However it very significantly improves the quality of codegen during inlining.\nOverridable: By template specialisation into the trait namespace.\nDefault: False. Default specialisations exist for:\n \u0026lt;outcome/experimental/status_result.hpp\u0026gt;  True for SYSTEM_ERROR2_NAMESPACE::status_code\u0026lt;DomainType\u0026gt; if trait SYSTEM_ERROR2_NAMESPACE::traits::is_move_bitcopying\u0026lt;SYSTEM_ERROR2_NAMESPACE::status_code\u0026lt;DomainType\u0026gt;\u0026gt;::value is true. True for SYSTEM_ERROR2_NAMESPACE::errored_status_code\u0026lt;DomainType\u0026gt; if trait SYSTEM_ERROR2_NAMESPACE::traits::is_move_bitcopying\u0026lt;SYSTEM_ERROR2_NAMESPACE::errored_status_code\u0026lt;DomainType\u0026gt;\u0026gt;::value is true.   Namespace: OUTCOME_V2_NAMESPACE::trait\nHeader: \u0026lt;outcome/trait.hpp\u0026gt;\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/traits/is_success_type/",
	"title": "`is_success_type&lt;T&gt;`",
	"tags": [],
	"description": "An integral constant boolean variable true for `success_type&lt;T&gt;` types.",
	"content": "An integral constant boolean variable true for success_type\u0026lt;T\u0026gt; types.\nOverridable: Not overridable.\nNamespace: OUTCOME_V2_NAMESPACE\nHeader: \u0026lt;outcome/success_failure.hpp\u0026gt;\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/awaitables/lazy/",
	"title": "`lazy&lt;T, Executor = void&gt;/atomic_lazy&lt;T, Executor = void&gt;`",
	"tags": [],
	"description": "A lazily evaluated coroutine awaitable with Outcome customisation.",
	"content": "This is very similar to eager\u0026lt;T, Executor = void\u0026gt; , except that execution of the lazy\u0026lt;T\u0026gt; returning function suspends immediately. Functions which return lazy\u0026lt;T\u0026gt; are therefore suitable for tasks which you need to instantiate right now, but whose execution will occur elsewhere e.g. in a separate kernel thread. Because of the very common use case of using worker threads to execute the body of lazily executed coroutines, most people will want to use atomic_lazy\u0026lt;T\u0026gt; instead of lazy\u0026lt;T\u0026gt;.\natomic_lazy\u0026lt;T\u0026gt; is like lazy\u0026lt;T\u0026gt;, except that the setting of the coroutine result performs an atomic release, whilst the checking of whether the coroutine has finished is an atomic acquire.\nlazy\u0026lt;T\u0026gt; has similar semantics to std::lazy\u0026lt;T\u0026gt;, which is being standardised. See https://wg21.link/P1056 Add lazy coroutine (coroutine task) type.\nThe Executor template parameter is purely for compatibility with third party software such as ASIO, and this awaitable can be directly used by ASIO.\nExample of use (must be called from within a coroutinised function):\nlazy\u0026lt;int\u0026gt; func(int x) { co_return x + 1; } ... // Always suspends perhaps causing other coroutines to execute, then resumes. int r = co_await func(5);  lazy\u0026lt;T\u0026gt; has special semantics if T is a type capable of constructing from an exception_ptr or error_code \u0026ndash; any exceptions thrown during the function\u0026rsquo;s body are sent via T, preferably via the error code route if error_from_exception( ) successfully matches the exception throw. This means that a basic_result\u0026lt;T, E, NoValuePolicy\u0026gt; or basic_outcome\u0026lt;T, EC, EP, NoValuePolicy\u0026gt; where one of its types is is compatible will have its .error() or .exception() set.\nNote that lazy\u0026lt;T\u0026gt; does not otherwise transport exception throws, and rethrows any exceptions thrown within the coroutine body through the coroutine machinery. This does not produce reliable consequences in current C++ compilers. You should therefore wrap the coroutine body in a try...catch if T is not able to transport exceptions on its own.\nRequires: C++ coroutines to be available in your compiler.\nNamespace: OUTCOME_V2_NAMESPACE::awaitables\nHeader: \u0026lt;outcome/coroutine_support.hpp\u0026gt;\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/aliases/outcome/",
	"title": "`outcome&lt;T, EC = varies, EP = varies, NoValuePolicy = policy::default_policy&lt;T, EC, EP&gt;&gt;`",
	"tags": [],
	"description": "A type alias to a `std_outcome&lt;T, EC, EP, NoValuePolicy&gt;` (standalone edition) or `boost_outcome&lt;T, EC, EP, NoValuePolicy&gt;` (Boost edition).",
	"content": "A type alias to either std_outcome\u0026lt;T, EC = std::error_code, EP = std::exception_ptr, NoValuePolicy = policy::default_policy\u0026lt;T, EC, EP\u0026gt;\u0026gt; (standalone edition) or boost_outcome\u0026lt;T, EC = boost::system::error_code, EP = boost::exception_ptr, NoValuePolicy = policy::default_policy\u0026lt;T, EC, EP\u0026gt;\u0026gt; (Boost edition), and policy::default_policy . This means that outcome\u0026lt;T\u0026gt; uses the appropriate default alias depending on which edition of Outcome is in use.\nNamespace: OUTCOME_V2_NAMESPACE\nHeader: \u0026lt;outcome/outcome.hpp\u0026gt;\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/aliases/result/",
	"title": "`result&lt;T, E = varies, NoValuePolicy = policy::default_policy&lt;T, E, void&gt;&gt;`",
	"tags": [],
	"description": "A type alias to a `std_result&lt;T, E, NoValuePolicy&gt;` (standalone edition) or `boost_result&lt;T, E, NoValuePolicy&gt;` (Boost edition).",
	"content": "A type alias to either std_result\u0026lt;T, E = std::error_code, NoValuePolicy = policy::default_policy\u0026lt;T, E, void\u0026gt;\u0026gt; (standalone edition) or boost_result\u0026lt;T, E = boost::system::error_code, NoValuePolicy = policy::default_policy\u0026lt;T, E, void\u0026gt;\u0026gt; (Boost edition), and policy::default_policy . This means that result\u0026lt;T\u0026gt; uses the appropriate default alias depending on which edition of Outcome is in use.\nNamespace: OUTCOME_V2_NAMESPACE\nHeader: \u0026lt;outcome/result.hpp\u0026gt;\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/functions/error_from_exception/",
	"title": "`std::error_code error_from_exception(std::exception_ptr &amp;&amp;ep = std::current_exception(), std::error_code not_matched = std::make_error_code(std::errc::resource_unavailable_try_again)) noexcept`",
	"tags": [],
	"description": "Returns an error code matching a thrown standard library exception.",
	"content": "This function saves writing boilerplate by rethrowing ep within a try block, with a long sequence of catch() handlers, one for every standard C++ exception type which has a near or exact equivalent code in  std::errc .\nIf matched, ep is set to a default constructed  std::exception_ptr , and a  std::error_code is constructed using the ADL discovered free function make_error_code() upon the std::errc enumeration value matching the thrown exception.\nIf not matched, ep is left intact, and the not_matched error code supplied is returned instead.\nOverridable: Not overridable.\nRequires: C++ exceptions to be globally enabled.\nNamespace: OUTCOME_V2_NAMESPACE\nHeader: \u0026lt;outcome/utils.hpp\u0026gt;\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/functions/iostream/outcome_operator_in/",
	"title": "`std::istream &amp;operator&gt;&gt;(std::istream &amp;, basic_outcome&lt;T, EC, EP, NoValuePolicy&gt; &amp;)`",
	"tags": [],
	"description": "Deserialises a `basic_outcome` from a `std::istream`.",
	"content": "Deserialises a basic_outcome from a std::istream.\nSerialisation format is:\n\u0026lt;unsigned int flags\u0026gt;\u0026lt;space\u0026gt;\u0026lt;value_type if set and not void\u0026gt;\u0026lt;error_type if set and not void\u0026gt;\u0026lt;exception_type if set and not void\u0026gt;  Overridable: Not overridable.\nRequires: That operator\u0026gt;\u0026gt; is a valid expression for std::istream and T, EC and EP.\nNamespace: OUTCOME_V2_NAMESPACE\nHeader: \u0026lt;outcome/iostream_support.hpp\u0026gt; (must be explicitly included manually).\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/functions/iostream/result_operator_in/",
	"title": "`std::istream &amp;operator&gt;&gt;(std::istream &amp;, basic_result&lt;T, E, NoValuePolicy&gt; &amp;)`",
	"tags": [],
	"description": "Deserialises a `basic_result` from a `std::istream`.",
	"content": "Deserialises a basic_result from a std::istream.\nSerialisation format is:\n\u0026lt;unsigned int flags\u0026gt;\u0026lt;space\u0026gt;\u0026lt;value_type if set and not void\u0026gt;\u0026lt;error_type if set and not void\u0026gt;  Overridable: Not overridable.\nRequires: That operator\u0026gt;\u0026gt; is a valid expression for std::istream and T and E.\nNamespace: OUTCOME_V2_NAMESPACE\nHeader: \u0026lt;outcome/iostream_support.hpp\u0026gt; (must be explicitly included manually).\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/functions/iostream/outcome_operator_out/",
	"title": "`std::ostream &amp;operator&lt;&lt;(std::ostream &amp;, const basic_outcome&lt;T, EC, EP, NoValuePolicy&gt; &amp;)`",
	"tags": [],
	"description": "Serialises a `basic_outcome` to a `std::ostream`.",
	"content": "Serialises a basic_outcome to a std::ostream.\nSerialisation format is:\n\u0026lt;unsigned int flags\u0026gt;\u0026lt;space\u0026gt;\u0026lt;value_type if set and not void\u0026gt;\u0026lt;error_type if set and not void\u0026gt;\u0026lt;exception_type if set and not void\u0026gt;  This is the wrong function to use if you wish to print human readable output. Use std::string print(const basic_outcome\u0026lt;T, EC, EP, NoValuePolicy\u0026gt; \u0026amp;) instead.\nOverridable: Not overridable.\nRequires: That operator\u0026lt;\u0026lt; is a valid expression for std::ostream and T, EC and EP.\nNamespace: OUTCOME_V2_NAMESPACE\nHeader: \u0026lt;outcome/iostream_support.hpp\u0026gt; (must be explicitly included manually).\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/functions/iostream/result_operator_out/",
	"title": "`std::ostream &amp;operator&lt;&lt;(std::ostream &amp;, const basic_result&lt;T, E, NoValuePolicy&gt; &amp;)`",
	"tags": [],
	"description": "Serialises a `basic_result` to a `std::ostream`.",
	"content": "Serialises a basic_result to a std::ostream.\nSerialisation format is:\n\u0026lt;unsigned int flags\u0026gt;\u0026lt;space\u0026gt;\u0026lt;value_type if set and not void\u0026gt;\u0026lt;error_type if set and not void\u0026gt;  This is the wrong function to use if you wish to print human readable output. Use std::string print(const basic_result\u0026lt;T, E, NoValuePolicy\u0026gt; \u0026amp;) instead.\nOverridable: Not overridable.\nRequires: That operator\u0026lt;\u0026lt; is a valid expression for std::ostream and T and E.\nNamespace: OUTCOME_V2_NAMESPACE\nHeader: \u0026lt;outcome/iostream_support.hpp\u0026gt; (must be explicitly included manually).\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/functions/iostream/outcome_print/",
	"title": "`std::string print(const basic_outcome&lt;T, EC, EP, NoValuePolicy&gt; &amp;)`",
	"tags": [],
	"description": "Returns a string containing a human readable rendition of the `basic_outcome`.",
	"content": "Returns a string containing a human readable rendition of the basic_outcome.\nOverridable: Not overridable.\nRequires: Always available.\nNamespace: OUTCOME_V2_NAMESPACE\nHeader: \u0026lt;outcome/iostream_support.hpp\u0026gt; (must be explicitly included manually).\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/functions/iostream/result_print/",
	"title": "`std::string print(const basic_result&lt;T, E, NoValuePolicy&gt; &amp;)`",
	"tags": [],
	"description": "Returns a string containing a human readable rendition of the `basic_result`.",
	"content": "Returns a string containing a human readable rendition of the basic_result.\nOverridable: Not overridable.\nRequires: Always available.\nNamespace: OUTCOME_V2_NAMESPACE\nHeader: \u0026lt;outcome/iostream_support.hpp\u0026gt; (must be explicitly included manually).\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/aliases/std_checked/",
	"title": "`std_checked&lt;T, E = std::error_code&gt;`",
	"tags": [],
	"description": "A type alias to a `basic_result` configured with `std::error_code` and `policy::throw_bad_result_access&lt;EC&gt;`.",
	"content": "A type alias to a basic_result\u0026lt;T, E, NoValuePolicy\u0026gt; configured with  std::error_code and policy::throw_bad_result_access\u0026lt;EC\u0026gt; .\nThis type alias always references the std edition of things, unlike checked\u0026lt;T, E = varies\u0026gt; which references either this alias or boost_checked\u0026lt;T, E = boost::system::error_code\u0026gt; .\nNamespace: OUTCOME_V2_NAMESPACE\nHeader: \u0026lt;outcome/std_result.hpp\u0026gt;\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/aliases/std_outcome/",
	"title": "`std_outcome&lt;T, EC = std::error_code, EP = std::exception_ptr, NoValuePolicy = policy::default_policy&lt;T, EC, EP&gt;&gt;`",
	"tags": [],
	"description": "A type alias to a `basic_outcome` configured with `std::error_code`, `std::exception_ptr` and `policy::default_policy`.",
	"content": "A type alias to a basic_outcome\u0026lt;T, EC, EP, NoValuePolicy\u0026gt; configured with  std::error_code ,  std::exception_ptr and policy::default_policy .\nThis type alias always references the std edition of things, unlike outcome\u0026lt;T, EC = varies, EP = varies, NoValuePolicy = policy::default_policy\u0026lt;T, EC, EP\u0026gt;\u0026gt; which references either this alias or boost_outcome\u0026lt;T, EC = boost::system::error_code, EP = boost::exception_ptr, NoValuePolicy = policy::default_policy\u0026lt;T, EC, EP\u0026gt;\u0026gt; .\nNamespace: OUTCOME_V2_NAMESPACE\nHeader: \u0026lt;outcome/std_outcome.hpp\u0026gt;\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/aliases/std_result/",
	"title": "`std_result&lt;T, E = std::error_code, NoValuePolicy = policy::default_policy&lt;T, E, void&gt;&gt;`",
	"tags": [],
	"description": "A type alias to a `basic_result` configured with `std::error_code` and `policy::default_policy`.",
	"content": "A type alias to a basic_result\u0026lt;T, E, NoValuePolicy\u0026gt; configured with  std::error_code and policy::default_policy .\nThis type alias always references the std edition of things, unlike result\u0026lt;T, E = varies, NoValuePolicy = policy::default_policy\u0026lt;T, E, void\u0026gt;\u0026gt; which references either this alias or boost_result\u0026lt;T, E = boost::system::error_code, NoValuePolicy = policy::default_policy\u0026lt;T, E, void\u0026gt;\u0026gt; .\nNamespace: OUTCOME_V2_NAMESPACE\nHeader: \u0026lt;outcome/std_result.hpp\u0026gt;\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/aliases/std_unchecked/",
	"title": "`std_unchecked&lt;T, E = std::error_code&gt;`",
	"tags": [],
	"description": "A type alias to a `basic_result` configured with `std::error_code` and `policy::all_narrow`.",
	"content": "A type alias to a basic_result\u0026lt;T, E, NoValuePolicy\u0026gt; configured with  std::error_code and policy::all_narrow .\nThis type alias always references the std edition of things, unlike unchecked\u0026lt;T, E = varies\u0026gt; which references either this alias or boost_unchecked\u0026lt;T, E = boost::system::error_code\u0026gt; .\nNamespace: OUTCOME_V2_NAMESPACE\nHeader: \u0026lt;outcome/std_result.hpp\u0026gt;\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/types/success_type/",
	"title": "`success_type&lt;T&gt;`",
	"tags": [],
	"description": "Type sugar for constructing a successful result or outcome.",
	"content": "Type sugar for constructing a successful result or outcome. Generally not constructed directly, but via the free function success(T \u0026amp;\u0026amp;, ...) . Detectable using is_success_type\u0026lt;T\u0026gt; .\nThis is a regular wrapper type, with defaulted default, copy and move constructor, defaulted assignment, and defaulted destructor.\nA member type alias value_type indicates T.\nThere is an explicit initialising constructor taking any type U which is not a success_type\u0026lt;T\u0026gt;, and which will forward construct the contained T from that U. It also has an optional parameter spare_storage, if you wish to specify a spare storage value.\nThere is a .value() reference observer with the usual constexpr lvalue, const lvalue, rvalue and const rvalue overloads.\nThere is a specialisation success_type\u0026lt;void\u0026gt; which stores nothing and provides no .value() observers.\nThere is a .spare_storage() observer which returns the spare storage value with which the success type sugar was constructed.\nRequires: Nothing.\nNamespace: OUTCOME_V2_NAMESPACE\nHeader: \u0026lt;outcome/success_failure.hpp\u0026gt;\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/policies/terminate/",
	"title": "`terminate`",
	"tags": [],
	"description": "Policy class defining that `std::terminate()` should be called on incorrect wide value, error or exception observation. Inherits publicly from `base`.",
	"content": "Policy class defining that  std::terminate() should be called on incorrect wide value, error or exception observation.\nInherits publicly from base , and its narrow value, error and exception observer policies are inherited from there.\nIncluded by \u0026lt;basic_result.hpp\u0026gt;, and so is always available when basic_result is available.\nRequires: Nothing.\nNamespace: OUTCOME_V2_NAMESPACE::policy\nHeader: \u0026lt;outcome/policy/terminate.hpp\u0026gt;\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/policies/throw_bad_result_access/",
	"title": "`throw_bad_result_access&lt;EC&gt;`",
	"tags": [],
	"description": "Policy class defining that `bad_result_access_with&lt;EC&gt;` should be thrown on incorrect wide value observation. Inherits publicly from `base`.",
	"content": "Policy class defining that bad_result_access_with\u0026lt;EC\u0026gt; should be thrown on incorrect wide value observation. The primary purpose of this policy is to enable standing in for  P0323 std::expected\u0026lt;T, E\u0026gt; which throws a bad_expected_access\u0026lt;E\u0026gt; on incorrect wide value observation. This is why it is only ever EC which is thrown with bad_result_access_with\u0026lt;EC\u0026gt; on value observation only, and only when there is an error available.\nIf used in basic_outcome, and the outcome is exceptioned and so no error is available, incorrect wide value observation performs instead:\nOUTCOME_THROW_EXCEPTION(bad_result_access(\u0026#34;no value\u0026#34;));  Incorrect wide error observation performs:\nOUTCOME_THROW_EXCEPTION(bad_result_access(\u0026#34;no error\u0026#34;));  Incorrect wide exception observation performs:\nOUTCOME_THROW_EXCEPTION(bad_outcome_access(\u0026#34;no exception\u0026#34;));  Inherits publicly from base , and its narrow value, error and exception observer policies are inherited from there.\nRequires: Nothing.\nNamespace: OUTCOME_V2_NAMESPACE::policy\nHeader: \u0026lt;outcome/policy/throw_bad_result_access.hpp\u0026gt;\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/traits/type_can_be_used_in_basic_result/",
	"title": "`type_can_be_used_in_basic_result&lt;R&gt;`",
	"tags": [],
	"description": "A constexpr boolean true for types permissible in `basic_result&lt;T, E, NoValuePolicy&gt;`.",
	"content": "A constexpr boolean true for types permissible in basic_result\u0026lt;T, E, NoValuePolicy\u0026gt;.\nOverridable: Not overridable.\nDefinition: True for a type which:\n Is not a reference. Is not an in_place_type_t\u0026lt;T\u0026gt; . Is not a success_type\u0026lt;T\u0026gt; . Is not a failure_type\u0026lt;EC, EP = void\u0026gt; . Is not an array. Is either void, or else is an Object and is Destructible.  Namespace: OUTCOME_V2_NAMESPACE::trait\nHeader: \u0026lt;outcome/trait.hpp\u0026gt;\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/functions/hooks/spare_storage/",
	"title": "`uint16_t spare_storage(const basic_result|basic_outcome *) noexcept`",
	"tags": [],
	"description": "Returns the sixteen bits of spare storage in the specified result or outcome.",
	"content": "Returns the sixteen bits of spare storage in the specified result or outcome. You can set these bits using void set_spare_storage(basic_result|basic_outcome *, uint16_t) noexcept .\nOverridable: Not overridable.\nRequires: Nothing.\nNamespace: OUTCOME_V2_NAMESPACE::hooks\nHeader: \u0026lt;outcome/basic_result.hpp\u0026gt;\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/aliases/unchecked/",
	"title": "`unchecked&lt;T, E = varies&gt;`",
	"tags": [],
	"description": "A type alias to a `std_unchecked&lt;T, E&gt;` (standalone edition) or `boost_unchecked&lt;T, E&gt;` (Boost edition).",
	"content": "A type alias to either std_unchecked\u0026lt;T, E = std::error_code\u0026gt; (standalone edition) or boost_unchecked\u0026lt;T, E = boost::system::error_code\u0026gt; (Boost edition). This means that unchecked\u0026lt;T\u0026gt; uses the appropriate default alias depending on which edition of Outcome is in use.\nNamespace: OUTCOME_V2_NAMESPACE\nHeader: \u0026lt;outcome/result.hpp\u0026gt;\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/converters/value_or_error/",
	"title": "`value_or_error&lt;T, U&gt;`",
	"tags": [],
	"description": "A customisable converter of `value_or_error&lt;T, E&gt;` concept matching types.",
	"content": "A customisable converter of concepts::value_or_error\u0026lt;T, E\u0026gt; concept matching types. It must have the following form:\n// `T` will be the destination basic_result or basic_outcome. // `U` will be the decayed form of the `value_or_error\u0026lt;T, E\u0026gt;` concept matching input type. template \u0026lt;classT\u0026gt; struct value_or_error\u0026lt;T, U\u0026gt; { // False to indicate that this converter wants `basic_result`/`basic_outcome` to reject all other `basic_result`  static constexpr bool enable_result_inputs = false; // False to indicate that this converter wants `basic_outcome` to reject all other `basic_outcome`  static constexpr bool enable_outcome_inputs = false; // `X` will be the raw input form of `U`. It must return a `T`.  template\u0026lt;classX\u0026gt; constexpr T operator()(X \u0026amp;\u0026amp;v); };  Overridable: By template specialisation into the convert namespace.\nDefault: If decayed X is same as U, concept value_or_error\u0026lt;U\u0026gt; matches, X::value_type is void or is explicitly constructible to T::value_type, and X::error_type is void or is explicitly constructible to T::error_type, then operator()(X \u0026amp;\u0026amp;) is made available.\noperator()(X \u0026amp;\u0026amp;v) tests if v.has_value() is true, if so then a T with successful value is returned, else a T with unsuccessful value. If the input type was void, a default constructed value is used for either, else a move/copy construction from the source is performed.\nNamespace: OUTCOME_V2_NAMESPACE::convert\nHeader: \u0026lt;outcome/convert.hpp\u0026gt;\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/concepts/value_or_error/",
	"title": "`value_or_error&lt;T&gt;`",
	"tags": [],
	"description": "A boolean concept matching types with either a value or an error.",
	"content": "If on C++ 20 or the Concepts TS is enabled, a boolean concept matching types with a public .has_value() observer which returns bool, a public .value() observer function, and a public .error() observer function.\nIf without Concepts, a static constexpr bool which is true for types matching the same requirements, using a SFINAE based emulation.\nThis concept matches expected-like types such as  P0323 std::expected\u0026lt;T, E\u0026gt; , one of which is basic_result\u0026lt;T, E, NoValuePolicy\u0026gt; . Be aware it does not differentiate between value-or-error types and value-and-error types if they present the interface matched above.\nIf you want a concept matching specifically basic_result\u0026lt;T, E, NoValuePolicy\u0026gt; , see basic_result\u0026lt;T\u0026gt; .\nNamespace: OUTCOME_V2_NAMESPACE::concepts\nHeader: \u0026lt;outcome/convert.hpp\u0026gt;\nLegacy: This was named convert::ValueOrError\u0026lt;T\u0026gt; in Outcome v2.1 and earlier. Define OUTCOME_ENABLE_LEGACY_SUPPORT_FOR to less than 220 to enable.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/concepts/value_or_none/",
	"title": "`value_or_none&lt;T&gt;`",
	"tags": [],
	"description": "A boolean concept matching types with an optional value.",
	"content": "If on C++ 20 or the Concepts TS is enabled, a boolean concept matching types with a public .has_value() observer which returns bool, and a public .value() observer function.\nIf without Concepts, a static constexpr bool which is true for types matching the same requirements, using a SFINAE based emulation.\nThis concept matches optional-like types such as  std::optional\u0026lt;T\u0026gt; . Note it also matches  P0323 std::expected\u0026lt;T, E\u0026gt; , which also has an optional-like interface. You may thus wish to preferentially match concepts::value_or_error\u0026lt;T, E\u0026gt; for any given T.\nNamespace: OUTCOME_V2_NAMESPACE::concepts\nHeader: \u0026lt;outcome/convert.hpp\u0026gt;\nLegacy: This was named convert::ValueOrNone\u0026lt;T\u0026gt; in Outcome v2.1 and earlier. Define OUTCOME_ENABLE_LEGACY_SUPPORT_FOR to less than 220 to enable.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/functions/hooks/hook_outcome_construction/",
	"title": "`void hook_outcome_construction(T *, U &amp;&amp;) noexcept`",
	"tags": [],
	"description": "(Until v2.2.0) ADL discovered free function hook invoked by the implicit constructors of `basic_outcome`.",
	"content": "Removed in Outcome v2.2.0, unless OUTCOME_ENABLE_LEGACY_SUPPORT_FOR is set to less than 220 to enable emulation. Use on_outcome_construction(T *, U \u0026amp;\u0026amp;) noexcept instead in new code.\nOne of the constructor hooks for basic_outcome\u0026lt;T, EC, EP, NoValuePolicy\u0026gt; , generally invoked by the implicit constructors of basic_outcome. See each constructor\u0026rsquo;s documentation to see which specific hook it invokes.\nOverridable: By Argument Dependent Lookup.\nRequires: Nothing.\nNamespace: OUTCOME_V2_NAMESPACE::hooks\nHeader: \u0026lt;outcome/basic_outcome.hpp\u0026gt;\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/functions/hooks/hook_outcome_construction2/",
	"title": "`void hook_outcome_construction(T *, U &amp;&amp;, V &amp;&amp;) noexcept`",
	"tags": [],
	"description": "(Until v2.2.0) ADL discovered free function hook invoked by the implicit constructors of `basic_outcome`.",
	"content": "Removed in Outcome v2.2.0, unless OUTCOME_ENABLE_LEGACY_SUPPORT_FOR is set to less than 220 to enable emulation. Use on_outcome_construction(T *, U \u0026amp;\u0026amp;, V \u0026amp;\u0026amp;) noexcept instead in new code.\nOne of the constructor hooks for basic_outcome\u0026lt;T, EC, EP, NoValuePolicy\u0026gt; , generally invoked by the implicit constructors of basic_outcome which consume two arguments. See each constructor\u0026rsquo;s documentation to see which specific hook it invokes.\nOverridable: By Argument Dependent Lookup.\nRequires: Nothing.\nNamespace: OUTCOME_V2_NAMESPACE::hooks\nHeader: \u0026lt;outcome/basic_outcome.hpp\u0026gt;\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/functions/hooks/hook_outcome_copy_construction/",
	"title": "`void hook_outcome_copy_construction(T *, U &amp;&amp;) noexcept`",
	"tags": [],
	"description": "(Until v2.2.0) ADL discovered free function hook invoked by the converting copy constructors of `basic_outcome`.",
	"content": "Removed in Outcome v2.2.0, unless OUTCOME_ENABLE_LEGACY_SUPPORT_FOR is set to less than 220 to enable emulation. Use on_outcome_copy_construction(T *, U \u0026amp;\u0026amp;) noexcept instead in new code.\nOne of the constructor hooks for basic_outcome\u0026lt;T, EC, EP, NoValuePolicy\u0026gt; , generally invoked by the converting copy constructors of basic_outcome (NOT the standard copy constructor). See each constructor\u0026rsquo;s documentation to see which specific hook it invokes.\nOverridable: By Argument Dependent Lookup.\nRequires: Nothing.\nNamespace: OUTCOME_V2_NAMESPACE::hooks\nHeader: \u0026lt;outcome/basic_outcome.hpp\u0026gt;\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/functions/hooks/hook_outcome_copy_construction2/",
	"title": "`void hook_outcome_copy_construction(T *, U &amp;&amp;, V &amp;&amp;) noexcept`",
	"tags": [],
	"description": "(Until v2.2.0) ADL discovered free function hook invoked by the converting copy constructors of `basic_outcome`.",
	"content": "Removed in Outcome v2.2.0, unless OUTCOME_ENABLE_LEGACY_SUPPORT_FOR is set to less than 220 to enable emulation. Use on_outcome_copy_construction(T *, U \u0026amp;\u0026amp;, V \u0026amp;\u0026amp;) noexcept instead in new code.\nOne of the constructor hooks for basic_outcome\u0026lt;T, EC, EP, NoValuePolicy\u0026gt; , generally invoked by the converting copy constructors of basic_outcome (NOT the standard copy constructor) which consume two arguments. See each constructor\u0026rsquo;s documentation to see which specific hook it invokes.\nOverridable: By Argument Dependent Lookup.\nRequires: Nothing.\nNamespace: OUTCOME_V2_NAMESPACE::hooks\nHeader: \u0026lt;outcome/basic_outcome.hpp\u0026gt;\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/functions/hooks/hook_outcome_in_place_construction/",
	"title": "`void hook_outcome_in_place_construction(T *, in_place_type_t&lt;U&gt;, Args &amp;&amp;...) noexcept`",
	"tags": [],
	"description": "(Until v2.2.0) ADL discovered free function hook invoked by the in-place constructors of `basic_outcome`.",
	"content": "Removed in Outcome v2.2.0, unless OUTCOME_ENABLE_LEGACY_SUPPORT_FOR is set to less than 220 to enable emulation. Use on_outcome_in_place_construction(T *, in_place_type_t\u0026lt;U\u0026gt;, Args \u0026amp;\u0026amp;...) noexcept instead in new code.\nOne of the constructor hooks for basic_outcome\u0026lt;T, EC, EP, NoValuePolicy\u0026gt; , generally invoked by the in-place constructors of basic_outcome. See each constructor\u0026rsquo;s documentation to see which specific hook it invokes.\nOverridable: By Argument Dependent Lookup.\nRequires: Nothing.\nNamespace: OUTCOME_V2_NAMESPACE::hooks\nHeader: \u0026lt;outcome/basic_outcome.hpp\u0026gt;\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/functions/hooks/hook_outcome_move_construction/",
	"title": "`void hook_outcome_move_construction(T *, U &amp;&amp;) noexcept`",
	"tags": [],
	"description": "(Until v2.2.0) ADL discovered free function hook invoked by the converting move constructors of `basic_outcome`.",
	"content": "Removed in Outcome v2.2.0, unless OUTCOME_ENABLE_LEGACY_SUPPORT_FOR is set to less than 220 to enable emulation. Use on_outcome_move_construction(T *, U \u0026amp;\u0026amp;) noexcept instead in new code.\nOne of the constructor hooks for basic_outcome\u0026lt;T, EC, EP, NoValuePolicy\u0026gt; , generally invoked by the converting move constructors of basic_outcome (NOT the standard move constructor). See each constructor\u0026rsquo;s documentation to see which specific hook it invokes.\nOverridable: By Argument Dependent Lookup.\nRequires: Nothing.\nNamespace: OUTCOME_V2_NAMESPACE::hooks\nHeader: \u0026lt;outcome/basic_outcome.hpp\u0026gt;\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/functions/hooks/hook_outcome_move_construction2/",
	"title": "`void hook_outcome_move_construction(T *, U &amp;&amp;, V &amp;&amp;) noexcept`",
	"tags": [],
	"description": "(Until v2.2.0) ADL discovered free function hook invoked by the converting move constructors of `basic_outcome`.",
	"content": "Removed in Outcome v2.2.0, unless OUTCOME_ENABLE_LEGACY_SUPPORT_FOR is set to less than 220 to enable emulation. Use on_outcome_move_construction(T *, U \u0026amp;\u0026amp;, V \u0026amp;\u0026amp;) noexcept instead in new code.\nOne of the constructor hooks for basic_outcome\u0026lt;T, EC, EP, NoValuePolicy\u0026gt; , generally invoked by the converting move constructors of basic_outcome (NOT the standard move constructor) which consume two arguments. See each constructor\u0026rsquo;s documentation to see which specific hook it invokes.\nOverridable: By Argument Dependent Lookup.\nRequires: Nothing.\nNamespace: OUTCOME_V2_NAMESPACE::hooks\nHeader: \u0026lt;outcome/basic_outcome.hpp\u0026gt;\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/functions/hooks/hook_result_construction/",
	"title": "`void hook_result_construction(T *, U &amp;&amp;) noexcept`",
	"tags": [],
	"description": "(Until v2.2.0) ADL discovered free function hook invoked by the implicit constructors of `basic_result`.",
	"content": "Removed in Outcome v2.2.0, unless OUTCOME_ENABLE_LEGACY_SUPPORT_FOR is set to less than 220 to enable emulation. Use on_result_construction(T *, U \u0026amp;\u0026amp;) noexcept instead in new code.\nOne of the constructor hooks for basic_result\u0026lt;T, E, NoValuePolicy\u0026gt; , generally invoked by the implicit constructors of basic_result. See each constructor\u0026rsquo;s documentation to see which specific hook it invokes.\nOverridable: By Argument Dependent Lookup.\nRequires: Nothing.\nNamespace: OUTCOME_V2_NAMESPACE::hooks\nHeader: \u0026lt;outcome/basic_result.hpp\u0026gt;\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/functions/hooks/hook_result_copy_construction/",
	"title": "`void hook_result_copy_construction(T *, U &amp;&amp;) noexcept`",
	"tags": [],
	"description": "(Until v2.2.0) ADL discovered free function hook invoked by the converting copy constructors of `basic_result`.",
	"content": "Removed in Outcome v2.2.0, unless OUTCOME_ENABLE_LEGACY_SUPPORT_FOR is set to less than 220 to enable emulation. Use on_result_copy_construction(T *, U \u0026amp;\u0026amp;) noexcept instead in new code.\nOne of the constructor hooks for basic_result\u0026lt;T, E, NoValuePolicy\u0026gt; , generally invoked by the converting copy constructors of basic_result (NOT the standard copy constructor). See each constructor\u0026rsquo;s documentation to see which specific hook it invokes.\nOverridable: By Argument Dependent Lookup.\nRequires: Nothing.\nNamespace: OUTCOME_V2_NAMESPACE::hooks\nHeader: \u0026lt;outcome/basic_result.hpp\u0026gt;\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/functions/hooks/hook_result_in_place_construction/",
	"title": "`void hook_result_in_place_construction(T *, in_place_type_t&lt;U&gt;, Args &amp;&amp;...) noexcept`",
	"tags": [],
	"description": "(Until v2.2.0) ADL discovered free function hook invoked by the in-place constructors of `basic_result`.",
	"content": "Removed in Outcome v2.2.0, unless OUTCOME_ENABLE_LEGACY_SUPPORT_FOR is set to less than 220 to enable emulation. Use on_result_in_place_construction(T *, in_place_type_t\u0026lt;U\u0026gt;, Args \u0026amp;\u0026amp;...) noexcept instead in new code.\nOne of the constructor hooks for basic_result\u0026lt;T, E, NoValuePolicy\u0026gt; , generally invoked by the in-place constructors of basic_result. See each constructor\u0026rsquo;s documentation to see which specific hook it invokes.\nOverridable: By Argument Dependent Lookup.\nRequires: Nothing.\nNamespace: OUTCOME_V2_NAMESPACE::hooks\nHeader: \u0026lt;outcome/basic_result.hpp\u0026gt;\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/functions/hooks/hook_result_move_construction/",
	"title": "`void hook_result_move_construction(T *, U &amp;&amp;) noexcept`",
	"tags": [],
	"description": "(Until v2.2.0) ADL discovered free function hook invoked by the converting move constructors of `basic_result`.",
	"content": "Removed in Outcome v2.2.0, unless OUTCOME_ENABLE_LEGACY_SUPPORT_FOR is set to less than 220 to enable emulation. Use on_result_move_construction(T *, U \u0026amp;\u0026amp;) noexcept instead in new code.\nOne of the constructor hooks for basic_result\u0026lt;T, E, NoValuePolicy\u0026gt; , generally invoked by the converting move constructors of basic_result (NOT the standard move constructor). See each constructor\u0026rsquo;s documentation to see which specific hook it invokes.\nOverridable: By Argument Dependent Lookup.\nRequires: Nothing.\nNamespace: OUTCOME_V2_NAMESPACE::hooks\nHeader: \u0026lt;outcome/basic_result.hpp\u0026gt;\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/functions/policy/outcome_throw_as_system_error_with_payload_boost_enum/",
	"title": "`void outcome_throw_as_system_error_with_payload(BoostErrorCodeEnum &amp;&amp;)`",
	"tags": [],
	"description": "Specialisation of `outcome_throw_as_system_error_with_payload()` for input types where `boost::system::is_error_code_enum&lt;BoostErrorCodeEnum&gt;` or `boost::system::is_error_condition_enum&lt;BoostErrorCodeEnum&gt;` is true.",
	"content": "A specialisation of outcome_throw_as_system_error_with_payload() for types where boost::system::is_error_code_enum\u0026lt;BoostErrorCodeEnum\u0026gt; or boost::system::is_error_condition_enum\u0026lt;BoostErrorCodeEnum\u0026gt; is true. This executes OUTCOME_THROW_EXCEPTION(expr) with a boost::system::system_error constructed from the result of the ADL discovered free function make_error_code(BoostErrorCodeEnum).\nOverridable: Argument dependent lookup.\nRequires: Either boost::system::is_error_code_enum\u0026lt;T\u0026gt; or boost::system::is_error_condition_enum\u0026lt;T\u0026gt; to be true for a decayed BoostErrorCodeEnum.\nNamespace: boost::system\nHeader: \u0026lt;outcome/boost_result.hpp\u0026gt;\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/functions/policy/outcome_throw_as_system_error_with_payload_std_enum/",
	"title": "`void outcome_throw_as_system_error_with_payload(ErrorCodeEnum &amp;&amp;)`",
	"tags": [],
	"description": "Specialisation of `outcome_throw_as_system_error_with_payload()` for input types where `std::is_error_code_enum&lt;ErrorCodeEnum&gt;` or `std::is_error_condition_enum&lt;ErrorCodeEnum&gt;` is true.",
	"content": "A specialisation of outcome_throw_as_system_error_with_payload() for types where std::is_error_code_enum\u0026lt;ErrorCodeEnum\u0026gt; or std::is_error_condition_enum\u0026lt;ErrorCodeEnum\u0026gt; is true. This executes OUTCOME_THROW_EXCEPTION(expr) with a  std::system_error constructed from the result of the ADL discovered free function make_error_code(ErrorCodeEnum).\nOverridable: Argument dependent lookup.\nRequires: Either  std::is_error_code_enum\u0026lt;T\u0026gt; or  std::is_error_condition_enum\u0026lt;T\u0026gt; to be true for a decayed ErrorCodeEnum.\nNamespace: std\nHeader: \u0026lt;outcome/std_result.hpp\u0026gt;\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/functions/policy/outcome_throw_as_system_error_with_payload_boost_error_code/",
	"title": "`void outcome_throw_as_system_error_with_payload(const boost::system::error_code &amp;)`",
	"tags": [],
	"description": "Specialisation of `outcome_throw_as_system_error_with_payload()` for `boost::system::error_code`.",
	"content": "A specialisation of outcome_throw_as_system_error_with_payload() for boost::system::error_code. This executes OUTCOME_THROW_EXCEPTION(expr) with a boost::system::system_error constructed from the input.\nOverridable: Argument dependent lookup.\nRequires: Nothing.\nNamespace: boost::system\nHeader: \u0026lt;outcome/boost_result.hpp\u0026gt;\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/functions/policy/outcome_throw_as_system_error_with_payload_std_error_code/",
	"title": "`void outcome_throw_as_system_error_with_payload(const std::error_code &amp;)`",
	"tags": [],
	"description": "Specialisation of `outcome_throw_as_system_error_with_payload()` for `std::error_code`.",
	"content": "A specialisation of outcome_throw_as_system_error_with_payload() for std::error_code. This executes OUTCOME_THROW_EXCEPTION(expr) with a  std::system_error constructed from the input.\nOverridable: Argument dependent lookup.\nRequires: Nothing.\nNamespace: std\nHeader: \u0026lt;outcome/std_result.hpp\u0026gt;\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/functions/hooks/override_outcome_exception/",
	"title": "`void override_outcome_exception(basic_outcome&lt;T, EC, EP, NoValuePolicy&gt; *, U &amp;&amp;) noexcept`",
	"tags": [],
	"description": "Overrides the exception to something other than what was constructed.",
	"content": "Overrides the exception to something other than what was constructed. You almost certainly never want to use this function. A much better way of overriding the exception returned is to create a custom no-value policy which lazily synthesises a custom exception object at the point of need.\nThe only reason that this function exists is because some people have very corner case needs where a custom no-value policy can\u0026rsquo;t be used, and where move-constructing a new outcome from an old outcome with the exception state replaced isn\u0026rsquo;t possible (e.g. when the types are non-copyable and non-moveable).\nUnless you are in a situation where no other viable alternative exists, do not use this function.\nOverridable: Not overridable.\nRequires: Nothing.\nNamespace: OUTCOME_V2_NAMESPACE::hooks\nHeader: \u0026lt;outcome/basic_outcome.hpp\u0026gt;\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/functions/hooks/set_spare_storage/",
	"title": "`void set_spare_storage(basic_result|basic_outcome *, uint16_t) noexcept`",
	"tags": [],
	"description": "Sets the sixteen bits of spare storage in the specified result or outcome.",
	"content": "Sets the sixteen bits of spare storage in the specified result or outcome. You can retrieve these bits later using uint16_t spare_storage(const basic_result|basic_outcome *) noexcept .\nOverridable: Not overridable.\nRequires: Nothing.\nNamespace: OUTCOME_V2_NAMESPACE::hooks\nHeader: \u0026lt;outcome/basic_result.hpp\u0026gt;\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/functions/strong_swap/",
	"title": "`void strong_swap(bool &amp;all_good, T &amp;a, T &amp;b)`",
	"tags": [],
	"description": "Tries to perform a strong guarantee swap.",
	"content": "The standard swap() function provides the weak guarantee i.e. that no resources are lost. This ADL discovered function provides the strong guarantee instead: that if any of these operations throw an exception (i) move construct to temporary (ii) move assign b to a (iii) move assign temporary to b, an attempt is made to restore the exact pre-swapped state upon entry, and if that recovery too fails, then the boolean all_good will be false during stack unwind from the exception throw, to indicate that state has been lost.\nThis function is used within basic_result::swap(basic_result \u0026amp;) if, and only if, either or both of value_type or error_type have a throwing move constructor or move assignment. It permits you to customise the implementation of the strong guarantee swap in Outcome with a more efficient implementation.\nOverridable: By Argument Dependent Lookup (ADL).\nRequires: That T is both move constructible and move assignable.\nNamespace: OUTCOME_V2_NAMESPACE\nHeader: \u0026lt;outcome/basic_result.hpp\u0026gt;\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/functions/try_throw_std_exception_from_error/",
	"title": "`void try_throw_std_exception_from_error(std::error_code ec, const std::string &amp;msg = std::string{})`",
	"tags": [],
	"description": "Try to throw a standard library exception type matching an error code.",
	"content": "This function saves writing boilerplate by throwing a standard library exception type equivalent to the supplied error code, with an optional custom message.\nIf the function returns, there is no standard library exception type equivalent to the supplied error code. The following codes produce the following exception throws:\n EINVAL std::invalid_argument EDOM std::domain_error E2BIG std::length_error ERANGE std::out_of_range EOVERFLOW std::overflow_error ENOMEM std::bad_alloc  The choice to refer to POSIX errno values above reflects the matching algorithm. As  std::errc exactly maps POSIX errno, on all platforms  std::generic_category error codes are matched by this function. Only on POSIX platforms only are  std::system_category error codes also matched by this function.\nOverridable: Not overridable.\nRequires: C++ exceptions to be globally enabled.\nNamespace: OUTCOME_V2_NAMESPACE\nHeader: \u0026lt;outcome/utils.hpp\u0026gt;\n"
}]